[{"title":"JavaScript 模块化规范的使用说明","url":"/posts/2b046bca.html","content":"本文介绍了常用的 JavaScript 模块化规范的使用说明，包含 ESMA6、CommonJS 等其它规范。\n\n\n视频链接\nES6 模块规范ES6 模块规范主要用于客户端，也可用于服务端。\n使用方式在 node.js 服务端有两种使用方式：\n\n将 .js 文件改为 .mjs 文件。\n或者在 package.json 中添加定义 &#39;type&#39;: &#39;module&#39; 。\n\n在浏览器端使用：\n\n在 html 文件中使用 &lt;script type=&quot;module&quot; src=&quot;index.js&quot;&gt;&lt;/script&gt; 引入。\n\n\n直接在本地使用浏览器打开 html 文件浏览器会报错，请启动 web 服务器后通过 IP:端口 访问网页。\n\n导出数据导出有三种方式：\n\n分别导出\n\n// student.jsexport const name = &#x27;zhangsan&#x27;;export const age = &#x27;18&#x27;;export function getTel ()&#123;    return &#x27;13333333333&#x27;;&#125;function getSubject ()&#123;    return [&#x27;Java&#x27;, &#x27;C++&#x27;, &#x27;高等数学&#x27;];&#125;\n\n\n统一导出\n\n// student.jsconst name = &#x27;zhangsan&#x27;;const age = &#x27;18&#x27;;function getTel ()&#123;    return &#x27;13333333333&#x27;;&#125;function getSubject ()&#123;    return [&#x27;Java&#x27;, &#x27;C++&#x27;, &#x27;高等数学&#x27;];&#125;export &#123; name, age, getTel &#125;;\n\n\n默认导出\n\n// student.jsconst name = &#x27;zhangsan&#x27;;const age = &#x27;18&#x27;;function getTel ()&#123;    return &#x27;13333333333&#x27;;&#125;function getSubject ()&#123;    return [&#x27;Java&#x27;, &#x27;C++&#x27;, &#x27;高等数学&#x27;];&#125;// export default &#123;//     name: name,//     age: age,//     getTel: getTel// &#125;;// 可省略书写export default &#123; name, age, getTel &#125;;\n\n三种导出可以混用：\n// student.jsexport const name = &#x27;zhangsan&#x27;;const age = &#x27;18&#x27;;function getTel ()&#123;    return &#x27;13333333333&#x27;;&#125;function getSubject ()&#123;    return [&#x27;Java&#x27;, &#x27;C++&#x27;, &#x27;高等数学&#x27;];&#125;export &#123; age &#125;;export default &#123; getTel &#125;;\n\n会得到：\n[Module: null prototype] &#123;  age: &#x27;18&#x27;,  default: &#123; getTel: [Function: getTel] &#125;,  name: &#x27;zhangsan&#x27;&#125;\n\n\n\n导入数据对于 ES6 模块化来说，使用何种导入方式要根据导出方式决定。\n\n全部导入（通用）\n\n// index.jsimport * as student from &#x27;./student.js&#x27;;\n\n\n命名导入（对应：分别导出、统一导出）\n\n// index.jsimport &#123; name as newName, age, getTel &#125; from &#x27;./student.js&#x27;;\n\n\n默认导入（对应：默认导出）\n\n// index.jsimport student from &#x27;./student.js&#x27;;// student 变量名可以自己取\n\n\n默认导入和命名导入可以混用（当然不能和全部导入混用）：\n// student.jsexport const name = &#x27;zhangsan&#x27;;const age = &#x27;18&#x27;;function getTel ()&#123;    return &#x27;13333333333&#x27;;&#125;function getSubject ()&#123;    return [&#x27;Java&#x27;, &#x27;C++&#x27;, &#x27;高等数学&#x27;];&#125;export &#123; age &#125;;export default &#123; getTel &#125;;// index.jsimport newFun, &#123; name, age &#125; frome &#x27;./student.js&#x27;;\n\n\n直接导入不接收任何数据\n\n// log.jsconsole.log(&#x27;hello world!&#x27;);// index.jsimport &#x27;./log.js&#x27;;// 导入时 console.log() 会执行\n\n\n动态导入（通用）\n\n导入还可以根据事件来进行动态导入，下面的例子将演示当点击按钮时才导入：\n// student.jsconst name = &#x27;zhangsan&#x27;;const age = &#x27;18&#x27;;function getTel ()&#123;    return &#x27;13333333333&#x27;;&#125;function getSubject ()&#123;    return [&#x27;Java&#x27;, &#x27;C++&#x27;, &#x27;高等数学&#x27;];&#125;export &#123; name, age, getTel &#125;;// index.jsconst btn = document.getElementById(&#x27;btn&#x27;);btn.onclick = async() =&gt; &#123;    const result = await import(&#x27;./student.js&#x27;);    console.log(result);&#125;\n\n\n\n\nCommonJS 规范CommonJS 规范主要用于服务端，如果想要在浏览器端使用，可以通过 browserify 将原本的 js 文件进行翻译，再将翻译后的文件在 html 中引用。\n导出数据在 CommonJS 规范中有两种导出方式，导出的是一个普通对象，默认为 &#123;&#125;。\n通过 exports：\n// student.jsconst name = &#x27;zhangsan&#x27;;const age = &#x27;18&#x27;;function getTel ()&#123;    return &#x27;13333333333&#x27;;&#125;function getSubject ()&#123;    return [&#x27;Java&#x27;, &#x27;C++&#x27;, &#x27;高等数学&#x27;];&#125;exports.name = name;exports.age = age;exports.getTel = getTel;// 当然也可以使用 module.exports.name = name 只是书写更麻烦;\n\n通过 module.exports：\n// student.jsconst name = &#x27;zhangsan&#x27;;const age = &#x27;18&#x27;;function getTel ()&#123;    return &#x27;13333333333&#x27;;&#125;function getSubject ()&#123;    return [&#x27;Java&#x27;, &#x27;C++&#x27;, &#x27;高等数学&#x27;];&#125;// module.exports = &#123;//     name: name,//     age: age,//     getTel: getTel// &#125;;// 可省略书写module.exports = &#123; name, age, getTel &#125;;\n\n导入数据导入时会执行被导入文件中的代码：\n// student.jsconsole.log(&#x27;hello&#x27;);// index.jsconst student = require(&#x27;./student.js&#x27;);console.log(student);// 会输出：// hello// &#123;&#125;\n\n导入时也能通过解构赋值：\n// index.jsconst &#123; name: newName, age, getTel &#125; = require(&#x27;./student.js&#x27;); // 解构导入并重命名\n\n\n\n注意注意点如下：\n\n每个模块内部的：this、exports、module.exports 在初始时都指向同一个空对象。console.log(this===exports &amp;&amp; exports === module.exports); // true。\n无论如何修改导出对象，最终导出的都是 module.exports 的值。\nexports 是对 module.exports 的初始引用，仅为了方便给导出对象添加属性，所以不能使用 exports = value 的形式导出数据，可以使用 exports.value = value 、module.exports = value 导出数据。\n\n思考以下代码在导入时获取到的数据是什么？\n// student.jsconst name = &#x27;zhangsan&#x27;;const age = &#x27;18&#x27;;function getTel ()&#123;    return &#x27;13333333333&#x27;;&#125;function getSubject ()&#123;    return [&#x27;Java&#x27;, &#x27;C++&#x27;, &#x27;高等数学&#x27;];&#125;exports = &#123; a: 1 &#125;;exports.b = 2;module.exports.c = 3;module.exports = &#123; d: 4 &#125;;\n\n// index.jsconst student = require(&#x27;./student.js&#x27;);console.log(student);// 输出：&#123; d: 4 &#125;\n\n分析：\n\nexports -&gt; &#123;&#125; &lt;- module.exports\nexports -&gt; &#123; a: 1 &#125; ；module.exports -&gt; &#123;&#125;\nexports -&gt; &#123; a: 1, b: 2 &#125;；module.exports -&gt; &#123;&#125;\nexports -&gt; &#123; a: 1, b: 2 &#125;；module.exports -&gt; &#123; c: 3 &#125;\nexports -&gt; &#123; a: 1, b: 2 &#125;；没有东西指向 &#123; c: 3 &#125; ；module.exports -&gt; &#123; d: 4 &#125;\n\n模块化的好处模块化能够有效解决：\n\n全局污染问题\n数据安全问题\n依赖混乱问题\n\n1、全局污染、数据安全问题\n在使用模块化以前：\n// student.jsconst name = &#x27;zhangsan&#x27;;const age = &#x27;18&#x27;;function getTel ()&#123;    return &#x27;13333333333&#x27;;&#125;function getSubject ()&#123;    return [&#x27;Java&#x27;, &#x27;C++&#x27;, &#x27;高等数学&#x27;];&#125;\n\n&lt;!-- index.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;student.js&quot;&gt;&lt;/script&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;/body&gt;&lt;/html&gt;\n\n此时在浏览器控制台是能够获取到 name、age 等变量的，并且如果引入的多个文件有相同的变量名会产生冲突。\n使用模块化以后：\n// student.jsconst name = &#x27;zhangsan&#x27;;const age = &#x27;18&#x27;;function getTel ()&#123;    return &#x27;13333333333&#x27;;&#125;function getSubject ()&#123;    return [&#x27;Java&#x27;, &#x27;C++&#x27;, &#x27;高等数学&#x27;];&#125;export default &#123; name, age, getTel &#125;;// index.jsimport student from &#x27;./student.js&#x27;;\n\n&lt;!-- index.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;script type=&quot;module&quot; src=&quot;index.js&quot;&gt;&lt;/script&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;/body&gt;&lt;/html&gt;\n\n此时在浏览器控制台是无法获取到 student.name 变量的，而且在导入模块时能够对冲突的变量重命名，解决了数据安全、全局污染问题。\n2、依赖混乱问题\n在使用模块化以前，直接在 html 文件中引入 js 的顺序至关重要，尤其是需要引入多个 js 文件时，特别需要关注他们的依赖关系来确定引入顺序，十分麻烦。使用模块化后，可以在各个 js 文件中显式导入需要使用到的模块，而不用关心 html 文件中引入 js 的顺序。\n数据引入问题思考同一代码在 CommonJS 规范和 ES6 规范的执行结果：\n\nCommonJS 规范\n\n// data.jslet sum = 1;function increment() &#123;    sum += 1;&#125;module.exports = &#123; sum, increment &#125;;// index.jsconst &#123; sum, increment &#125; = require(&#x27;./data.js&#x27;);console.log(sum);increment();increment();console.log(sum);\n\n\n输出：\n1data: 2data: 31\n\n\nES6 规范\n\n// data.jslet sum = 1;function increment() &#123;    sum += 1;&#125;export &#123; sum, increment &#125;;// index.jsimport &#123; sum, increment &#125; from &#x27;./data.js&#x27;;console.log(sum);increment();increment();console.log(sum);\n\n\n输出：\n1data: 2data: 33\n\n对比两者发现，ES6 规范中执行完函数后的 sum 的值不一样了，是因为 index.js 和 data.js 中的 sum 是同一片内存空间（在 CommonJS 规范中导入是将值进行了复制），为了避免这种情况应该在 data.js 中声明常量而不是变量，即改为 const sum = 1。\n其它规范AMD 规范 是 RequireJS 在推广过程中对模块定义的规范化产出。\nCMD 规范 是 SeaJS 在推广过程中对模块定义的规范化产出。\n","categories":["学习笔记","前端知识"],"tags":["JavaScript","ESMA6","CommonJS"]},{"title":"Spring Boot 参数校验","url":"/posts/f00bce88.html","content":"Spring Boot 中使用 JSR 对前端传来的数据进行校验的过程。 \n\n\n\n本文省略对返回结果和响应枚举类型的封装。\n\n导入包&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;&lt;/dependency&gt;\n\n在 spring-boot-starter-web 中已包含上述包。\n统一异常处理@Slf4j@RestControllerAdvicepublic class GlobalExceptionHandler &#123;    // 处理 @Valid 校验失败异常    @ExceptionHandler(MethodArgumentNotValidException.class)    public JSONResult&lt;Void&gt; handlerValidationException(MethodArgumentNotValidException e) &#123;        log.warn(&quot;参数校验失败：&quot; + e.getMessage(), e);        String errorMessage = e.getBindingResult()                .getAllErrors()                .stream()                .map(ObjectError::getDefaultMessage)                .collect(Collectors.joining(&quot;;&quot;));        return JSONResult.error(StatusCodeEnum.FAIL.getCode(), errorMessage);    &#125;        // 处理其它异常...&#125;\n\n\n\nJSR 注解校验UserVO\n@Datapublic class UserVO &#123;    @NotNull(message = &quot;用户名不能为空&quot;)    private String username;&#125;\n\nController\n@PostMapping(value=&quot;/save&quot;)// 接口接收参数上添加 @Valid 注解进行校验public JSONResult insert(@RequestBody @Valid UserVO vo)&#123;\tuserService.insert(vo);    return JSONResult.success();&#125;\n\n接收到前端发送请求后会对数据进行校验，如果校验失败会抛出 MethodArgumentNotValidException 异常，全局异常处理器将捕获到异常进行处理。\n测试当前端请求：\n&#123;    &quot;username&quot;: &quot;&quot;&#125;\n\n后端返回：\n&#123;    &quot;code&quot;: 400,    &quot;message&quot;: &quot;用户名不能为空&quot;&#125;\n\n\n","categories":["学习笔记","后端知识"],"tags":["Spring Boot"]},{"title":"KMP 算法实现及改良","url":"/posts/853edc9f.html","content":"与每趟匹配失败都从头开始重新比较的暴力匹配算法不同，KMP 算法会按照已记录的数组移动到指定位置开始比较，能大幅提高效率。而该数组记录的内容仅与模式串本身结构相关，与主串无关。\n\n\n理论知识设：\n\nababcabcacbab 为主串, i 为主串的遍历指针\nabcac 为子串， j 为子串（也称模式串）的遍历指针\npm 数组  为对应字符串的部分匹配值\nnext 数组 由 pm 数组 右移一位得到，其中规定 next[0] = -1\n\n\n\n\nindex\n0\n1\n2\n3\n4\n\n\n\nchar\na\nb\nc\na\nc\n\n\npm\n0\n0\n0\n1\n0\n\n\nnext\n-1\n0\n0\n0\n1\n\n\n在 KMP 算法匹配过程中，假设第 j 位失配（从 0 编号）\n已知：移动位数 = 已经匹配的字符数（0 ~ j-1 共 j 个） - 最后一个匹配字符的部分匹配值（pm[j-1]）\n记为：move = j - pm[j-1]\n替换：move = j - next[j]\n则 j 需要回退到 j - move 位置，即  j = j - move = j - (j - next[j]) = next[j] ，即 j 回退到 next[j] 位置\n具体匹配过程：\n\n第一次匹配（失配时 i = 2, j = 2）\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ni：\n0\n1\n2\n\n\n\n\n\n\n\n\n\n\n\n\n主串：\na\nb\na\nb\nc\na\nb\nc\na\nc\nb\na\nb\n\n\n子串：\na\nb\nc\n\n\n\n\n\n\n\n\n\n\n\n\nj：\n0\n1\n2\n\n\n\n\n\n\n\n\n\n\n\n\n\n子串应向后移动 2 位，j = 2 —-&gt; j = 0 （next[2] == 0），i = 2 —-&gt; i = 2 （ i 不变）\n\n\n第二次匹配（失配时 i = 6, j = 4）\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ni：\n0\n1\n2\n3\n4\n5\n6\n\n\n\n\n\n\n\n\n主串：\na\nb\na\nb\nc\na\nb\nc\na\nc\nb\na\nb\n\n\n子串：\n#\n#\na\nb\nc\na\nc\n\n\n\n\n\n\n\n\nj：\n\n\n0\n1\n2\n3\n4\n\n\n\n\n\n\n\n\n\n子串应继续向后移动 3 位，j = 4 —-&gt; j = 1 （next[4] == 1），i = 6 —-&gt; i = 6 （ i 不变）\n\n\n第三次匹配（匹配成功 i = 10, j = 5）\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ni：\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n\n主串：\na\nb\na\nb\nc\na\nb\nc\na\nc\nb\na\nb\n\n\n子串：\n#\n#\n*\n*\n*\na\nb\nc\na\nc\n\n\n\n\n\nj：\n\n\n\n\n\n0\n1\n2\n3\n4\n5\n\n\n\n\n\n匹配成功，返回子串在主串中的首位置：i - j = 5\n\n\n\n所以 KMP 算法如何实现的问题就转化为如何构建 next 数组的问题。\n手动如何求 next 数组呢？\n\n法一：先求部分匹配值，再右移得到 next 数组\n法二：由 [0…j-1]个字符（已经匹配成功的字符）组成的串的最长相等前后缀长度就是 next[j]\n\n\n注：不同书中定义的 next 数组含义不同，有的是没有右移之前的，有的是右移一位的（如本文），有的是右移一位后数值再加 1 的，要具体情况具体分析。另外，本文中数组从 0 开始存字符，有的书可能从 1 开始，对应的代码会有些许差别。\n\n代码实现第一步：求 next 数组\nvoid getNextTable(string pattern,int nextTable[])&#123;      nextTable[0] = -1; //第一个默认为-1      int j=0; //j表示next数组下标      int k=nextTable[j]; //k表示next数组的值      while(j &lt; pattern.size())&#123; //求next[j+1]          if(k==-1 || pattern[j] == pattern[k])&#123;              nextTable[++j]=++k;              //相当于 j++; next[j]=k+1; 计算出 next[j+1]，然后令 k=next[j]; 继续循环        &#125;else&#123;              k = nextTable[k];          &#125;      &#125;  &#125;\n\n第二步：根据 next 数组编写 KMP 算法\nint KMP(string pattern, string str,int nextTable[])&#123;      getNextTable(pattern,nextTable);//得到next数组      int i=0; int j=0;      while(i&lt;str.size() &amp;&amp; j&lt;pattern.size())&#123;          if(j==-1 || pattern[j]==str[i])&#123;              i++;             j++; //匹配成功则继续匹配          &#125;        else              j = nextTable[j];//匹配失败则回溯          &#125;      if(j==pattern.size())          return i-j; //返回子串在主串的首位置(下标从零开始)      else          return -1;  &#125; \n\n第三步：测试\n#include &lt;iostream&gt;  using namespace std;  int main()&#123;      string s=&quot;abcac&quot;;      string d=&quot;ababcabcacbab&quot;;      int nextTable[s.size()];     cout&lt;&lt;KMP(s,d,nextTable)&lt;&lt;endl; //匹配成功返回子串在主串的首位置，不匹配返回 -1    return 0;&#125;\n\n算法改良假设 j == 3 时失配，而 next[3] == 2, next[2] == 1, next[1] == 0, next[0] == -1 （由计算 next 数组的规则可知，此时模式串中第 0、1、2 个字符必相同），则 j 需要依次回退到 2、1、0，我们可以改善 next 数组，让 j 直接回退到 0 位置，减少无效判断次数。\n用 nextval数组 表示改良后的 next数组，过程如下：\n\n先算出 next 数组（next[0] = -1）\n如果第 j 个字符和 j 的 next 所指向的字符相同，则它们的 nextval 值相同；否则让 j 的 nextval 值与 next 值相等。\n\n代码如下：\nvoid getNextvalTable(string pattern,int nextvalTable[])&#123;      nextvalTable[0] = -1; //第一个默认为-1      int j=0; //j表示nextval数组下标      int k=nextvalTable[j]; //k表示nextval数组的值      while(j &lt; pattern.size())&#123; //求nextval[j+1]          if(k==-1 || pattern[j] == pattern[k])&#123;              if(pattern[++j] == pattern[++k])                nextvalTable[j] = nextvalTable[k];             else                nextvalTable[j] = k; //相当于nextval[j+1]=k+1; k=nextval[j+1]; j++;          &#125;else&#123;              k = nextvalTable[k];          &#125;      &#125;  &#125;\n\nKMP 算法只要将其调用的函数 getNextTable 改为 getNextvalTable ，其余保持不变。\n手动计算部分匹配值部分匹配值为字符串的前缀和后缀的最长相等前后缀长度，以 ababa 为例：\n\na 的前缀和后缀都为空集，最长相等前后缀长度为 0\nab 的前缀为 { a }，后缀为 { b } ，交集为空集，最长相等前后缀长度为 0\naba 的前缀为 { a, ab }，后缀为 { a, ba }，交集为 { a }，最长相等前后缀长度为 1\nabab 的前缀为 { a, ab, aba }，后缀为 { b, ab, bab }，交集为 { ab }，最长相等前后缀长度为 2\nababa 的前缀为 { a, ab, aba, abab }，后缀为 { a, ba, aba, baba }，交集为 { a, aba }，最长相等前后缀长度为 3所以字符串 ababa 的部分匹配值为 00123\n\n参考《王道数据结构考研复习指导》\n","categories":["学习笔记","数据结构与算法"],"tags":["KMP"]},{"title":"Spring Boot 整合 Swagger 实现接口文档","url":"/posts/448c169.html","content":"本文介绍 OpenApi、Swagger、SpringFox 和 SpringDoc 之间的区别，以及 SpringBoot 如何整合并使用 Swagger 实现接口文档。\n\n名词解释\nOpenApi 是什么？\n\n解答： OpenApi 是一个用于描述、定义和共享 RESTful API 文档的规范。最新规范是 OpenAPI 3.0。\n\nSwagger 是什么？\n\n解答： Swagger 是一个用于设计和测试 RESTful API 的工具，是无关语言的。它提供了 API 描述、请求和响应示例、API 测试和文档生成等丰富的功能。最新版本是 Swagger 3，支持 OpenAPI 3.0 规范。\n\nSpringFox 是什么？\n\n解答： SpringFox 是 Spring 社区维护的一个项目（非官方），帮助使用者将 Swagger 2 集成到 Spring 中。\n地址：https://github.com/springfox/springfox\n\nSpringDoc 是什么？\n\n解答： SpringDoc 也是 Spring 社区维护的一个项目（非官方），帮助使用者将 Swagger 3 集成到 Spring 中。SpringDoc 支持 Swagger 页面、Oauth2 登录，相较于 SpringFox 而言，它的支撑时间更长，无疑是更好的选择。\n地址：https://springdoc.org/\n\n它们之间的关系\n\n解答： OpenAPI 定义了一种标准的格式来表示 API 文档，而 Swagger 是一个实现 OpenAPI 规范的工具，而 SpringFox 和 SpringDoc 都是将 Swagger 继承到 Spring 框架中方便使用。\n开始如何将 Swagger 集成到 SpringBoot 中？\n环境\nJDK 17\nSpringBoot 3\n\n在 SpringBoot 3 之前用的都是 SpringFox 来集成 Swagger 管理我们的 API 接口文档，但是 SpringFox 已经停止更新了，本次我们使用的是 SpringBoot 3 、JDK 17 的环境，推荐使用 SpringDoc 来整合 Swagger。\n添加依赖&lt;dependency&gt;    &lt;groupId&gt;org.springdoc&lt;/groupId&gt;    &lt;artifactId&gt;springdoc-openapi-starter-webmvc-ui&lt;/artifactId&gt;    &lt;version&gt;2.8.8&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springdoc&lt;/groupId&gt;    &lt;artifactId&gt;springdoc-openapi-starter-webmvc-api&lt;/artifactId&gt;    &lt;version&gt;2.8.8&lt;/version&gt;&lt;/dependency&gt;\n\n\n编写 Controller 类@RestControllerpublic class HelloController &#123;     @RequestMapping(&quot;/hello&quot;)    public String hello()&#123;        return &quot;hello&quot;;    &#125;&#125;\n\n访问接口页面浏览器直接输入：http://localhost:8080/swagger-ui/index.html 回车即可看到下面界面：\n\n配置在 application.yml 中可以自定义 api-docs 和 swagger-ui 的访问路径，扫描的指定包等等。\nspringdoc:  api-docs:    path: /v3/api-docs    enabled: false # 关闭接口文档，可针对 application-dev.yml / application-test 进行不同配置  swagger-ui:    path: /swagger-ui.html  packages-to-scan: com.example.swaggerdemo.common.controller # 只显示 common 包下的接口\n\n可以通过配置类来自定义 swagger-ui 页面信息：\n@OpenAPIDefinition(        // 不同环境的服务器地址        servers = &#123;                @Server(description = &quot;开发环境服务器&quot;, url = &quot;http://localhost:8080&quot;),                @Server(description = &quot;测试环境服务器&quot;, url = &quot;https://test.xiezhr.com&quot;)        &#125;,        // 配置外部文档地址        externalDocs = @ExternalDocumentation(                description = &quot;项目编译部署说明&quot;,                url = &quot;http://localhost:8080/deplay/readme.md&quot;        )) @Configurationpublic class SpringDocConfig &#123;     @Bean    public OpenAPI openAPI() &#123;        return new OpenAPI()                // 配置接口文档基本信息                .info(this.getApiInfo())                ;    &#125;     private Info getApiInfo() &#123;        return new Info()                 // 配置文档标题                .title(&quot;SpringBoot3集成Swagger3&quot;)                // 配置文档描述                .description(&quot;SpringBoot3集成Swagger3示例文档&quot;)                // 配置作者信息                .contact(new Contact().name(&quot;程序员小凡&quot;).url(&quot;https://www.xiezhrspace.cn&quot;).email(&quot;1666397814@163.com&quot;))                // 配置License许可证信息                .license(new License().name(&quot;Apache 2.0&quot;).url(&quot;https://www.xiezhrspace.cn&quot;))                //                .summary(&quot;SpringBoot3集成Swagger3示例文档aaa&quot;)                .termsOfService(&quot;https://www.xiezhrspace.cn&quot;)                 // 配置版本号                .version(&quot;2.0&quot;);    &#125;    // 对接口进行分组    @Bean(&quot;commonGroupApi&quot;)    public GroupedOpenApi webGroupApi() &#123;        return GroupedOpenApi.builder().group(&quot;common通用模块组&quot;)            .pathsToMatch(&quot;/common/**&quot;)            .build();    &#125;     @Bean(&quot;adminGroupApi&quot;)    public GroupedOpenApi adminGroupApi() &#123;        return GroupedOpenApi.builder().group(&quot;admin模块组&quot;)            .pathsToMatch(&quot;/admin/**&quot;)            .build();    &#125;&#125;\n\n\n\n注解使用Controller 类① @Tag 注解，用于类上。\n\nname: 名称\ndescription: 接口描述信息\n\n② @Operation 注解，用在方法上。\n\nsummary：方法概要，方法的一个简单介绍，建议 120 个字符内\ndescription：方法描述，一般是很长的内容\nhidden：是否隐藏\n\n③@Parameter 注解，用在方法参数上。\n\nname：指定的参数名\nin：参数位置，可选 query、header、path 或 cookie，默认为空，表示忽略\ndescription：参数描述\nrequired：是否必填，默认为 false\n\n④ @ApiResponse 注解，用于说明一个响应信息，用在 @ApiResponses 中。\n\nresponseCode：HTTP 响应码\ndescription：描述\n\n@RestController@RequestMapping(&quot;/common&quot;)@Tag(name = &quot;公共接口&quot;, description = &quot;公共接口&quot;)public class CommonController &#123;     @Autowired    private IUserService userService;    @GetMapping(&quot;/hello&quot;)   @Operation(summary = &quot;hello接口&quot;, description = &quot;hello接口描述&quot;, hidden = true)    public String hello()&#123;        return &quot;hello&quot;;    &#125;     @GetMapping(&quot;/hi&quot;)    @Operation(summary = &quot;hi接口&quot;, description = &quot;hi接口描述&quot;)    public String Hi()&#123;        return &quot;Hi 程序员小凡&quot;;    &#125;     @GetMapping(&quot;/user/&#123;id&#125;&quot;)    @Operation(summary = &quot;获取用户信息&quot;, description = &quot;根据用户ID获取用户信息&quot;)    @ApiResponses(value =&#123;            @ApiResponse(responseCode = &quot;200&quot;, description = &quot;请求成功&quot;),            @ApiResponse(responseCode = &quot;404&quot;, description = &quot;用户不存在&quot;)    &#125;)    public User getUser( @Parameter(name = &quot;id&quot;, in = ParameterIn.PATH, description = &quot;用户ID&quot;, required = true) @PathVariable(&quot;id&quot;) Integer id)&#123;        User user = userService.getUserById(id);        return user;    &#125;&#125;\n\n\n⑤@RequestHeader 注解。\n很多时候我们接口都需要认证之后才能访问，这时候我们就需要接口调用的时候携带着 token 信息，我们通过 @RequestHeader 注解，获取请求头中 token 信息。\n@GetMapping(&quot;/index&quot;)public String  admin(@RequestHeader (&quot;token&quot;) String token)&#123;\tSystem.out.println(&quot;token&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot; + token);    //token 验证    //.....各种业务逻辑    return &quot;admin&quot;;&#125;\n\n\n实体类@Schema 注解，用于描述数据对象信息或数据对象属性，用在类或类属性上。\n\nname: 属性名称\ndescription: 属性描述\nrequired: 是否必须\nminLength: 字符最小长度\nmaxLength: 字符最大长度\n\n@Data@Schema(description = &quot;用户实体类&quot;, name = &quot;User&quot;)public class User &#123;    @Schema(description = &quot;用户名&quot;, name = &quot;name&quot;, minLength = 6, maxLength = 20, required = true)    private String name;    @Schema(description = &quot;年龄&quot;, name = &quot;age&quot;, required = true, minimum = &quot;1&quot;, maximum = &quot;100&quot;)    private Integer age;    @Schema(description = &quot;邮箱&quot;, name = &quot;email&quot;, required = true)    private String email;    @Schema(description = &quot;地址&quot;, name = &quot;address&quot;)    private String address;&#125;\n\n\n","categories":["学习笔记","后端知识"],"tags":["Spring Boot","Swagger"]},{"title":"出栈顺序个数之卡特兰数","url":"/posts/6fd3c141.html","content":"在数据结构中有个问题：n 个元素进栈，共有多少种出栈顺序？\n\n\n答案：\n分析可以利用动态规划里面的子问题来进行推导。\n把 n 个元素的出栈顺序个数的记为 f(n)：\n\n当 n = 1 时，假设元素是 ( a )，那么出栈顺序只有 ( a )，则 \n当 n = 2 时，假设元素是 ( a b )，那么出栈顺序有 ( a b ) ( b a )，则 \n当 n = 3 时，假设元素是 ( a b c )，那么出栈顺序有 ( a b c ) ( a c b ) ( b a c ) ( b c a ) ( c b a )，则 \n\n当 n = 4 时, 假设元素是 ( a b c d )，那么：元素 a 结果只可能出现在 1 号位置，2 号位置，3 号位置和 4 号位置。\n分析：\n\n如果元素 a 在 1 号位置，那么只可能 a 先进栈且马上出栈，此时还剩 3 个元素等待操作，就是子问题 f(3)\n\n如果元素 a 在 2 号位置，那么一定有 1 个元素比 a 先出栈（只能是 b ），即有 f(1) 种可能顺序。一定有 2 个元素比 a 后出栈，即有 f(2) 种可能顺序，根据乘法原理一共的顺序个数为 \n\n如果元素 a 在 3 号位置，那么一定有 2 个元素比 a 先出栈，即有 f(2) 种可能顺序。一定有 1 个元素比 a 后出栈（只能是 d ），即有 f(1) 种可能顺序，根据乘法原理一共的顺序个数为 \n\n如果元素 a 在 4 号位置，那么在 a 最后出栈前已经有 3 个元素进行了入栈出栈操作，就是子问题 f(3)\n\n\n结合所有情况，即  。\n我们定义 。于是可以重新写为： 。\n推广到 n，于是我们可以得到： 。\n\n习题：元素 ABCDE 依次入栈，则以下（）是不可能的出栈次序。\nA、ABCDE\nB、EDCBA\nC、BADCE\nD、DBCAE\n答案：D\n解析：看 A 的位置 n，结果中排在 A 左边的元素一定是 A 的后 n - 1 个元素当中的。比如 D 选项：A 在结果中的位置是 4，那么结果中排在 A 左边的元素一定只能是 A 的后 3 个元素（即 B C D）当中的，此时符合。但是还要判断以 A 为界，左右两个子问题是否符合此规律。对于左边子问题 D B C ，同理要看 B 的位置，B 在子问题结果中的位置是 2，结果中排在 B 左边的元素一定只能是 B 的后 1 个元素，即出现在 B 的左边一定只能是 C，所以不符合。\n总结：判断原问题是否符合规则，若符合则继续判断子问题是否符合。\n\n求通项可通过折线法求得通项： 。\n要求：有两种操作即入栈和出栈，要求每种操作的总次数一样，且进行第 k 次出栈前必须先进行至少 k 次入栈。\n假设：一个人从原点出发，入栈是此人沿右上角 45° 走一个单位（一个单位长为 ）。出栈是此人沿右下角 45° 走一个单位。\n因为有入栈和出栈操作的次数相同的限制，所以最后必将到到达点  。\n因为有第 k 次出栈前必须先进行至少 k 次入栈的限制，导致走出来的折线不会跨越 x 轴走到  这条线上。\n\n如果没有限制第 k 次出栈前必须先进行至少 k 次入栈，只要求两种操作各 n 次，那么其不同折线共有  种可能，其中减去不合法的可能就是要求的内容。\n\n对于任意跨越 x 轴的折线情况，找出第一个与  相交的点 k，将 k 点以右的折线根据  对称。可以发现终点最终都会从  对称到 。\n我们可以得出所有跨越了 x 轴的折线总数与从  到  的折线总数相等。\n而从  到  的折线表示的是入栈和出栈的总数是 2n 且出栈的数量比入栈多了 2 次，则出栈 n+1 次，入栈 n-1次。所以其不同折线有  或者  种可能。\n所以合法的折线有  种可能。\n得证  。\n参考文章n个元素进栈，共有多少种出栈顺序？ - 止战 - 博客园\n卡特兰数的证明及其应用 - _Dinosaur_Po - 博客园\n","categories":["学习笔记","数据结构与算法"],"tags":["栈","卡特兰数"]},{"title":"Spring Framework","url":"/posts/874e8d58.html","content":"Spring Framework 是一个功能强大的 Java 应用程序框架，旨在提供高效且可扩展的开发环境。它结合了轻量级的容器和依赖注入功能，提供了一种使用 POJO 进行容器配置和面向切面的编程的简单方法，以及一组用于 AOP 的模块。\n\n\n\n\nSpring 两大核心机制：\n\nIoC（控制反转）：工厂模式\nAOP（面向切面编程）：代理模式\n\n开发步骤1、创建 Maven 工程，在 pom.xml 导入依赖：\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-framework-context&lt;/artifactId&gt;    &lt;version&gt;6.2.4&lt;/version&gt;&lt;/dependency&gt;\n\n2、在 resources 路径下创建 spring.xml：\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;bean id=&quot;student&quot; class=&quot;com.kecho.entity.Student&quot;/&gt;&lt;/beans&gt;\n\n3、获取 IoC 容器中已经创建的对象：\nApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);// 通过 bean id 获取，返回值需要强制类型转换Student student = (Student) context.getBean(&quot;student&quot;);// 也可以通过类名获取，但要确保容器中只有一个该类型的 bean// Student student = context.getBean(Student.class);System.out.println(student.toString());\n\n\n\n常用标签beanbean 标签用于创建一个对象，id 是唯一标识，class 是完全限定类名，name 可以同时取多个别名，别名之间可以使用空格或逗号或分号分隔。\n&lt;bean id=&quot;student&quot; class=&quot;com.kecho.entity.Student&quot; name=&quot;student1 student2 student3&quot;/&gt;\n\naliasalias 可用于配置别名，alias 的 name 对应需要取别名的 bean 的 id。\n&lt;bean id=&quot;student&quot; class=&quot;com.kecho.entity.Student&quot;/&gt;&lt;alias name=&quot;student&quot; alias=&quot;stuNew&quot; /&gt;\n\nimportimport 用于导入其它配置文件。\n&lt;import resource=&quot;beans1.xml&quot;/&gt;&lt;import resource=&quot;beans2.xml&quot;/&gt;\n\n\n\n创建顺序IoC 容器默认情况下是通过 spring.xml 中 bean 的配置顺序来决定创建顺序的，配置在前⾯的 bean 会先创建。在不更改配置顺序的前提下，通过 depends-on 来设置 bean 之间的依赖关系，从而调整 bean 的创建顺序。\n&lt;bean id=&quot;student&quot; class=&quot;com.kecho.entity.Student&quot; depends-on=&quot;cat&quot;/&gt;&lt;bean id=&quot;cat&quot; class=&quot;com.kecho.entity.Cat&quot;/&gt;\n\n上述代码的结果是先创建 Cat，再创建 Student 对象。\n创建方式IoC 容器通过读取 spring.xml 配置文件，按照顺序加载 bean 标签来创建对象，相当于替代了手动去 new 一个对象的过程，而创建对象的方式主要有两种：构造函数和 Setter 方法。\n通过构造函数IoC 容器通过对应构造函数去创建对象，这也要求实体类必须有对应的构造函数。\n\n无参构造函数（实体类必须有无参构造函数）\n\n&lt;bean id=&quot;student&quot; class=&quot;com.kecho.entity.Student&quot;&gt;&lt;/bean&gt;\n\n\n有参构造函数（实体类必须有相同参数列表的有参构造函数）\n\n&lt;bean id=&quot;student&quot; class=&quot;com.kecho.entity.Student&quot;&gt;    &lt;constructor-arg name=&quot;id&quot; value=&quot;1&quot;/&gt;    &lt;constructor-arg name=&quot;name&quot; value=&quot;kecho&quot;/&gt;    &lt;constructor-arg name=&quot;age&quot; value=&quot;18&quot;/&gt;&lt;/bean&gt;\n\n使用 name 时，参数顺序必须和构造函数中的参数顺序保持一致，其中 String 类型会自动转 int 类型（实体类 Student 中的 id 和 age 均为 int 类型）。\n你也可以使用 index 来避免顺序不一致导致可能出现的问题：\n&lt;bean id=&quot;student&quot; class=&quot;com.kecho.entity.Student&quot;&gt;    &lt;constructor-arg index=&quot;1&quot; value=&quot;kecho&quot;/&gt;    &lt;constructor-arg index=&quot;2&quot; value=&quot;18&quot;/&gt;    &lt;constructor-arg index=&quot;0&quot; value=&quot;1&quot;/&gt;&lt;/bean&gt;\n\n还可以使用 type 根据参数类型来匹配构造函数创建 bean（如果有多个有参构造函数，通过参数类型无法匹配到唯一的构造函数时会报错）：\n&lt;bean id=&quot;student&quot; class=&quot;com.kecho.entity.Student&quot;&gt;    &lt;constructor-arg type=&quot;int&quot; value=&quot;1&quot;/&gt;    &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;kecho&quot;/&gt;    &lt;constructor-arg type=&quot;int&quot; value=&quot;18&quot;/&gt;&lt;/bean&gt;\n\n\n\n通过 Setter 方法IoC 容器通过 Setter 方法去创建对象，这要求对应字段在实体类中必须有对应的 Setter 方法。\n&lt;bean id=&quot;student&quot; class=&quot;com.kecho.entity.Student&quot;&gt;    &lt;property name=&quot;id&quot; value=&quot;1&quot;/&gt;    &lt;property name=&quot;name&quot; value=&quot;kecho&quot;/&gt;    &lt;property name=&quot;age&quot; value=&quot;18&quot;/&gt;&lt;/bean&gt;\n\n如果我想把 name 的值设置为 &lt;小二&gt;，因为字符串包含了特殊字符，应该改用 CDATA 格式：\n&lt;bean id=&quot;student&quot; class=&quot;com.kecho.entity.Student&quot;&gt;    &lt;property name=&quot;id&quot; value=&quot;1&quot;/&gt;    &lt;property name=&quot;name&quot;&gt;        &lt;value&gt;&lt;![CDATA[&lt;小二&gt;]]]&gt;&lt;/value&gt;    &lt;/property&gt;    &lt;property name=&quot;age&quot; value=&quot;18&quot;/&gt; &lt;/bean&gt;\n\n\n\n两种创建方式的写法非常相似，主要是 constructor-arg 和 property 的不同，接下来的示例主要以 Setter 方法为主，构造器注入同理。\n依赖注入DI 是指 bean 之间的依赖注入，用于设置对象之间的级联关系。此时应该改用 ref 而不能改用 value，否则会抛出类型转换异常。除了 ref，还有数组、 List、Set、Map、Properties 类型，下面将使用 Setter 方式注入展示各种类型的写法：\n实体类 Student：\n@Data@ToString@AllArgsConstructor@NoArgsConstructorpublic class Student &#123;    private String name;    private Cat cat;    private String[] books;    private List&lt;String&gt; hobbys;    private Set&lt;String&gt; games;    private Map&lt;String,String&gt; card;    private String spouse;    private Properties info;&#125;\n\nspring.xml：\n&lt;bean id=&quot;cat&quot; class=&quot;com.kecho.entity.Cat&quot;/&gt;&lt;bean id=&quot;student&quot; class=&quot;com.kecho.entity.Student&quot;&gt;    &lt;!-- 普通值注入 value --&gt;    &lt;property name=&quot;name&quot; value=&quot;张三&quot; /&gt;    &lt;!-- 引用注入 ref --&gt;    &lt;property name=&quot;cat&quot; ref=&quot;cat&quot;/&gt;    &lt;!-- 数组 --&gt;    &lt;property name=&quot;books&quot;&gt;        &lt;array&gt;            &lt;value&gt;红楼梦&lt;/value&gt;            &lt;value&gt;西游记&lt;/value&gt;        &lt;/array&gt;    &lt;/property&gt;    &lt;!-- List --&gt;    &lt;property name=&quot;hobbys&quot;&gt;        &lt;list&gt;            &lt;value&gt;听歌&lt;/value&gt;            &lt;value&gt;敲代码&lt;/value&gt;        &lt;/list&gt;    &lt;/property&gt;    &lt;!-- Set --&gt;    &lt;property name=&quot;games&quot;&gt;        &lt;set&gt;            &lt;value&gt;LOL&lt;/value&gt;            &lt;value&gt;王者荣耀&lt;/value&gt;        &lt;/set&gt;    &lt;/property&gt;    &lt;!-- Map --&gt;    &lt;property name=&quot;card&quot;&gt;        &lt;map&gt;            &lt;entry key=&quot;身份证&quot; value=&quot;123456123412121234&quot;/&gt;        &lt;/map&gt;    &lt;/property&gt;    &lt;!-- null --&gt;    &lt;property name=&quot;spouse&quot;&gt;        &lt;null/&gt;    &lt;/property&gt;    &lt;!-- Properties --&gt;    &lt;property name=&quot;info&quot;&gt;        &lt;props&gt;            &lt;prop key=&quot;学号&quot;&gt;111111&lt;/prop&gt;            &lt;prop key=&quot;性别&quot;&gt;男&lt;/prop&gt;        &lt;/props&gt;    &lt;/property&gt;&lt;/bean&gt;\n\n上面如果改用构造器注入又改怎么写呢？只需要将 property 改成 constructor-arg 即可。\n命名空间c 命名空间c 命名空间对应构造器注入。\n使用 c 命名空间应在 xml 头部引入约束：xmlns:c=&quot;http://www.springframework.org/schema/c&quot;：\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:c=&quot;http://www.springframework.org/schema/c&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;bean id=&quot;cat&quot; class=&quot;com.kecho.entity.Cat&quot; c:name=&quot;咪咪&quot;/&gt;    &lt;bean id=&quot;student&quot; class=&quot;com.kecho.entity.Student&quot;           c:name=&quot;kecho&quot; c:id=&quot;1&quot; c:age=&quot;18&quot; c:cat-ref=&quot;cat&quot;/&gt;&lt;/beans&gt;\n\n\n\np 命名空间p 命名空间对应 Setter 方法注入。\n使用 p 命名空间应在 xml 头部引入约束：xmlns:p=&quot;http://www.springframework.org/schema/p&quot;：\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;bean id=&quot;cat&quot; class=&quot;com.kecho.entity.Cat&quot; p:name=&quot;咪咪&quot;/&gt;        &lt;bean id=&quot;student&quot; class=&quot;com.kecho.entity.Student&quot;     \tp:name=&quot;kecho&quot; p:id=&quot;1&quot; p:age=&quot;18&quot; p:cat-ref=&quot;cat&quot;/&gt;&lt;/beans&gt;\n\n\n\n\n\n作用域bean 是根据 scope 来⽣成，表示 bean 的作⽤域，scope 有4种类型：\n\nsingleton，单例，表示通过容器获取的对象是唯⼀的，默认值。\nprototype，原型，表示通过容器获取的对象是不同的。\nrequest，请求，表示在⼀次 HTTP 请求内有效。\nsession，会话，表示在⼀个⽤户会话内有效。\n\nrequset，session 适⽤于 Web 项⽬。\nsingleton 模式下，只要加载 IoC 容器，⽆论是否从 IoC 中取出 bean，配置⽂件中的 bean 都会被创建。prototype 模式下，如果不从 IoC 中取 bean，则不创建对象，取⼀次 bean，就会创建⼀个对象。\n&lt;bean id=&quot;student&quot; class=&quot;com.kecho.entity.Student&quot; scope=&quot;prototype&quot;/&gt;\n\n也可以通过对类添加注解 @Scope(&quot;prototype&quot;) 来实现同样功能。\n懒加载默认情况下，ApplicationContext 的实现会急切地创建和配置所有的单例 bean，你可以通过将 bean 定义标记为懒加载来阻止单例 bean 的预实例化。懒加载的 bean 告诉 IoC 容器在第一次被请求时创建一个 bean 实例，而不是在启动时。\n&lt;bean id=&quot;student&quot; class=&quot;com.example.Student&quot; lazy-init=&quot;true&quot;/&gt;\n\n当懒加载 bean 是被未懒加载的单例 bean 所依赖时，ApplicationContext 会在启动时创建懒加载 bean。\n你也可以通过使用 &lt;beans&gt; 元素上的 default-lazy-init 属性来控制容器级的懒加载：\n&lt;beans default-lazy-init=&quot;true&quot;&gt;    &lt;!-- no beans will be pre-instantiated... --&gt;&lt;/beans&gt;\n\n\n\n读取外部资源实际开发中，数据库的配置⼀般会单独保存到后缀为 properties 的⽂件中，⽅便维护和修改，如果使⽤ Spring 来加载数据源，就需要在 spring.xml 中读取 properties 中的数据，这就是读取外部资源。\njdbc.properties\nuser = rootpassword = rooturl = jdbc:mysql://localhost:3306/librarydriverName = com.mysql.cj.jdbc.Driver\n\nspring.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;    &lt;!-- 导⼊外部资源 --&gt;    &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt;    &lt;!-- SpEL --&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;com.southwind.entity.DataSource&quot;&gt;        &lt;property name=&quot;user&quot; value=&quot;$&#123;user&#125;&quot;/&gt;        &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt;        &lt;property name=&quot;driverName&quot; value=&quot;$&#123;driverName&#125;&quot;/&gt;        &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n\n\n工厂方法IoC 通过⼯⼚模式创建 bean 有两种⽅式：静态⼯⼚⽅法和实例⼯⼚⽅法，区别在于静态⼯⼚类不需要实例化，实例⼯⼚类需要实例化。\n静态⼯⼚⽅法1、创建 Car 类\n@Data@AllArgsConstructorpublic class Car &#123;\tprivate Integer num;\tprivate String brand;&#125;\n\n2、创建静态⼯⼚类、静态⼯⼚⽅法\npublic class StaticCarFactory&#123;\tprivate static Map&lt;Integer, Car&gt; carMap;\tstatic &#123;         carMap = new HashMap&lt;&gt;();        carMap.put(1,new Car(1,&quot;奥迪&quot;));        carMap.put(2,new Car(2,&quot;奥拓&quot;));\t&#125;\tpublic static Car getCar(Integer num)&#123;\t\treturn carMap.get(num);    &#125;&#125;\n\n3、spring.xml\n&lt;bean id=&quot;car1&quot; class=&quot;com.example.factory.StaticCarFactory&quot; factory-method=&quot;getCar&quot;&gt;\t&lt;constructor-arg value=&quot;1&quot;&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;\n\nfactory-method 指向静态⽅法，constructor-arg 的 value 属性是调⽤静态⽅法传⼊的参数。\n实例⼯⼚⽅法1、创建实例⼯⼚类、⼯⼚⽅法\npublic class InstanceCarFactory&#123;\tprivate Map&lt;Integer, Car&gt; carMap;\tpublic InstanceCarFactory() &#123;         carMap = new HashMap&lt;&gt;();        carMap.put(1,new Car(1,&quot;奥迪&quot;));        carMap.put(2,new Car(2,&quot;奥拓&quot;));\t&#125;\tpublic Car getCar(Integer num)&#123;\t\treturn carMap.get(num);    &#125;&#125;\n\n2、spring.xml\n&lt;bean id=&quot;instanceCarFactory&quot; class=&quot;com.example.factory.InstanceCarFactory&quot;/&gt;&lt;bean id=&quot;car2&quot; factory-bean=&quot;instanceCarFactory&quot; factory-method=&quot;getCar&quot;&gt;\t&lt;constructor-arg value=&quot;2&quot;&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;\n\n静态⼯⼚⽅法创建 Car 对象，不需要实例化⼯⼚对象，因为静态⼯⼚的静态⽅法，不需要创建对象即可调⽤，spring.xml 中只需要配置⼀个 bean，即最终的结果 Car 即可。\n实例⼯⼚⽅法创建 Car 对象，需要实例化⼯⼚对象，因为 getCar ⽅法是⾮静态的，就必须通过实例化对象才能调⽤，所以就必须要创建⼯⼚对象，spring.xml 中需要配置两个 bean，⼀个是⼯⼚ bean，⼀个是 Car bean。\n自动装载已知有两个实体类 Student 和 Cat。\nStudent：\n@Data@ToStringpublic class Student &#123;    private int id;    private String name;    private int age;    private Cat cat;&#125;\n\nCat：\n@Datapublic class Cat &#123;    private String name;&#125;\n\nspring.xml：\n&lt;bean id=&quot;cat&quot; class=&quot;com.kecho.entity.Cat&quot;&gt;    &lt;property name=&quot;name&quot; value=&quot;咪咪&quot;/&gt;&lt;/bean&gt;&lt;bean id=&quot;student&quot; class=&quot;com.kecho.entity.Student&quot; autowire=&quot;byName&quot;&gt;    &lt;property name=&quot;id&quot; value=&quot;1&quot;/&gt;    &lt;property name=&quot;name&quot; value=&quot;kecho&quot;/&gt;    &lt;property name=&quot;age&quot; value=&quot;18&quot;/&gt;&lt;/bean&gt;\n\n最终得到 Student(id=1, name=kecho, age=18, cat=Cat(name=咪咪))，通过 autowire 可以自动地将 cat 装载到 student 中，即使未显示使用 ref 声明。\nautowire 有两个值：byName 和 byType。\nbyName 会去找和 set 方法后面的值相同的 bean id 的 bean 自动装载，没有相同的则会报错。\nbyType 会去找和成员变量的数据类型相同的 bean 自动装载，如果容器中有两个相同类型的 bean 则会报错。\n基于注解开发使用注解开发需要：\n\n导入 context 约束\n配置注解支持\n\n以下创建 bean 时没有使用到 Setter 方法。\n手动创建需要在 xml 中手动声明 bean：\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;    &lt;context:annotation-config/&gt;    &lt;bean id=&quot;cat&quot; class=&quot;com.kecho.entity.Cat&quot;/&gt;    &lt;bean id=&quot;student&quot; class=&quot;com.kecho.entity.Student&quot;/&gt;&lt;/beans&gt;\n\n此时可以使用 @Value 来设置属性值，使用 @Autowired 实现自动装载：\npublic class Student &#123;    @Value(&quot;1&quot;)    private int id;    @Value(&quot;kecho&quot;)    private String name;    @Value(&quot;18&quot;)    private int age;        @Autowired    private Cat cat;&#125;\n\n如果容器中没有这个 bean，@Autowired 会自动装配失败报错，可以使用 @Autowired(require = false) 来允许为空。\n@Autowired 默认通过 byType 的方式来查找 bean，如果存在多个相同类型的 bean 也会无法自动装配，可以加上 @Qualifier(value = &quot;beanid&quot;) 指定装配相应 id 的 bean，不带参数的 @Qualifier 默认指定 id 与属性名对应的 bean。\n\n除了使用 @Autowired，Java 也有自己的注解 @Resource 实现相同的功能，也可以通过 @Resource(name = &quot;bean id&quot;) 指定 bean id 来自动装配对应的 bean。\n不同于 @Autowired 通过 byType 的方式来查找 bean，@Resource 默认通过 byName 的方式实现，如果找不到名字则通过 byType 的方式。\n\n自动扫描为了避免每个 bean 都需要自己手动去创建，可以配置扫描包：\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;    &lt;context:annotation-config/&gt;    &lt;context:component-scan base-package=&quot;com.kecho.entity&quot;/&gt;&lt;/beans&gt;\n\n此时使用 @Component 来自动加载：\n@Componentpublic class Student &#123;    @Value(&quot;1&quot;)    private int id;    @Value(&quot;kecho&quot;)    private String name;    @Value(&quot;18&quot;)    private int age;    @Autowired(required = false)    private Cat cat;&#125;\n\n除了 @Component 外，还有 @Repository、@Service、@Controller，这些注解的功能是一样的。\n@Configuration除了在 xml 配置文件中进行创建 bean、配置 context 约束、配置扫描包路径、配置注解的支持等等，还可以在 Java 类中进行配置：\nMyConfig 类：\n@Configuration // 相当于 beans 标签public class MyConfig &#123;    // 相当于一个 bean 标签    @Bean    public Student myStudent() &#123;  // Student 是 bean 的类型，myStudent 是 bean id        return new Student(1, &quot;kecho&quot;, 18);    &#125;&#125;\n\n获取 bean：\n// 不再通过 xml 文件获取上下文ApplicationContext context = new AnnotationConfigApplicationContext(MyConfig.class);User user = context.getBean(&quot;myUser&quot;, User.class);\n\n\n\n如果要自动扫描包来加载 bean，可以为 MyConfig 类设置 @ComponentScan(&quot;com.kecho.entity&quot;)，同时搭配 @Component 来自动加载 bean。如下：\nMyConfig 类：\n@Configuration@ComponentScan(&quot;com.kecho.entity&quot;)public class MyConfig &#123;&#125;\n\nStudent 类：\n@Componentpublic class Student &#123;    @Value(&quot;1&quot;)    private int id;    @Value(&quot;kecho&quot;)    private String name;    @Value(&quot;18&quot;)    private int age;    @Autowired(required = false)    private Cat cat;&#125;\n\n\n\n\n\nIoC控制反转（Inversion of Control，简称 IoC）是一种设计思想，它将对象的创建和依赖关系的管理交给容器，而不是在代码中直接控制对象的创建和依赖关系。IoC 的核心思想是通过容器来管理对象的生命周期和依赖关系，从而实现对象之间的松耦合。\n思想/* dao */public interface Fruit &#123;    public void get();&#125;/* daoImpl */public class Apple implements Fruit &#123;    public void get()&#123;        System.out.println(&quot;get a Apple&quot;);    &#125;&#125;public class Banana implements Fruit &#123;    public void get()&#123;        System.out.println(&quot;get a Banana&quot;);    &#125;&#125;/* service */public interface UserService &#123;    public void getFruit();&#125;/* serviceImpl */public UserServiceImpl implements UserService &#123;    private Fruit fruit = new Apple();        public void getFruit() &#123;        fruit.get();    &#125;&#125;/* 主程序测试 */public class MyTest &#123;    public static void main(String[] args) &#123;        UserService user = new UserServiceImpl();        user.getFruit(); // 输出 &quot;get a Apple&quot;     &#125;&#125;\n\n目前的控制权在业务层，每次用户需求改变时业务层也要跟着改变，即需要修改 UserServiceImpl 中的代码，如果工程量较大修改起来会很麻烦，而且修改代码容易对其它业务造成影响，可以考虑把控制权交给用户。\n修改业务层的代码实现控制权的转换，程序由主动创建对象变为被动接收对象：\n/* serviceImpl */public class UserServiceImpl implements UserService &#123;    private Fruit fruit;        // 利用 set 方法动态获取值的注入    public void setFruit(Fruit fruit) &#123;        this.fruit = fruit;    &#125;    public void getFruit() &#123;        this.fruit.get();    &#125;&#125;/* 主程序测试 */public class MyTest &#123;    public static void main(String[] args) &#123;        UserService user = new UserServiceImpl();        user.setFruit(new Apple());        //user.setFruit(new Banana());        user.getFruit();     &#125;&#125;\n\n在 spring.xml 中就是这么配置：\n&lt;bean id=&quot;apple&quot; class=&quot;com.example.dao.Apple&quot;/&gt;&lt;bean id=&quot;banana&quot; class=&quot;com.example.dao.Banana&quot;/&gt;&lt;bean id=&quot;userServiceImpl&quot; class=&quot;com.example.service.UserServiceImpl&quot;&gt;    &lt;property name=&quot;fruit&quot; ref=&quot;apple&quot; /&gt;&lt;/bean&gt;\n\n\n\n实现原理核⼼技术点：XML 解析 + 反射机制\n具体的思路：\n1、根据需求编写 XML ⽂件，配置需要创建的 bean。\n2、编写程序读取 XML ⽂件，获取 bean 相关信息，类、属性、id。\n3、根据第 2 步获取到的信息，结合反射机制动态创建对象，同时完成属性的赋值。\n4、将创建好的 bean 存⼊ Map 集合，设置 key - value 映射，key 就是 bean 中 id 值，value 就是 bean 对象。\n5、提供⽅法从 Map 中通过 id 获取到对应的 value。\n下面将自定义一个 MyClassPathXmlApplicationContext 类来实现。\n首先需要在 pom.xml 引入依赖解析 xml 文件：\n&lt;dependency&gt;    &lt;groupId&gt;dom4j&lt;/groupId&gt;    &lt;artifactId&gt;dom4j&lt;/artifactId&gt;    &lt;version&gt;1.6.1&lt;/version&gt;&lt;/dependency&gt;\n\n自定义 MyClassPathXmlApplicationContext 类（这里假设 bean 的属性仅为 int 或 String 类型）：\npublic class MyClassPathXmlApplicationContext implements ApplicationContext &#123;    private Map&lt;String, Object&gt; iocMap;    public MyClassPathXmlApplicationContext(String path) &#123;        iocMap = new HashMap&lt;&gt;();        parseXml(path);    &#125;    public void parseXml(String path)&#123;        SAXReader reader = new SAXReader();        try &#123;            Document document = reader.read(&quot;src/main/resources/&quot; + path);            Element rootElement = document.getRootElement();            Iterator&lt;Element&gt; elementIterator = rootElement.elementIterator();            while (elementIterator.hasNext()) &#123;                Element bean = elementIterator.next();                String beanID = bean.attributeValue(&quot;id&quot;);                String beanClassName = bean.attributeValue(&quot;class&quot;);                // 反射创建对象                Class myClass = Class.forName(beanClassName);                Constructor constructor = myClass.getConstructor();                Object object = constructor.newInstance();                // 给属性赋值                Iterator&lt;Element&gt; propertyIterator = bean.elementIterator();                while (propertyIterator.hasNext()) &#123;                    Element property = propertyIterator.next();                    String propertyName = property.attributeValue(&quot;name&quot;);                    String propertyValue = property.attributeValue(&quot;value&quot;);                    // 获取 setter 方法                    String methodName = &quot;set&quot; + propertyName.substring(0, 1).toUpperCase() + propertyName.substring(1);                    // 获取属性和方法                    Field field = myClass.getDeclaredField(propertyName);                    Method method = myClass.getMethod(methodName, field.getType());                    Object value = propertyValue;                    // 类型转换（这里假设 bean 的属性仅为 int 或 String 类型）                    switch (field.getType().getName())&#123;                        case &quot;java.lang.String&quot;:                            break;                        case &quot;int&quot;:                        case &quot;java.lang.Integer&quot;:                            value = Integer.parseInt(propertyValue);                            break;                    &#125;                    // 调用方法                    method.invoke(object, value);                &#125;                // 存入 Map                iocMap.put(beanID, object);            &#125;        &#125; catch (Exception e)&#123;            e.printStackTrace();        &#125;    &#125;        @Override    public Object getBean(String beanID) throws BeansException &#123;        return iocMap.get(beanID);    &#125;        // 省略其它需要重写的方法......&#125;\n\nspring.xml 配置：\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd &quot;&gt;    &lt;bean id=&quot;student&quot; class=&quot;com.kecho.entity.Student&quot;&gt;        &lt;property name=&quot;id&quot; value=&quot;1&quot;/&gt;        &lt;property name=&quot;name&quot; value=&quot;kecho&quot;/&gt;        &lt;property name=&quot;age&quot; value=&quot;18&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n测试类：\npublic static void main(String[] args  )&#123;    ApplicationContext context = new MyClassPathXmlApplicationContext(&quot;spring.xml&quot;);    Student student = (Student) context.getBean(&quot;student&quot;);    System.out.println(student);&#125;\n\n\n\n\nAOP","categories":["学习笔记","后端知识"],"tags":["Spring"]},{"title":"常用编程语言基础语法对比","url":"/posts/d0f4f654.html","content":"本文将对 Java、Go、Python 等编程语言的基础语法进行对比。\n\n\n导入包\n                \n                    JavaGoPython\n                \n                package com.example.main;import com.example.myapp.MyClass;import com.example.main.TestClass;package mainimport (    &quot;fmt&quot;    &quot;foo/bar&quot; // 导入本地包    myBar &quot;foo/bar&quot; // 别名    &quot;github.com/username/myproject/foo&quot; // 导入三方包)import module_name_1import module_name_2 as aliasfrom module_name_3 import class_name, func_namefrom module_name_4 import *  # 导入所有内容module = __import__(&#x27;module_name_5&#x27;)  # 动态导入\n          \n\n\n控制结构\n                \n                    JavaGoPython\n                \n                if 结构\nif ( condition1 ) &#123;    // ...&#125; else if ( condition2 ) &#123;    // ...&#125; else &#123;    // ...&#125;\n\nswitch 结构，多行语句不需要花括号但需要手动写 break;\nswitch ( val ) &#123;    case val1:        // ...        // ...        break;    case val2:        // ...        break;    default:        // ...&#125;\n\n循环结构\nfor ( int i = 0; i &lt; 10; i++ ) &#123;    count++;&#125;while ( condition ) &#123;    // ...&#125;do &#123;    // ...&#125; while ( condition );\n不需要小括号\n\nif 结构\nif condition1 &#123;    // ...&#125; else if condition2 &#123;    // ...    &#125; else &#123;    // ...&#125;\n\nswitch 结构，多行语句不需要花括号且不需要手动写 break;\nswitch val &#123;    case val1:        // ...        // ...    case val2:        // ...    default:        // ...&#125;\n\n循环结构，没有 while 关键字但有 for - range 结构\nfor i := 0; i &lt; 10; i++ &#123;    // ...&#125;for condition &#123;    // ...&#125;for pos, char := range myStr &#123;    // ...&#125;\n需要冒号，不需要花括号，小括号可省略，\n\nif 结构\nif condition1:    # ...elif condition2:    # ...elif condition3:    # ...else:    # ...\n\n没有 switch 结构，可以使用 and 或 or 来组合多个条件\nif condition1 or condition2:    # ...else:    # ...\n\n循环结构\nfor i in range(10):    # ...for letter in &#x27;Python&#x27;:   print(&quot;当前字母: %s&quot; % letter)while condition:    # ...\n          \n","categories":["学习笔记","编程语言"]},{"title":"正则表达式","url":"/posts/2f57a694.html","content":"正则表达式是用字符串描述的一个匹配规则，使用正则表达式可以快速判断给定的字符串是否符合匹配规则。\n\n\n常见匹配规则\n\n\n正则表达式\n含义\n备注\n\n\n\n\\\n转义字符\n常用于转义 \\、(、[、&#123; 等\n\n\n^\n匹配字符串开头（第一个字符之前）\n\n\n\n$\n匹配字符串结尾（最后一个字符之后）\n^A\\d&#123;3&#125;$ 可匹配 A001、A380\n\n\n.\n除 \\n、\\r 之外的任意单个字符\n注意 [.] 只会匹配 . 字符，等价于 \\.\n\n\nA\n指定字符 A\n\n\n\n\\u548c\n指定 Unicode 字符\n\\u548c 可匹配 和\n\n\n\\b\n匹配一个单词边界，即字与空格间的位置\n作用类似于 ^、$，注意 \\bCha 和 Cha\\b 的区别\n\n\n\\B\n\\b 的反义，即非单词边界匹配\n\n\n\n\\d\n数字 0~9\n相当于 [0-9]\n\n\n\\D\n\\d 的反义，即非数字\n相当于 [^0-9]\n\n\n\\w\n大小写字母，数字和下划线\n相当于 [A-Za-z0-9_]\n\n\n\\W\n\\w 的反义\n\n\n\n\\s\n匹配空白字符，如空格、制表符等\n相当于 [ \\t\\v\\r\\n\\f]\n\n\n\\S\n\\s 的反义，即非空白符\n\n\n\n*\n任意个数\nA* 可匹配  、A、AA、AAA、…\n\n\n+\n至少一个\nA+ 可匹配 A、AA、…\n\n\n?\n0 或 1 个（也用于 非贪婪匹配 ）\nA? 可匹配  、A\n\n\n&#123;3&#125;\n指定个数，此处指定为 3 个\nA&#123;3&#125; 可匹配 AAA\n\n\n&#123;2,3&#125;\n指定个数范围\nA&#123;2,3&#125; 可匹配 AA、AAA\n\n\n&#123;2,&#125;\n至少个数，此处为至少 2 个\nA&#123;2,&#125; 可匹配 AA、AAA、AAAA、…\n\n\n&#123;0,2&#125;\n至多个数，此处为至多 2 个\nA&#123;0,2&#125; 可匹配  、A、AA\n\n\nX|Y\n匹配 X 或 Y\n(z|f)ood 可匹配 zood 和 food\n\n\n[ABC]\n匹配 [...] 内的任意单个字符\n[ABC] 可匹配 A、B、C\n\n\n[^ABC]\n匹配除指定字符之外的任意单个字符\n[^ABC] 可匹配 D、1、_\n\n\n[A-C1-3X]\n匹配指定范围内的单个字符\n[A-C1-3XY] 可匹配 A、B、C、1、2、3、X\n\n\n[^A-C]\n匹配指定范围之外的任意单个字符\n[^A-C] 可匹配 D、1、_、…\n\n\nex1(?=ex2)\n查找 ex1，但后面是 ex2\n\n\n\nex1(?!ex2)\n查找 ex1，但后面不是 ex2\n\n\n\n(?&lt;=ex2)ex1\n查找 ex1，但前面是 ex2\n\n\n\n(?&lt;!ex2)ex1\n查找 ex1，但前面不是 ex2\n\n\n\n\n\n可使用 (...) 将子规则括起来\n定位符（如 ^、$、/b、/B）不能与限定符（?、*、+、&#123;2,4&#125; 等）一起使用\n\n\n正则表达式默认使用贪婪匹配：任何一个规则，它总是尽可能多地向后匹配。* 和 + 限定符都是贪婪的，它们会尽可能多的匹配文字，在它们的后面加上一个 ? 可以实现非贪婪或最小匹配。\n修饰符带有修饰符的正则表达式格式：/pattern/flags\n\n\n\n修饰符 flags\n含义\n备注\n\n\n\ni\n不区分大小写\n默认区分大小写\n\n\ng\n全局匹配\n查找所有匹配项，默认找到一项就停止\n\n\nm\n多行匹配\n使边界字符 ^ 和 $ 匹配每一行的开头和结尾\n\n\ns\n特殊字符圆点 . 中包含换行符 \\n\n默认是不包含的\n\n\n非打印字符\n\n\n字符\n含义\n\n\n\n\\cx\n匹配由 x 指明的控制字符。例如 \\cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 &#39;c&#39; 字符。\n\n\n\\t\n匹配一个制表符。等价于 \\x09 和 \\cI\n\n\n\\v\n匹配一个垂直制表符。等价于 \\x0b 和 \\cK\n\n\n\\r\n匹配一个回车符。等价于 \\x0d 和 \\cM\n\n\n\\n\n匹配一个换行符。等价于 \\x0a 和 \\cJ\n\n\n\\f\n匹配一个换页符。等价于 \\x0c 和 \\cL\n\n\n\\s\n匹配任何空白字符。等价于 [ \\t\\v\\r\\n\\f]。注意 Unicode 正则表达式会匹配全角空格符。\n\n\n\\S\n匹配任何非空白字符。等价于 [^ \\t\\v\\r\\n\\f]\n\n\n参考\n廖雪峰的官方网站-正则表达式\n菜鸟教程-正则表达式\n正则表达式手册\n\n","categories":["学习笔记","通用工具"],"tags":["正则表达式"]},{"title":"Handsome 主题美化教程","url":"/posts/ffa86c2a.html","content":"Handsome 是一款收费的 Typecho 主题，本文给出的 Handsome 主题美化教程收集自网络，部分内容可能随着主题更新而失效。\n\n\n\n首页列表最前方广告位新年倒计时&lt;style&gt;   .gn_box &#123;    border: none;         border-radius: 15px;   &#125;   .gn_box &#123;    padding: 10px 14px;    margin: 10px;    margin-bottom: 20px;    text-align: center;    background-color: #fff;   &#125;   #t_d &#123;    color: #982585;    font-size: 18px;   &#125;   #t_h &#123;     color: #8f79c1;    font-size: 18px;  &#125;   #t_m &#123;     color: #65b4b5;    font-size: 18px;  &#125;   #t_s &#123;    color: #83caa3;    font-size: 18px;   &#125; &lt;/style&gt; &lt;div class=&quot;gn_box&quot;&gt;     &lt;h1&gt;    &lt;font color=#E80017&gt;2&lt;/font&gt;&lt;font color=#D1002E&gt;0&lt;/font&gt;&lt;font color=#BA0045&gt;2&lt;/font&gt;&lt;font color=#A3005C&gt;1&lt;/font&gt;&lt;font  color=#8C0073&gt;年&lt;/font&gt;&lt;font color=#75008A&gt;-&lt;/font&gt;&lt;font color=#5E00A1&gt;新&lt;/font&gt;&lt;font color=#4700B8&gt;年&lt;/font&gt;&lt;font color=#3000CF&gt;倒&lt;/font&gt;&lt;font color=#1900E6&gt;计&lt;/font&gt;&lt;font color=#0200FD&gt;时&lt;/font&gt;  &lt;/h1&gt;  &lt;center&gt;    &lt;div id=&quot;CountMsg&quot; class=&quot;HotDate&quot;&gt;      &lt;span id=&quot;t_d&quot;&gt; 天&lt;/span&gt;&lt;span id=&quot;t_h&quot;&gt; 时&lt;/span&gt;&lt;span id=&quot;t_m&quot;&gt; 分&lt;/span&gt;&lt;span id=&quot;t_s&quot;&gt; 秒&lt;/span&gt;    &lt;/div&gt;  &lt;/center&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;   function getRTime() &#123;         var EndTime = new Date(&#x27;2021/02/12 00:00:00&#x27;);        var NowTime = new Date();        var t = EndTime.getTime() - NowTime.getTime();         var d = Math.floor(t / 1000 / 60 / 60 / 24);         var h = Math.floor(t / 1000 / 60 / 60 % 24);         var m = Math.floor(t / 1000 / 60 % 60);         var s = Math.floor(t / 1000 % 60);       var day = document.getElementById(&quot;t_d&quot;);      if (day != null) &#123;          day.innerHTML = d + &quot; 天&quot;;         &#125;      var hour = document.getElementById(&quot;t_h&quot;);      if (hour != null) &#123;          hour.innerHTML = h + &quot; 时&quot;;        &#125;      var min = document.getElementById(&quot;t_m&quot;);      if (min != null) &#123;          min.innerHTML = m + &quot; 分&quot;;         &#125;      var sec = document.getElementById(&quot;t_s&quot;);      if (sec != null) &#123;          sec.innerHTML = s + &quot; 秒&quot;;      &#125;  &#125;     setInterval(getRTime, 1000);   &lt;/script&gt;\n\n自定义 CSS以下内容添加到后台主题外观设置-开发者设置-自定义 CSS\n头像呼吸环和鼠标悬停旋转放大.img-full &#123;    width: 100px;    border-radius: 50%;    animation: light 4s ease-in-out infinite;    transition: 0.5s;&#125;.img-full:hover &#123;    transform: scale(1.15) rotate(720deg);&#125;@keyframes light &#123;    0% &#123;        box-shadow: 0 0 4px #f00;    &#125;    25% &#123;        box-shadow: 0 0 16px #0f0;    &#125;    50% &#123;        box-shadow: 0 0 4px #00f;    &#125;    75% &#123;        box-shadow: 0 0 16px #0f0;    &#125;    100% &#123;        box-shadow: 0 0 4px #f00;    &#125;&#125;\n\n打赏图标跳动.btn-pay &#123;    animation: star 0.5s ease-in-out infinite alternate;&#125;@keyframes star &#123;    from &#123;        transform: scale(1);    &#125;    to &#123;        transform: scale(1.1);    &#125;&#125;\n\n自定义鼠标指针可以使用下面代码，或者直接下载插件 HoerMouse 使用\nbody &#123;    cursor:url(&#x27;鼠标指针图片链接&#x27;), auto;&#125;select, input, textarea, a, button &#123;    cursor:url(&#x27;鼠标指针图片链接&#x27;), auto;&#125;input[disabled], select[disabled], textarea[disabled], input[readonly], select[readonly] &#123;    cursor:url(&#x27;鼠标指针图片链接&#x27;), auto;&#125;\n\n自定义右侧滚动条/*定义滚动条高宽及背景 高宽分别对应横竖滚动条的尺寸*/::-webkit-scrollbar&#123;    width: 3px;    height: 16px;    background-color: rgba(255,255,255,0);&#125;/*定义滚动条轨道 内阴影+圆角*/::-webkit-scrollbar-track&#123;    -webkit-box-shadow: inset 0 0 6px rgba(0,0,0,0.3);    border-radius: 10px;    background-color: rgba(255,255,255,0);&#125;/*定义滑块 内阴影+圆角*/::-webkit-scrollbar-thumb&#123;    border-radius: 10px;    -webkit-box-shadow: inset 0 0 6px rgba(0,0,0,.3);    background-color: #555;&#125;\n\n首页文章列表悬浮.blog-post .panel:not(article) &#123;    transition: all 0.3s;&#125;.blog-post .panel:not(article):hover &#123;    transform: translateY(-10px);    box-shadow: 0 8px 15px rgba(73, 90, 47, 0.5);&#125;\n\n首页文章列表宽度盒子模型下我感觉页面有点小，但非盒子模型下首页文章列表感觉太宽了，特别在首页设置了大头图情况下，图片看起来就更不美观了，所以可以用以下代码改窄一点。\n.blog-post&#123;  max-width: 900px;  margin: 0 auto;&#125;\n\n首页文章版式阴影化.panel&#123;    box-shadow: 1px 1px 3px 3px rgba(255,255,255, 0.35);    -moz-box-shadow: 1px 1px 3px 3px rgba(255,255,255, 0.35);&#125;.panel:hover&#123;    box-shadow: 1px 1px 3px 3px rgba(135 206 250, 0.35);    -moz-box-shadow: 1px 1px 3px 3px rgba(135 206 250, 0.35);&#125;.panel-small&#123;    box-shadow: 1px 1px 3px 3px rgba(255,255,255, 0.35);    -moz-box-shadow: 1px 1px p3x 3px rgba(255,255,255, 0.35);&#125;.panel-small:hover&#123;    box-shadow: 1px 1px p3x 3px rgba(135 206 250, 0.35);    -moz-box-shadow: 1px 1px 3px 3px rgba(135 206 250, 0.35);&#125;.app.container &#123;box-shadow: 0 0 30px rgba(255, 255, 255, 0.3);&#125;span.baidu-record::before &#123;    font: normal normal normal 12px/1 FontAwesome;    content: &quot;\\f024&quot;;    margin-right: 3px;&#125;\n\n首页文章标题颜色渐变.index-post-title a:hover&#123;     color:rgba(107, 209, 255, 1);     transition:color 0.2s linear&#125;\n\n文章标题居中.panel h2&#123;    text-align: center; &#125;.post-item-foot-icon&#123;    text-align: center;&#125;\n\n文章图片悬停放大.entry-thumbnail &#123;    overflow: hidden;&#125;/*如果想放大并超出范围请删除上面代码*/#post-content img &#123;    border-radius: 10px;    transition: 0.5s;&#125;#post-content img:hover &#123;    transform: scale(1.05);&#125;\n\n文章末尾转载说明可使用插件 Copyright\n自定义 JavaScript以下内容添加到后台主题外观设置-开发者设置-自定义 JavaScript\n鼠标点击爱心! function (e, t, a) &#123;  function n() &#123;    c(&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &#x27;&#x27;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;), o(), r()  &#125;  function r() &#123;    for (var e = 0; e &lt; d.length; e++) d[e].alpha &lt;= 0 ? (t.body.removeChild(d[e].el), d.splice(e, 1)) : (d[e].y--, d[e].scale += .004, d[e].alpha -= .013, d[e].el.style.cssText = &quot;left:&quot; + d[e].x + &quot;px;top:&quot; + d[e].y + &quot;px;opacity:&quot; + d[e].alpha + &quot;;transform:scale(&quot; + d[e].scale + &quot;,&quot; + d[e].scale + &quot;) rotate(45deg);background:&quot; + d[e].color + &quot;;z-index:99999&quot;);    requestAnimationFrame(r)  &#125;  function o() &#123;    var t = &quot;function&quot; == typeof e.onclick &amp;&amp; e.onclick;    e.onclick = function (e) &#123;      t &amp;&amp; t(), i(e)    &#125;  &#125;  function i(e) &#123;    var a = t.createElement(&quot;div&quot;);    a.className = &quot;heart&quot;, d.push(&#123;      el: a,      x: e.clientX - 5,      y: e.clientY - 5,      scale: 1,      alpha: 1,      color: s()    &#125;), t.body.appendChild(a)  &#125;  function c(e) &#123;    var a = t.createElement(&quot;style&quot;);    a.type = &quot;text/css&quot;;    try &#123;      a.appendChild(t.createTextNode(e))    &#125; catch (t) &#123;      a.styleSheet.cssText = e    &#125;    t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a)  &#125;  function s() &#123;    return &quot;rgb(&quot; + ~~(255 * Math.random()) + &quot;,&quot; + ~~(255 * Math.random()) + &quot;,&quot; + ~~(255 * Math.random()) + &quot;)&quot;  &#125;  var d = [];  e.requestAnimationFrame = function () &#123;    return e.requestAnimationFrame || e.webkitRequestAnimationFrame || e.mozRequestAnimationFrame || e.oRequestAnimationFrame || e.msRequestAnimationFrame || function (e) &#123;      setTimeout(e, 1e3 / 60)    &#125;  &#125;(), n()&#125;(window, document);\n\n彩色数字可用于将左侧各分类下文章数目变成彩色数字，右侧博客信息变成彩色，标签变成彩色。如果启用 pjax，添加自定义 JavaScript 的同时还要将代码放入 pjax 函数中，否则无效。\nlet tags = document.querySelectorAll(&quot;#tag_cloud-2 a&quot;);let infos = document.querySelectorAll(&quot;.badge&quot;);let colorArr = [&quot;#428BCA&quot;, &quot;#AEDCAE&quot;, &quot;#ECA9A7&quot;, &quot;#DA99FF&quot;, &quot;#FFB380&quot;, &quot;#D9B999&quot;];tags.forEach(tag =&gt; &#123;    tagsColor = colorArr[Math.floor(Math.random() * colorArr.length)];    tag.style.backgroundColor = tagsColor;&#125;);infos.forEach(info =&gt; &#123;    infosColor = colorArr[Math.floor(Math.random() * colorArr.length)];    info.style.backgroundColor = infosColor;&#125;);\n\n网页标签获得&#x2F;失去焦点时更改标题内容//网页标签获得/失去焦点时更改标题内容var OriginTitile = document.title;var titleTime;document.addEventListener(&quot;visibilitychange&quot;,function() &#123;    if (document.hidden) &#123;        OriginTitile = document.title;        document.title = &quot;怎么走了(；д｀)ゞ&quot;;        clearTimeout(titleTime)    &#125; else &#123;        document.title = &quot;回来了ヾ(◍°∇°◍)ﾉﾞ)&quot;;        titleTime = setTimeout(function() &#123;            document.title = OriginTitile        &#125;,        2000)    &#125;&#125;);\n\n多处组合改动复制弹窗提醒第一步：将 layer.js 保存至自己的服务器上。\n第二步：将以下代码添加到后台主题外观设置-开发者设置-自定义输出 head 头部的 HTML 代码，注意修改引用路径。\n&lt;script src=&quot;https://xxxx/layer.js&quot;&gt;&lt;/script&gt;\n第三步：将以下代码添加到后台主题外观设置-开发者设置-自定义 JavaScript\ndocument.body.oncopy = function() &#123;layer.msg(&#x27;复制成功，若要转载请务必保留本文链接！&#x27;);&#125;;\n\n彩色 3D 云标签\n彩色标签以下内容添加到后台主题外观设置-开发者设置-自定义 CSS\n#tag_cloud-2&gt;div&gt;a &#123;    color: #fff;    text-align: center;    text-overflow: ellipsis;    white-space: nowrap;    padding: 3px 5px;    border: 0;    border-radius: 3px;    display: inline-block;    line-height: 18px;&#125;#tag_cloud-2&gt;div&gt;a:hover &#123;    background: #d02f53;&#125;\n以下内容添加到后台主题外观设置-开发者设置-自定义 JavaScript\nfunction colorfultags()&#123;let tags = document.querySelectorAll(&quot;#tag_cloud-2 a&quot;);let colorArr = [&quot;#f60&quot;, &quot;#45B6F7&quot;, &quot;#15a287&quot;, &quot;#5cb85c&quot;, &quot;#d9534f&quot;, &quot;#567e95&quot;, &quot;#00a67c&quot;, &quot;#b37333&quot;];let count = 1;tags.forEach(tag =&gt; &#123;    tagsColor = colorArr[count%8];    tag.style.backgroundColor = tagsColor;    count++;&#125;);&#125;window.onload=colorfultags();\n\n3D 标签以下内容添加到后台主题外观设置-开发者设置-自定义 CSS\n#tag_cloud-2&gt;div &#123;    position: relative;    width: 200px;    height: 240px;    border: 2px black;    margin: 0 0px 0px 0&#125;#tag_cloud-2&gt;div&gt;a &#123;    position: absolute;&#125;#tag_cloud-2&gt;div&gt;a:hover &#123;    display: block&#125;\n以下内容添加到后台主题外观设置-开发者设置-自定义 JavaScript\n//3d标签，和css搭配使用function around3D() &#123;  var oDiv = document.getElementById(&#x27;tag_cloud-2&#x27;).getElementsByTagName(&#x27;div&#x27;)[0];  if (null == oDiv) &#123;    return  &#125; else &#123;    var radius = 80;    var d = 200;    var dtr = Math.PI / 180;    var mcList = [];    var lasta = 1;    var lastb = 1;    var distr = true;    var tspeed = 11;    var size = 200;    var mouseX = 0;    var mouseY = 10;    var howElliptical = 1;    var aA = null;    var i = 0;    var oTag = null;    aA = oDiv.getElementsByTagName(&#x27;a&#x27;);    for (i = 0; i &lt; aA.length; i++) &#123;      oTag = &#123;&#125;;      aA[i].onmouseover = (function(obj) &#123;        return function() &#123;          obj.on = true;          this.style.zIndex = 9999;          this.style.color = &#x27;#fff&#x27;;          this.style.background = &#x27;#0099ff&#x27;;          this.style.padding = &#x27;5px 5px&#x27;;          this.style.filter = &quot;alpha(opacity=100)&quot;;          this.style.opacity = 1;        &#125;      &#125;)(oTag)      aA[i].onmouseout = (function(obj) &#123;        return function() &#123;          obj.on = false;          this.style.zIndex = obj.zIndex;          this.style.color = &#x27;#fff&#x27;;          this.style.background = &#x27;#30899B&#x27;;          this.style.padding = &#x27;5px&#x27;;          this.style.filter = &quot;alpha(opacity=&quot; + 100 * obj.alpha + &quot;)&quot;;          this.style.opacity = obj.alpha;          this.style.zIndex = obj.zIndex;        &#125;      &#125;)(oTag)      oTag.offsetWidth = aA[i].offsetWidth;      oTag.offsetHeight = aA[i].offsetHeight;      mcList.push(oTag);    &#125;    sineCosine(0, 0, 0);    positionAll();    (function() &#123;      update();      setTimeout(arguments.callee, 40);    &#125;)();    function update() &#123;      var a, b, c = 0;      a = (Math.min(Math.max(-mouseY, -size), size) / radius) * tspeed;      b = (-Math.min(Math.max(-mouseX, -size), size) / radius) * tspeed;      lasta = a;      lastb = b;      if (Math.abs(a) &lt;= 0.01 &amp;&amp; Math.abs(b) &lt;= 0.01) &#123;        return;      &#125;      sineCosine(a, b, c);      for (var i = 0; i &lt; mcList.length; i++) &#123;        if (mcList[i].on) &#123;          continue;        &#125;        var rx1 = mcList[i].cx;        var ry1 = mcList[i].cy * ca + mcList[i].cz * (-sa);        var rz1 = mcList[i].cy * sa + mcList[i].cz * ca;        var rx2 = rx1 * cb + rz1 * sb;        var ry2 = ry1;        var rz2 = rx1 * (-sb) + rz1 * cb;        var rx3 = rx2 * cc + ry2 * (-sc);        var ry3 = rx2 * sc + ry2 * cc;        var rz3 = rz2;        mcList[i].cx = rx3;        mcList[i].cy = ry3;        mcList[i].cz = rz3;        per = d / (d + rz3);        mcList[i].x = (howElliptical * rx3 * per) - (howElliptical * 2);        mcList[i].y = ry3 * per;        mcList[i].scale = per;        var alpha = per;        alpha = (alpha - 0.6) * (10 / 6);        mcList[i].alpha = alpha * alpha * alpha - 0.2;        mcList[i].zIndex = Math.ceil(100 - Math.floor(mcList[i].cz));      &#125;      doPosition();    &#125;    function depthSort() &#123;      var i = 0;      var aTmp = [];      for (i = 0; i &lt; aA.length; i++) &#123;        aTmp.push(aA[i]);      &#125;      aTmp.sort(        function(vItem1, vItem2) &#123;          if (vItem1.cz &gt; vItem2.cz) &#123;            return -1;          &#125; else if (vItem1.cz &lt; vItem2.cz) &#123;            return 1;          &#125; else &#123;            return 0;          &#125;        &#125;      );      for (i = 0; i &lt; aTmp.length; i++) &#123;        aTmp[i].style.zIndex = i;      &#125;    &#125;    function positionAll() &#123;      var phi = 0;      var theta = 0;      var max = mcList.length;      for (var i = 0; i &lt; max; i++) &#123;        if (distr) &#123;          phi = Math.acos(-1 + (2 * (i + 1) - 1) / max);          theta = Math.sqrt(max * Math.PI) * phi;        &#125; else &#123;          phi = Math.random() * (Math.PI);          theta = Math.random() * (2* Math.PI);        &#125;        mcList[i].cx = radius * Math.cos(theta) * Math.sin(phi);        mcList[i].cy = radius * Math.sin(theta) * Math.sin(phi);        mcList[i].cz = radius * Math.cos(phi);        aA[i].style.left = mcList[i].cx + oDiv.offsetWidth / 2 - mcList[i].offsetWidth / 2 + &#x27;px&#x27;;        aA[i].style.top = mcList[i].cy + oDiv.offsetHeight / 2 - mcList[i].offsetHeight / 2 + &#x27;px&#x27;;      &#125;    &#125;    function doPosition() &#123;      var l = oDiv.offsetWidth / 2;      var t = oDiv.offsetHeight / 2;      for (var i = 0; i &lt; mcList.length; i++) &#123;        if (mcList[i].on) &#123;          continue;        &#125;        var aAs = aA[i].style;        if (mcList[i].alpha &gt; 0.1) &#123;          if (aAs.display != &#x27;&#x27;)            aAs.display = &#x27;&#x27;;        &#125; else &#123;          if (aAs.display != &#x27;none&#x27;)            aAs.display = &#x27;none&#x27;;          continue;        &#125;        aAs.left = mcList[i].cx + l - mcList[i].offsetWidth / 2 + &#x27;px&#x27;;        aAs.top = mcList[i].cy + t - mcList[i].offsetHeight / 2 + &#x27;px&#x27;;          aAs.filter = &quot;alpha(opacity=&quot; + 100 * mcList[i].alpha + &quot;)&quot;;        aAs.zIndex = mcList[i].zIndex;        aAs.opacity = mcList[i].alpha;      &#125;    &#125;    function sineCosine(a, b, c) &#123;      sa = Math.sin(a * dtr);      ca = Math.cos(a * dtr);      sb = Math.sin(b * dtr);      cb = Math.cos(b * dtr);      sc = Math.sin(c * dtr);      cc = Math.cos(c * dtr);    &#125;  &#125;&#125;window.onload = around3D();\n\n如果启用了 pjax ，要实现 3D 彩色标签，则保持上面两个自定义 CSS 不变，将上面两个自定义 JavaScript 删掉，替换成下面这个自定义 JavaScript，然后后台 pjax 回调函数加上 colorfultags();around3D();\n\nfunction colorfultags()&#123;    let tags = document.querySelectorAll(&quot;#tag_cloud-2 a&quot;);    let colorArr = [&quot;#f60&quot;, &quot;#45B6F7&quot;, &quot;#15a287&quot;, &quot;#5cb85c&quot;, &quot;#d9534f&quot;, &quot;#567e95&quot;, &quot;#00a67c&quot;, &quot;#b37333&quot;];    let count = 1;    tags.forEach(tag =&gt; &#123;        tagsColor = colorArr[count%8];        tag.style.backgroundColor = tagsColor;        count++;    &#125;);&#125;function around3D() &#123;    var oDiv = document.getElementById(&#x27;tag_cloud-2&#x27;).getElementsByTagName(&#x27;div&#x27;)[0];    if (null == oDiv) &#123;        return;    &#125; else &#123;        var radius = 80;        var d = 200;        var dtr = Math.PI / 180;        var mcList = [];        var lasta = 1;        var lastb = 1;        var distr = true;        var tspeed = 11;        var size = 200;        var mouseX = 0;        var mouseY = 10;        var howElliptical = 1;        var aA = null;        var i = 0;        var oTag = null;        aA = oDiv.getElementsByTagName(&#x27;a&#x27;);        for (i = 0; i &lt; aA.length; i++) &#123;            oTag = &#123;&#125;;            aA[i].onmouseover = (function(obj) &#123;                return function() &#123;                    obj.on = true;                    this.style.zIndex = 9999;                    this.style.color = &#x27;#fff&#x27;;                    this.style.background = &#x27;#0099ff&#x27;;                    this.style.padding = &#x27;5px 5px&#x27;;                    this.style.filter = &quot;alpha(opacity=100)&quot;;                    this.style.opacity = 1;                  &#125;              &#125;)(oTag)            aA[i].onmouseout = (function(obj) &#123;                return function() &#123;                    obj.on = false;                    this.style.zIndex = obj.zIndex;                    this.style.color = &#x27;#fff&#x27;;                    this.style.background = &#x27;#30899B&#x27;;                    this.style.padding = &#x27;5px&#x27;;                    this.style.filter = &quot;alpha(opacity=&quot; + 100 * obj.alpha + &quot;)&quot;;                    this.style.opacity = obj.alpha;                    this.style.zIndex = obj.zIndex;                &#125;            &#125;)(oTag)            oTag.offsetWidth = aA[i].offsetWidth;            oTag.offsetHeight = aA[i].offsetHeight;            mcList.push(oTag);        &#125;        sineCosine(0, 0, 0);        positionAll();        (function() &#123;            update();            setTimeout(arguments.callee, 40);        &#125;)();        function update() &#123;            var a, b, c = 0;            a = (Math.min(Math.max(-mouseY, -size), size) / radius) * tspeed;            b = (-Math.min(Math.max(-mouseX, -size), size) / radius) * tspeed;            lasta = a;            lastb = b;            if (Math.abs(a) &lt;= 0.01 &amp;&amp; Math.abs(b) &lt;= 0.01) &#123;                return;            &#125;            sineCosine(a, b, c);            for (var i = 0; i &lt; mcList.length; i++) &#123;                if (mcList[i].on) &#123;                    continue;                &#125;                var rx1 = mcList[i].cx;                var ry1 = mcList[i].cy * ca + mcList[i].cz * (-sa);                var rz1 = mcList[i].cy * sa + mcList[i].cz * ca;                var rx2 = rx1 * cb + rz1 * sb;                var ry2 = ry1;                var rz2 = rx1 * (-sb) + rz1 * cb;                var rx3 = rx2 * cc + ry2 * (-sc);                var ry3 = rx2 * sc + ry2 * cc;                var rz3 = rz2;                mcList[i].cx = rx3;                mcList[i].cy = ry3;                mcList[i].cz = rz3;                per = d / (d + rz3);                mcList[i].x = (howElliptical * rx3 * per) - (howElliptical * 2);                mcList[i].y = ry3 * per;                mcList[i].scale = per;                var alpha = per;                alpha = (alpha - 0.6) * (10 / 6);                mcList[i].alpha = alpha * alpha * alpha - 0.2;                mcList[i].zIndex = Math.ceil(100 - Math.floor(mcList[i].cz));            &#125;            doPosition();        &#125;        function depthSort() &#123;            var i = 0;            var aTmp = [];            for (i = 0; i &lt; aA.length; i++) &#123;                aTmp.push(aA[i]);            &#125;            aTmp.sort(                function(vItem1, vItem2) &#123;                    if (vItem1.cz &gt; vItem2.cz) &#123;                        return -1;                    &#125; else if (vItem1.cz &lt; vItem2.cz) &#123;                        return 1;                    &#125; else &#123;                        return 0;                    &#125;                &#125;            );            for (i = 0; i &lt; aTmp.length; i++) &#123;                aTmp[i].style.zIndex = i;            &#125;        &#125;        function positionAll() &#123;            var phi = 0;            var theta = 0;            var max = mcList.length;            for (var i = 0; i &lt; max; i++) &#123;                if (distr) &#123;                    phi = Math.acos(-1 + (2 * (i + 1) - 1) / max);                    theta = Math.sqrt(max * Math.PI) * phi;                &#125; else &#123;                    phi = Math.random() * (Math.PI);                    theta = Math.random() * (2 * Math.PI);                &#125;                mcList[i].cx = radius * Math.cos(theta) * Math.sin(phi);                mcList[i].cy = radius * Math.sin(theta) * Math.sin(phi);                mcList[i].cz = radius * Math.cos(phi);                aA[i].style.left = mcList[i].cx + oDiv.offsetWidth / 2 - mcList[i].offsetWidth / 2 + &#x27;px&#x27;;                aA[i].style.top = mcList[i].cy + oDiv.offsetHeight / 2 - mcList[i].offsetHeight / 2 + &#x27;px&#x27;;            &#125;        &#125;        function doPosition() &#123;            var l = oDiv.offsetWidth / 2;            var t = oDiv.offsetHeight / 2;            for (var i = 0; i &lt; mcList.length; i++) &#123;                if (mcList[i].on) &#123;                    continue;                &#125;                var aAs = aA[i].style;                if (mcList[i].alpha &gt; 0.1) &#123;                    if (aAs.display != &#x27;&#x27;)                        aAs.display = &#x27;&#x27;;                &#125; else &#123;                    if (aAs.display != &#x27;none&#x27;)                        aAs.display = &#x27;none&#x27;;                    continue;                &#125;                aAs.left = mcList[i].cx + l - mcList[i].offsetWidth / 2 + &#x27;px&#x27;;                aAs.top = mcList[i].cy + t - mcList[i].offsetHeight / 2 + &#x27;px&#x27;;                aAs.filter = &quot;alpha(opacity=&quot; + 100 * mcList[i].alpha + &quot;)&quot;;                aAs.zIndex = mcList[i].zIndex;                aAs.opacity = mcList[i].alpha;            &#125;        &#125;        function sineCosine(a, b, c) &#123;            sa = Math.sin(a * dtr);            ca = Math.cos(a * dtr);            sb = Math.sin(b * dtr);            cb = Math.cos(b * dtr);            sc = Math.sin(c * dtr);            cc = Math.cos(c * dtr);        &#125;    &#125;&#125;\n\n文件改动左侧导航全站友链显示头像在 aside.php 文件中大约 213 行左右 “使用links插件，输出全站友链” 位置下方修改代码，在 php 代码中的 a 标签内加上：\n&lt;img style=\\&quot;width:18px;height:18px;border-radius:50%;margin-right:3px;\\&quot; src=\\&quot;&#123;image&#125;\\&quot; /&gt;\n\n左、右下角彩色版权声明找到主题文件夹下 handsomecomponentfooter.php 文件，找到下方这段代码（在文件中可按 Ctrl+F 进行查找）：\nPowered by &lt;a target=&quot;_blank&quot; href=&quot;http://www.typecho.org&quot;&gt;Typecho&lt;/a&gt; | Theme by &lt;a target=&quot;_blank&quot;href=&quot;https://www.ihewro.com/archives/489/&quot;&gt;handsome&lt;/a&gt;\n修改为:\n&lt;div class=&quot;wrapper bg-light&quot;&gt;      &lt;!--右下角--&gt;    &lt;span class=&quot;pull-right hidden-xs text-ellipsis&quot;&gt;        &lt;?php $this-&gt;options-&gt;BottomInfo(); ?&gt;        &lt;div class=&quot;github-badge&quot;&gt;            &lt;a href=&quot;http://www.typecho.org&quot; title=&quot;Typecho&quot; target=&quot;_blank&quot;&gt;                &lt;span class=&quot;badge-subject&quot;&gt;Powered by&lt;/span&gt;&lt;span class=&quot;badge-value bg-blue&quot;&gt;Typecho&lt;/span&gt;            &lt;/a&gt;        &lt;/div&gt;        &lt;span&gt; | &lt;/span&gt;        &lt;div class=&quot;github-badge&quot;&gt;            &lt;a href=&quot;https://www.ihewro.com/archives/489/&quot; title=&quot;Handsome&quot; target=&quot;_blank&quot;&gt;                &lt;span class=&quot;badge-subject&quot;&gt;Theme by&lt;/span&gt;&lt;span class=&quot;badge-value bg-green&quot;&gt;Handsome&lt;/span&gt;            &lt;/a&gt;        &lt;/div&gt;    &lt;/span&gt;      &lt;!--左下角--&gt;    &lt;span class=&quot;text-ellipsis&quot;&gt;        &lt;?php $this-&gt;options-&gt;BottomleftInfo(); ?&gt;        &lt;div class=&quot;github-badge&quot;&gt;            &lt;a href=&quot;https://blog.kecho.top&quot; title=&quot;©2022 Kecho&quot; target=&quot;_blank&quot;&gt;                &lt;span class=&quot;badge-subject&quot;&gt;Copyright&lt;/span&gt;&lt;span class=&quot;badge-value bg-blue&quot;&gt;©2022 Kecho&lt;/span&gt;            &lt;/a&gt;        &lt;/div&gt;        &lt;span&gt; | &lt;/span&gt;        &lt;div class=&quot;github-badge&quot;&gt;            &lt;a href=&quot;http://www.beian.miit.gov.cn&quot; title=&quot;赣ICP备 20004569号-1&quot; target=&quot;_blank&quot;&gt;                &lt;span class=&quot;badge-subject&quot;&gt;备案号&lt;/span&gt;&lt;span class=&quot;badge-value bg-green&quot;&gt;赣ICP备 20004569号-1&lt;/span&gt;            &lt;/a&gt;        &lt;/div&gt;    &lt;/span&gt;&lt;/div&gt;\n然后在后台主题外观设置-开发者设置-自定义 CSS中添加：\n/*最底部版权声明样式*/.github-badge &#123;    display: inline-block;    border-radius: 4px;    text-shadow: none;    font-size: 12px;    color: #fff;    line-height: 14px;    background-color: #abbac3;&#125;.github-badge .badge-subject &#123;    display: inline-block;    background-color: #4d4d4d;    padding: 4px 4px 4px 6px;    border-top-left-radius: 4px;    border-bottom-left-radius: 4px&#125;.github-badge .badge-value &#123;    display: inline-block;    padding: 4px 6px 4px 4px;    border-top-right-radius: 4px;    border-bottom-right-radius: 4px&#125;.github-badge .bg-blue &#123;    background-color: #007ec6&#125;.github-badge .bg-orange &#123;    background-color: #ffa500&#125;.github-badge .bg-red &#123;    background-color: #f00&#125;.github-badge .bg-green &#123;    background-color: #3bca6e&#125;.github-badge .bg-purple &#123;    background-color: #ab34e9&#125;\n\n网站顶部彩虹条第一步：将以下代码添加到后台主题外观设置-开发者设置-自定义 CSS\n.gundongtiao&#123;    animation: gundongtiao 1s infinite linear;    height:2px;    top:0;    left:0;    position: fixed;    width:100%;    z-index:9999;&#125;@keyframes gundongtiao&#123;    0%&#123;        background: #000 linear-gradient(to left, #4cd964, #5ac8fa, #007aff, #34aadc, #5856d6, #ff2d55);    &#125;    20%&#123;        background: #000 linear-gradient(to left, #ff2d55,#4cd964, #5ac8fa, #007aff, #34aadc,#5856d6);    &#125;    40%&#123;        background: #000 linear-gradient(to left, #5856d6,#ff2d55,#4cd964, #5ac8fa, #007aff, #34aadc);    &#125;    60%&#123;        background: #000 linear-gradient(to left, #34aadc,#5856d6,#ff2d55,#4cd964, #5ac8fa, #007aff);    &#125;    80%&#123;        background: #000 linear-gradient(to left, #007aff,#34aadc,#5856d6,#ff2d55,#4cd964, #5ac8fa);    &#125;    100%&#123;        background: #000 linear-gradient(to left, #5ac8fa,#007aff,#34aadc,#5856d6,#ff2d55,#4cd964);    &#125;&#125;\n第二步：在网站文件 footer.php (文件路径为 handsome/component/footer.php )末尾添加：\n&lt;div class=&quot;gundongtiao&quot;&gt;&lt;/div&gt;\n\n添加访客 3D 地球找到 handsome/component/sidebar.php 下方代码位置：\n&lt;li class=&quot;list-group-item text-second&quot;&gt;&lt;span class=&quot;blog-info-icons&quot;&gt; &lt;i data-feather=&quot;activity&quot;&gt;&lt;/i&gt;&lt;/span&gt;     &lt;span class=&quot;badge         pull-right&quot;&gt;&lt;?php echo Utils::getLatestTime($this); ?&gt;&lt;/span&gt;&lt;?php _me(&quot;最后活动&quot;) ?&gt;&lt;/li&gt;    &lt;/ul&gt; &lt;/section&gt; &lt;!--插入位置--&gt; &lt;?php endif; ?&gt; &lt;?php if ($this-&gt;options-&gt;adContentSidebar != &quot;&quot;): ?&gt; &lt;!--广告位置--&gt;     &lt;section id=&quot;a_d_sidebar&quot; class=&quot;widget widget_categories wrapper-md clear&quot;&gt;         &lt;h5 class=&quot;widget-title m-t-none text-md&quot;&gt;&lt;?php _me(&quot;广告&quot;) ?&gt;&lt;/h5&gt;         &lt;?php $this-&gt;options-&gt;adContentSidebar(); ?&gt;    &lt;/section&gt; &lt;?php endif; ?&gt;\n插入以下代码：（可以修改其中的 height 来调整大小）\n&lt;!--自定义访客地球--&gt;&lt;section id=&quot;tag_cloud-2&quot; class=&quot;widget widget_tag_cloud wrapper-md clear&quot;&gt;    &lt;h3 class=&quot;widget-title m-t-none text-md&quot;&gt;访客统计&lt;/h3&gt;    &lt;div id=&quot;visitors&quot; class=&quot;tags l-h-2x&quot; style=&quot;width:auto;height:185px;&quot;&gt;&lt;/div&gt;&lt;/section&gt;\n然后去 RevolverMaps 找自己喜欢的地球样式，并且把它给的 JavaScript 代码复制下来，然后将复制的代码进行转义，即将 / 改为 \\/ ，将 &quot; 改为 \\&quot;，将转义后的代码和下方代码合并在一起，放到后台主题外观设置-开发者设置-自定义 JavaScript。\n$(document).ready(function()&#123;$(&quot;#visitors&quot;).append(&quot;这里是您在 RevolverMaps 地球网站上复制的转义后的代码&quot;);&#125;);$(document).on(&#x27;pjax:complete&#x27;, function() &#123;$(&#x27;#morphing&#x27;).tooltip(&#x27;show&#x27;); $(&quot;#visitors&quot;).append(&quot;这里是您在 RevolverMaps 地球网站上复制的转义后的代码&quot;);&#125;);\n如果你不会转义，也可以直接使用我转义好的：\n&lt;script type=\\&quot;text/javascript\\&quot; src=\\&quot;//rf.revolvermaps.com/0/0/8.js?i=51frwlq4tnv&amp;m=0&amp;c=ff0000&amp;cr1=ffffff&amp;f=arial&amp;l=33&amp;bv=65\\&quot; async=\\&quot;async\\&quot;&gt;&lt;\\/script&gt;\n\n评论框打字特效详见 网页输入框打字特效\n左侧导航栏输出优化详见 Handsome 魔改教程：左侧边栏输出优化\n","categories":["折腾记录"],"tags":["Handsome","Typecho"]},{"title":"Windows 注册表备忘","url":"/posts/e36ef7eb.html","content":"记录 Windows 系统常用注册表。\n\n系统代理记录清除删除 HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings 中 ProxyServer 和 ProxyOverride 的值\n共享网络默认网关修改修改 HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\SharedAccess\\Parameters 中 ScopeAddress 和 ScopeAddressBackup 的值\nRDP 默认端口修改修改 HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp 中 PortNumber 的值\nWebdav 挂载支持 http修改 HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\WebClient\\Parameters 中 BasicAuthLevel 的值为 2，然后重新启动计算机\n开机自启项可使用 autoruns 管理开机自启项。\nHKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\RunHKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnceHKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunHKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnceHKEY_LOCAL_MACHINE\\SOFTWARE\\WOW6432Node\\Microsoft\\Windows\\CurrentVersion\\Run\n","categories":["折腾记录"],"tags":["Windows","注册表"]},{"title":"Debian 服务器配置备忘","url":"/posts/f7465fc9.html","content":"记录个人 Debian 服务器的配置过程。\n\n软件安装aptdebian | 镜像站使用帮助 | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror\n编辑配置文件：\nsudo - rootvi /etc/apt/sources.list\n\n替换为：\ndeb https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm main contrib non-free non-free-firmware# deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm main contrib non-free non-free-firmwaredeb https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-updates main contrib non-free non-free-firmware# deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-updates main contrib non-free non-free-firmwaredeb https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-backports main contrib non-free non-free-firmware# deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-backports main contrib non-free non-free-firmwaredeb https://mirrors.tuna.tsinghua.edu.cn/debian-security bookworm-security main contrib non-free non-free-firmware# deb-src https://mirrors.tuna.tsinghua.edu.cn/debian-security bookworm-security main contrib non-free non-free-firmware\n\n其中 main contrib non-free non-free-firmware 表示不同类型的软件包。\n\nmain 表示符合 Debian Free Software Guidelines 的包；\ncontrib 是依赖一些非自由软件就才能正常运作的开源软件；\nnon-free 和 non-free-firmware 表示非自由软件。\n\n\n上述这种格式称为传统格式（又称 One-Line-Style 格式）。\n新的 DEB822 格式自 APT 1.1（2015 年发布）起支持，文件后缀为 .sources，存储在 /etc/apt/sources.list.d/ 目录下，格式类似如下：\nTypes: deb deb-srcURIs: https://mirrors.tuna.tsinghua.edu.cn/debianSuites: bookworm bookworm-updates bookworm-backportsComponents: main contrib non-free non-free-firmwareSigned-By: /usr/share/keyrings/debian-archive-keyring.gpgTypes: deb deb-srcURIs: http://security.debian.org/debian-securitySuites: bookworm-securityComponents: mainSigned-By: /usr/share/keyrings/debian-archive-keyring.gpg\n\n安装常用工具：\napt updateapt install vim git wget curl\n\n常用命令：\napt update    # 更新软件索引apt upgrade  # 更新系统中的所有软件包，但不安装额外的软件包或卸载软件包apt full-upgrade # 更新系统中的所有软件包，并且在必要的时候安装额外的软件包或卸载软件包apt install foo   # 安装软件包 foo 和它的全部依赖apt remove foo  # 卸载软件包 fooapt purge foo    # 卸载软件包 foo 和它的配置文件apt list --upgradable  # 列出所有可以更新到新版本的软件包apt search foo  # 找出描述中包含 foo 的软件包apt show foo    # 打印软件包的详细信息apt-cache depends foo    # 打印软件包的依赖apt-cache showpkg foo   # 打印软件包各可用版本的详细信息，以及反向依赖它的软件包\n\ndpkg除了使用 apt 软件管理工具安装软件外，还可以直接使用 dpkg 命令本地安装 deb 软件包\ndeb 包安装与卸载：\ndpkg -i hello.deb       # 安装dpkg -r hello.deb       # 保留配置文件卸载dpkg -P hello.deb       # 清除配置文件卸载dpkg -l                 # 显示已安装程序列表dpkg -l | grep &quot;hello&quot;  # 查询已安装包dpkg -l | grep ^rc      # 查看处于 rc 状态的软件包\ndpkg -l 显示已安装程序列表，其中每行输出的第一列 ii 表示软件包的安装和配置状态，其格式如下：期望状态|当前状态|错误 。\n期望状态有以下几种：\n\nu：即 unknown，软件包未安装且用户未请求安装\ni：即 install，用户请求安装该软件包\nr：即 remove，用户请求卸载该软件包\np：即 purge，用户请求卸载该软件包并清理配置文件\nh：即 hold，用户请求保持续当前软件包版本\n\n当前状态有以下几种：\n\nn：即 not-installed，软件包未安装\ni：即 installed，软件包已安装并完成配置\nc：即 config-files，软件包已经被卸载，但是其配置文件未清理\nu：即 unpacked，软件包已经被解压缩，但还未配置\nf：即 half-configured，配置软件包时出现错误\nw：即 triggers-awaited，触发器等待\nt：即 triggers-pending，触发器未决\n\n错误状态有以下几种：\n\nh：软件包被强制保持\nr：即 reinstall-required，需要卸载并重新安装\nx：软件包被破坏\n\n因此 ii 表示该软件需要安装且已经安装，没有出现错误；iu 表示已经安装该软件，但未正确配置；rc 表示该软件已经被删除，但配置文件未清理。\n一个 deb 包的目录结构如下：\n\nmy.deb\nDEBIAN\ncontrol （存放软件包的作者、版本、描述等信息）\npreinst （安装前执行的脚本）\npostinst （安装后执行的脚本）\nprerm （卸载前执行的脚本）\npostrm （卸载后执行的脚本）\n\n\nusr （存放源码）\nxxxxxx\n\n\n\n\n\n可以使用以下命令对 deb 包进行解压和打包：\ndpkg -x my.deb build  # 解压源码dpkg -e my.deb build  # 解压其中的 DEBIAN 内容dpkg -b build my.deb  # 重新打包为 deb\n\n\nsudo安装：\nsu - rootapt install sudo\n\n配置：\nusermod -aG sudo username #将用户 username 添加到 sudo 组中\n\n或者使用 visudo 命令或者编辑 /etc/sudoers 文件，文中添加 username ALL=(ALL) ALL ，保存文件后注销重新登录。\ndockerdocker-ce | 镜像站使用帮助 | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror\n卸载：\nfor pkg in docker.io docker-doc docker-compose podman-docker containerd runc; do apt-get remove $pkg; done\n\n信任公钥并添加仓库：\ninstall -m 0755 -d /etc/apt/keyringscurl -fsSL https://download.docker.com/linux/debian/gpg | gpg --dearmor -o /etc/apt/keyrings/docker.gpgsudo chmod a+r /etc/apt/keyrings/docker.gpgecho \\  &quot;deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/debian \\  &quot;$(. /etc/os-release &amp;&amp; echo &quot;$VERSION_CODENAME&quot;)&quot; stable&quot; | \\  tee /etc/apt/sources.list.d/docker.list &gt; /dev/null\n\n安装：\nsudo apt updatesudo apt install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin\n\n编辑配置文件：\nsudo vim /etc/docker/daemon.json\n\n增加代理加速地址：\n&#123;  &quot;registry-mirrors&quot;: [    &quot;https://docker.1panel.live&quot;,    &quot;https://docker.ketches.cn&quot;,    &quot;https://hub.iyuu.cn&quot;  ]&#125;\n\n服务启动：\nsudo systemctl restart docker\n\n\n\n常用命令：\nsudo vim docker-compose.yml # 编辑容器配置文件sudo docker compose up -dsudo docker compose downsudo docker exec -it [contianer_name] /bin/bashsudo docker images # 列出所有镜像sudo docker image remove xxx:xxx # 删除指定镜像sudo docker container ps # 列出在运行容器\n\n\n\nip 固定编辑配置文件：\nsudo vim /etc/network/interfaces\n\n增加内容：\nauto enp0s3iface enp0s3 inet staticaddress 192.168.1.240/24network 192.168.1.0broadcast 192.168.1.255gateway 192.168.1.1dns-nameservers 223.5.5.5\n\n服务启动：\nsudo systemctl restart networking.service\n\n常用命令：\nip address # 查看网络接口ip route # 查看路由\n\n\nsmb安装：\nsudo apt updatesudo apt install samba\n\n配置：\nmkdir share # 创建共享文件夹sudo vim /etc/samba/smb.conf # 编辑配置文件\n\n末尾增加：\n[SHARE]comment = My Share Folderpath = /home/username/sharewritable = yesbrowseable = noguest ok = no\n\n服务启动：\nsudo systemctl restart smbd.service\n\n\n\ncrontabDebian 12 已经默认安装了 cron\n安装：\nsudo apt updatesudo apt install cron\n\n常用命令：\ncrontab –e     //修改 crontab 文件，如果文件不存在会自动创建crontab –l      //显示 crontab 文件crontab -r      //删除 crontab 文件crontab -ir     //删除 crontab 文件前提醒用户# 默认使用当前用户，可以使用 -u 指定用户crontab [-u username] -e\n\n\n\n编写服务创建配置文件：\nsudo vim /etc/systemd/system/frpc.service\n\n添加内容：\n[Unit]Description=Frpc ServiceAfter=network.target[Service]ExecStart=/home/username/frpc -c ./frpc.tomlRestart=on-failure[Install]WantedBy=default.target\n\n服务启动：\nsudo systemctl daemon-reloadsudo systemctl enable frpc.service\n\n","categories":["折腾记录"],"tags":["Linux","Debian"]},{"title":"Windows 本地部署 DeepSeek 大模型","url":"/posts/8bd9618c.html","content":"本文介绍如何通过 Ollama 部署 DeepSeek-R1 蒸馏版。\n\n\n\n安装 DeepSeek去官网下载 Ollama 安装程序，使用 OllamaSetup.exe /DIR=D:\\Software\\Ollama 可指定安装路径。\nOllama 安装后执行 ollama run deepseek-r1:14b 即可运行 DeepSeek-R1-Distill-Qwen-14B，可以替换数字以安装不同数据集大小的模型，更多信息见 Ollama DeepSeek-R1。\n安装 open-webui运行成功后默认是通过命令行进行交互，可以利用安装 open-webui 提供网页交互入口，此处使用 pip 安装（依赖 python 3.11 ）：\n# 需已安装 python 3.11pip install open-webuiopen-webui serve\n\n你也可以使用 docker 安装，更多信息详见 Open WebUI 文档。\n参考文章\nOllama Deepseek-R1\nOpen WebUI 文档\n\n","categories":["折腾记录"],"tags":["Windows","DeepSeek","大模型","AI"]},{"title":"KeepassDx 的魔法键盘适配小米手机键盘全面屏优化","url":"/posts/ca3e9532.html","content":"本文将通过修改包名的方式使 KeepassDx 的魔法键盘适配小米手机键盘全面屏优化\n\n\n\n前情提要密码管理工具 KeepassDX 填充密码时可以使用魔法键盘填充，防止密码被第三方输入法读取，但是切换输入法需要去设置应用手动切换，十分麻烦。\n小米手机在 “设置 -&gt; 更多设置 -&gt; 语言与输入法” 中打开 “全面屏键盘优化” 能够实现快捷切换输入法，但是目前只支持三个小米版输入法，分别是百度输入法小米版、搜狗输入法小米版、讯飞输入法小米版。\n有人对其实现的原理进行了分析，发现是系统是根据包名来判断的，那我们可以把包名修改成其中之一，也就能够实现快捷切换了。\n操作步骤1.电脑新建文件夹 demo，下载 反编译工具 apktool 到其中并重命名为 apktool.apk，下载 KeePassDX 安装包 到其中并重命名为 KeePassDX.apk，下载 脚本文件 到其中并重命名为 apktool.bat，然后双击脚本文件。\n2.进入 demo 目录下执行命令：apktool d KeePassDX.apk 进行解包。\n3.打开 KeePassDX 目录中的 AndroidManifest.xml 文件，将第一行中 package=&quot;com.kunzisoft.keepass.libre&quot; 改为 package=&quot;com.iflytek.inputmethod.miui&quot;。\n\n包名在 com.iflytek.inputmethod.miui，com.sohu.inputmethod.sogou.xiaomi，com.baidu.input_mi 三个中选一个，不要和正常在用的键盘包名重复\n\n4.执行命令：apktool b &quot;KeePassDX&quot; -o KeePassDX-new.apk 将文件重新打包。\n5.手机下载并安装 MT 管理器\n6.将 KeePassDX-new.apk 发送到手机，打开 MT 管理器，长按文件选择 “签名”。\n7.安装签名后的文件。\n安装完成后，去系统设置里面启用魔法键盘，之后就能快速切换键盘实现填充密码了。\n参考文章KeepassDx的魔法键盘适配小米全面屏优化 - 三点一圆 - 博客园\n","categories":["折腾记录"],"tags":["Keepass","Android"]}]