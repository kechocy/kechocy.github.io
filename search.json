[{"title":"Debian 服务器配置备忘","url":"/posts/f7465fc9.html","content":"记录个人 Debian 服务器的配置过程。\n\naptdebian | 镜像站使用帮助 | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror\n编辑配置文件：\nsudo - rootvi /etc/apt/sources.list\n\n替换为：\ndeb https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm main contrib non-free non-free-firmware# deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm main contrib non-free non-free-firmwaredeb https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-updates main contrib non-free non-free-firmware# deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-updates main contrib non-free non-free-firmwaredeb https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-backports main contrib non-free non-free-firmware# deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-backports main contrib non-free non-free-firmwaredeb https://mirrors.tuna.tsinghua.edu.cn/debian-security bookworm-security main contrib non-free non-free-firmware# deb-src https://mirrors.tuna.tsinghua.edu.cn/debian-security bookworm-security main contrib non-free non-free-firmware\n\n安装常用工具：\napt updateapt install vim git wget curl\n\n\n\ndeb 包安装与卸载：\nsudo dpkg -i hello.deb       # 安装sudo dpkg -l | grep &quot;hello&quot;  # 查询已安装包sudo dpkg -r hello           # 卸载\n\n\n\nsudo安装：\nsu - rootapt install sudo\n\n配置：\nusermod -aG sudo username #将用户 username 添加到 sudo 组中\n\n或者使用 visudo 命令或者编辑 /etc/sudoers 文件，文中添加 username ALL=(ALL) ALL ，保存文件后注销重新登录。\ndockerdocker-ce | 镜像站使用帮助 | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror\n卸载：\nfor pkg in docker.io docker-doc docker-compose podman-docker containerd runc; do apt-get remove $pkg; done\n\n信任公钥并添加仓库：\ninstall -m 0755 -d /etc/apt/keyringscurl -fsSL https://download.docker.com/linux/debian/gpg | gpg --dearmor -o /etc/apt/keyrings/docker.gpgsudo chmod a+r /etc/apt/keyrings/docker.gpgecho \\  &quot;deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/debian \\  &quot;$(. /etc/os-release &amp;&amp; echo &quot;$VERSION_CODENAME&quot;)&quot; stable&quot; | \\  tee /etc/apt/sources.list.d/docker.list &gt; /dev/null\n\n安装：\nsudo apt updatesudo apt install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin\n\n编辑配置文件：\nsudo vim /etc/docker/daemon.json\n\n增加代理加速地址：\n&#123;  &quot;registry-mirrors&quot;: [    &quot;https://docker.1panel.live&quot;,    &quot;https://docker.ketches.cn&quot;,    &quot;https://hub.iyuu.cn&quot;  ]&#125;\n\n服务启动：\nsudo systemctl restart docker\n\n\n\n常用命令：\nsudo vim docker-compose.yml # 编辑容器配置文件sudo docker compose up -dsudo docker compose downsudo docker exec -it [contianer_name] /bin/bashsudo docker images # 列出所有镜像sudo docker image remove xxx:xxx # 删除指定镜像sudo docker container ps # 列出在运行容器\n\n\n\nip 固定编辑配置文件：\nsudo vim /etc/network/interfaces\n\n增加内容：\nauto enp0s3iface enp0s3 inet staticaddress 192.168.1.240/24network 192.168.1.0broadcast 192.168.1.255gateway 192.168.1.1dns-nameservers 223.5.5.5\n\n服务启动：\nsudo systemctl restart networking.service\n\n常用命令：\nip address # 查看网络接口ip route # 查看路由\n\n\nsmb安装：\nsudo apt updatesudo apt install samba\n\n配置：\nmkdir share # 创建共享文件夹sudo vim /etc/samba/smb.conf # 编辑配置文件\n\n末尾增加：\n[SHARE]comment = My Share Folderpath = /home/username/sharewritable = yesbrowseable = noguest ok = no\n\n服务启动：\nsudo systemctl restart smbd.service\n\n\n\ncrontabDebian 12 已经默认安装了 cron\n安装：\nsudo apt updatesudo apt install cron\n\n常用命令：\ncrontab –e     //修改 crontab 文件，如果文件不存在会自动创建crontab –l      //显示 crontab 文件crontab -r      //删除 crontab 文件crontab -ir     //删除 crontab 文件前提醒用户# 默认使用当前用户，可以使用 -u 指定用户crontab [-u username] -e\n\n\n\n编写服务创建配置文件：\nsudo vim /etc/systemd/system/frpc.service\n\n添加内容：\n[Unit]Description=Frpc ServiceAfter=network.target[Service]ExecStart=/home/username/frpc -c ./frpc.tomlRestart=on-failure[Install]WantedBy=default.target\n\n服务启动：\nsudo systemctl daemon-reloadsudo systemctl enable frpc.service\n\n","categories":["学习笔记","运维技巧","折腾记录"],"tags":["Linux"]},{"title":"Spring Boot 整合 Swagger 实现接口文档","url":"/posts/448c169.html","content":"本文介绍 OpenApi、Swagger、SpringFox 和 SpringDoc 之间的区别，以及 SpringBoot 如何整合并使用 Swagger 实现接口文档。\n\n名词解释\nOpenApi 是什么？\n\n解答： OpenApi 是一个用于描述、定义和共享 RESTful API 文档的规范。最新规范是 OpenAPI 3.0。\n\nSwagger 是什么？\n\n解答： Swagger 是一个用于设计和测试 RESTful API 的工具，是无关语言的。它提供了 API 描述、请求和响应示例、API 测试和文档生成等丰富的功能。最新版本是 Swagger 3，支持 OpenAPI 3.0 规范。\n\nSpringFox 是什么？\n\n解答： SpringFox 是 Spring 社区维护的一个项目（非官方），帮助使用者将 Swagger 2 集成到 Spring 中。\n地址：https://github.com/springfox/springfox\n\nSpringDoc 是什么？\n\n解答： SpringDoc 也是 Spring 社区维护的一个项目（非官方），帮助使用者将 Swagger 3 集成到 Spring 中。SpringDoc 支持 Swagger 页面、Oauth2 登录，相较于 SpringFox 而言，它的支撑时间更长，无疑是更好的选择。\n地址：https://springdoc.org/\n\n它们之间的关系\n\n解答： OpenAPI 定义了一种标准的格式来表示 API 文档，而 Swagger 是一个实现 OpenAPI 规范的工具，而 SpringFox 和 SpringDoc 都是将 Swagger 继承到 Spring 框架中方便使用。\n开始如何将 Swagger 集成到 SpringBoot 中？\n环境\nJDK 17\nSpringBoot 3\n\n在 SpringBoot 3 之前用的都是 SpringFox 来集成 Swagger 管理我们的 API 接口文档，但是 SpringFox 已经停止更新了，本次我们使用的是 SpringBoot 3 、JDK 17 的环境，推荐使用 SpringDoc 来整合 Swagger。\n添加依赖&lt;dependency&gt;    &lt;groupId&gt;org.springdoc&lt;/groupId&gt;    &lt;artifactId&gt;springdoc-openapi-starter-webmvc-ui&lt;/artifactId&gt;    &lt;version&gt;2.8.8&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springdoc&lt;/groupId&gt;    &lt;artifactId&gt;springdoc-openapi-starter-webmvc-api&lt;/artifactId&gt;    &lt;version&gt;2.8.8&lt;/version&gt;&lt;/dependency&gt;\n\n\n编写 Controller 类@RestControllerpublic class HelloController &#123;     @RequestMapping(&quot;/hello&quot;)    public String hello()&#123;        return &quot;hello&quot;;    &#125;&#125;\n\n访问接口页面浏览器直接输入：http://localhost:8080/swagger-ui/index.html 回车即可看到下面界面：\n\n配置在 application.yml 中可以自定义 api-docs 和 swagger-ui 的访问路径，扫描的指定包等等。\nspringdoc:  api-docs:    path: /v3/api-docs    enabled: false # 关闭接口文档，可针对 application-dev.yml / application-test 进行不同配置  swagger-ui:    path: /swagger-ui.html  packages-to-scan: com.example.swaggerdemo.common.controller # 只显示 common 包下的接口\n\n可以通过配置类来自定义 swagger-ui 页面信息：\n@OpenAPIDefinition(        // 不同环境的服务器地址        servers = &#123;                @Server(description = &quot;开发环境服务器&quot;, url = &quot;http://localhost:8080&quot;),                @Server(description = &quot;测试环境服务器&quot;, url = &quot;https://test.xiezhr.com&quot;)        &#125;,        // 配置外部文档地址        externalDocs = @ExternalDocumentation(                description = &quot;项目编译部署说明&quot;,                url = &quot;http://localhost:8080/deplay/readme.md&quot;        )) @Configurationpublic class SpringDocConfig &#123;     @Bean    public OpenAPI openAPI() &#123;        return new OpenAPI()                // 配置接口文档基本信息                .info(this.getApiInfo())                ;    &#125;     private Info getApiInfo() &#123;        return new Info()                 // 配置文档标题                .title(&quot;SpringBoot3集成Swagger3&quot;)                // 配置文档描述                .description(&quot;SpringBoot3集成Swagger3示例文档&quot;)                // 配置作者信息                .contact(new Contact().name(&quot;程序员小凡&quot;).url(&quot;https://www.xiezhrspace.cn&quot;).email(&quot;1666397814@163.com&quot;))                // 配置License许可证信息                .license(new License().name(&quot;Apache 2.0&quot;).url(&quot;https://www.xiezhrspace.cn&quot;))                //                .summary(&quot;SpringBoot3集成Swagger3示例文档aaa&quot;)                .termsOfService(&quot;https://www.xiezhrspace.cn&quot;)                 // 配置版本号                .version(&quot;2.0&quot;);    &#125;    // 对接口进行分组    @Bean(&quot;commonGroupApi&quot;)    public GroupedOpenApi webGroupApi() &#123;        return GroupedOpenApi.builder().group(&quot;common通用模块组&quot;)            .pathsToMatch(&quot;/common/**&quot;)            .build();    &#125;     @Bean(&quot;adminGroupApi&quot;)    public GroupedOpenApi adminGroupApi() &#123;        return GroupedOpenApi.builder().group(&quot;admin模块组&quot;)            .pathsToMatch(&quot;/admin/**&quot;)            .build();    &#125;&#125;\n\n\n\n注解使用Controller 类① @Tag 注解，用于类上。\n\nname: 名称\ndescription: 接口描述信息\n\n② @Operation 注解，用在方法上。\n\nsummary：方法概要，方法的一个简单介绍，建议 120 个字符内\ndescription：方法描述，一般是很长的内容\nhidden：是否隐藏\n\n③@Parameter 注解，用在方法参数上。\n\nname：指定的参数名\nin：参数位置，可选 query、header、path 或 cookie，默认为空，表示忽略\ndescription：参数描述\nrequired：是否必填，默认为 false\n\n④ @ApiResponse 注解，用于说明一个响应信息，用在 @ApiResponses 中。\n\nresponseCode：HTTP 响应码\ndescription：描述\n\n@RestController@RequestMapping(&quot;/common&quot;)@Tag(name = &quot;公共接口&quot;, description = &quot;公共接口&quot;)public class CommonController &#123;     @Autowired    private IUserService userService;    @GetMapping(&quot;/hello&quot;)   @Operation(summary = &quot;hello接口&quot;, description = &quot;hello接口描述&quot;, hidden = true)    public String hello()&#123;        return &quot;hello&quot;;    &#125;     @GetMapping(&quot;/hi&quot;)    @Operation(summary = &quot;hi接口&quot;, description = &quot;hi接口描述&quot;)    public String Hi()&#123;        return &quot;Hi 程序员小凡&quot;;    &#125;     @GetMapping(&quot;/user/&#123;id&#125;&quot;)    @Operation(summary = &quot;获取用户信息&quot;, description = &quot;根据用户ID获取用户信息&quot;)    @ApiResponses(value =&#123;            @ApiResponse(responseCode = &quot;200&quot;, description = &quot;请求成功&quot;),            @ApiResponse(responseCode = &quot;404&quot;, description = &quot;用户不存在&quot;)    &#125;)    public User getUser( @Parameter(name = &quot;id&quot;, in = ParameterIn.PATH, description = &quot;用户ID&quot;, required = true) @PathVariable(&quot;id&quot;) Integer id)&#123;        User user = userService.getUserById(id);        return user;    &#125;&#125;\n\n\n⑤@RequestHeader 注解。\n很多时候我们接口都需要认证之后才能访问，这时候我们就需要接口调用的时候携带着 token 信息，我们通过 @RequestHeader 注解，获取请求头中 token 信息。\n@GetMapping(&quot;/index&quot;)public String  admin(@RequestHeader (&quot;token&quot;) String token)&#123;\tSystem.out.println(&quot;token&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot; + token);    //token 验证    //.....各种业务逻辑    return &quot;admin&quot;;&#125;\n\n\n实体类@Schema 注解，用于描述数据对象信息或数据对象属性，用在类或类属性上。\n\nname: 属性名称\ndescription: 属性描述\nrequired: 是否必须\nminLength: 字符最小长度\nmaxLength: 字符最大长度\n\n@Data@Schema(description = &quot;用户实体类&quot;, name = &quot;User&quot;)public class User &#123;    @Schema(description = &quot;用户名&quot;, name = &quot;name&quot;, minLength = 6, maxLength = 20, required = true)    private String name;    @Schema(description = &quot;年龄&quot;, name = &quot;age&quot;, required = true, minimum = &quot;1&quot;, maximum = &quot;100&quot;)    private Integer age;    @Schema(description = &quot;邮箱&quot;, name = &quot;email&quot;, required = true)    private String email;    @Schema(description = &quot;地址&quot;, name = &quot;address&quot;)    private String address;&#125;\n\n\n","categories":["学习笔记","后端知识","Spring"],"tags":["Spring Boot","Swagger"]},{"title":"JavaScript 模块化规范的使用说明","url":"/posts/2b046bca.html","content":"本文介绍了常用的 JavaScript 模块化规范的使用说明，包含 ESMA6、CommonJS 等其它规范。\n\n\n视频链接\nES6 模块规范ES6 模块规范主要用于客户端，也可用于服务端。\n使用方式在 node.js 服务端有两种使用方式：\n\n将 .js 文件改为 .mjs 文件。\n或者在 package.json 中添加定义 &#39;type&#39;: &#39;module&#39; 。\n\n在浏览器端使用：\n\n在 html 文件中使用 &lt;script type=&quot;module&quot; src=&quot;index.js&quot;&gt;&lt;/script&gt; 引入。\n\n\n直接在本地使用浏览器打开 html 文件浏览器会报错，请启动 web 服务器后通过 IP:端口 访问网页。\n\n导出数据导出有三种方式：\n\n分别导出\n\n// student.jsexport const name = &#x27;zhangsan&#x27;;export const age = &#x27;18&#x27;;export function getTel ()&#123;    return &#x27;13333333333&#x27;;&#125;function getSubject ()&#123;    return [&#x27;Java&#x27;, &#x27;C++&#x27;, &#x27;高等数学&#x27;];&#125;\n\n\n统一导出\n\n// student.jsconst name = &#x27;zhangsan&#x27;;const age = &#x27;18&#x27;;function getTel ()&#123;    return &#x27;13333333333&#x27;;&#125;function getSubject ()&#123;    return [&#x27;Java&#x27;, &#x27;C++&#x27;, &#x27;高等数学&#x27;];&#125;export &#123; name, age, getTel &#125;;\n\n\n默认导出\n\n// student.jsconst name = &#x27;zhangsan&#x27;;const age = &#x27;18&#x27;;function getTel ()&#123;    return &#x27;13333333333&#x27;;&#125;function getSubject ()&#123;    return [&#x27;Java&#x27;, &#x27;C++&#x27;, &#x27;高等数学&#x27;];&#125;// export default &#123;//     name: name,//     age: age,//     getTel: getTel// &#125;;// 可省略书写export default &#123; name, age, getTel &#125;;\n\n三种导出可以混用：\n// student.jsexport const name = &#x27;zhangsan&#x27;;const age = &#x27;18&#x27;;function getTel ()&#123;    return &#x27;13333333333&#x27;;&#125;function getSubject ()&#123;    return [&#x27;Java&#x27;, &#x27;C++&#x27;, &#x27;高等数学&#x27;];&#125;export &#123; age &#125;;export default &#123; getTel &#125;;\n\n会得到：\n[Module: null prototype] &#123;  age: &#x27;18&#x27;,  default: &#123; getTel: [Function: getTel] &#125;,  name: &#x27;zhangsan&#x27;&#125;\n\n\n\n导入数据对于 ES6 模块化来说，使用何种导入方式要根据导出方式决定。\n\n全部导入（通用）\n\n// index.jsimport * as student from &#x27;./student.js&#x27;;\n\n\n命名导入（对应：分别导出、统一导出）\n\n// index.jsimport &#123; name as newName, age, getTel &#125; from &#x27;./student.js&#x27;;\n\n\n默认导入（对应：默认导出）\n\n// index.jsimport student from &#x27;./student.js&#x27;;// student 变量名可以自己取\n\n\n默认导入和命名导入可以混用（当然不能和全部导入混用）：\n// student.jsexport const name = &#x27;zhangsan&#x27;;const age = &#x27;18&#x27;;function getTel ()&#123;    return &#x27;13333333333&#x27;;&#125;function getSubject ()&#123;    return [&#x27;Java&#x27;, &#x27;C++&#x27;, &#x27;高等数学&#x27;];&#125;export &#123; age &#125;;export default &#123; getTel &#125;;// index.jsimport newFun, &#123; name, age &#125; frome &#x27;./student.js&#x27;;\n\n\n直接导入不接收任何数据\n\n// log.jsconsole.log(&#x27;hello world!&#x27;);// index.jsimport &#x27;./log.js&#x27;;// 导入时 console.log() 会执行\n\n\n动态导入（通用）\n\n导入还可以根据事件来进行动态导入，下面的例子将演示当点击按钮时才导入：\n// student.jsconst name = &#x27;zhangsan&#x27;;const age = &#x27;18&#x27;;function getTel ()&#123;    return &#x27;13333333333&#x27;;&#125;function getSubject ()&#123;    return [&#x27;Java&#x27;, &#x27;C++&#x27;, &#x27;高等数学&#x27;];&#125;export &#123; name, age, getTel &#125;;// index.jsconst btn = document.getElementById(&#x27;btn&#x27;);btn.onclick = async() =&gt; &#123;    const result = await import(&#x27;./student.js&#x27;);    console.log(result);&#125;\n\n\n\n\nCommonJS 规范CommonJS 规范主要用于服务端，如果想要在浏览器端使用，可以通过 browserify 将原本的 js 文件进行翻译，再将翻译后的文件在 html 中引用。\n导出数据在 CommonJS 规范中有两种导出方式，导出的是一个普通对象，默认为 &#123;&#125;。\n通过 exports：\n// student.jsconst name = &#x27;zhangsan&#x27;;const age = &#x27;18&#x27;;function getTel ()&#123;    return &#x27;13333333333&#x27;;&#125;function getSubject ()&#123;    return [&#x27;Java&#x27;, &#x27;C++&#x27;, &#x27;高等数学&#x27;];&#125;exports.name = name;exports.age = age;exports.getTel = getTel;// 当然也可以使用 module.exports.name = name 只是书写更麻烦;\n\n通过 module.exports：\n// student.jsconst name = &#x27;zhangsan&#x27;;const age = &#x27;18&#x27;;function getTel ()&#123;    return &#x27;13333333333&#x27;;&#125;function getSubject ()&#123;    return [&#x27;Java&#x27;, &#x27;C++&#x27;, &#x27;高等数学&#x27;];&#125;// module.exports = &#123;//     name: name,//     age: age,//     getTel: getTel// &#125;;// 可省略书写module.exports = &#123; name, age, getTel &#125;;\n\n导入数据导入时会执行被导入文件中的代码：\n// student.jsconsole.log(&#x27;hello&#x27;);// index.jsconst student = require(&#x27;./student.js&#x27;);console.log(student);// 会输出：// hello// &#123;&#125;\n\n导入时也能通过解构赋值：\n// index.jsconst &#123; name: newName, age, getTel &#125; = require(&#x27;./student.js&#x27;); // 解构导入并重命名\n\n\n\n注意注意点如下：\n\n每个模块内部的：this、exports、module.exports 在初始时都指向同一个空对象。console.log(this===exports &amp;&amp; exports === module.exports); // true。\n无论如何修改导出对象，最终导出的都是 module.exports 的值。\nexports 是对 module.exports 的初始引用，仅为了方便给导出对象添加属性，所以不能使用 exports = value 的形式导出数据，可以使用 exports.value = value 、module.exports = value 导出数据。\n\n思考以下代码在导入时获取到的数据是什么？\n// student.jsconst name = &#x27;zhangsan&#x27;;const age = &#x27;18&#x27;;function getTel ()&#123;    return &#x27;13333333333&#x27;;&#125;function getSubject ()&#123;    return [&#x27;Java&#x27;, &#x27;C++&#x27;, &#x27;高等数学&#x27;];&#125;exports = &#123; a: 1 &#125;;exports.b = 2;module.exports.c = 3;module.exports = &#123; d: 4 &#125;;\n\n// index.jsconst student = require(&#x27;./student.js&#x27;);console.log(student);// 输出：&#123; d: 4 &#125;\n\n分析：\n\nexports -&gt; &#123;&#125; &lt;- module.exports\nexports -&gt; &#123; a: 1 &#125; ；module.exports -&gt; &#123;&#125;\nexports -&gt; &#123; a: 1, b: 2 &#125;；module.exports -&gt; &#123;&#125;\nexports -&gt; &#123; a: 1, b: 2 &#125;；module.exports -&gt; &#123; c: 3 &#125;\nexports -&gt; &#123; a: 1, b: 2 &#125;；没有东西指向 &#123; c: 3 &#125; ；module.exports -&gt; &#123; d: 4 &#125;\n\n模块化的好处模块化能够有效解决：\n\n全局污染问题\n数据安全问题\n依赖混乱问题\n\n1、全局污染、数据安全问题\n在使用模块化以前：\n// student.jsconst name = &#x27;zhangsan&#x27;;const age = &#x27;18&#x27;;function getTel ()&#123;    return &#x27;13333333333&#x27;;&#125;function getSubject ()&#123;    return [&#x27;Java&#x27;, &#x27;C++&#x27;, &#x27;高等数学&#x27;];&#125;\n\n&lt;!-- index.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;student.js&quot;&gt;&lt;/script&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;/body&gt;&lt;/html&gt;\n\n此时在浏览器控制台是能够获取到 name、age 等变量的，并且如果引入的多个文件有相同的变量名会产生冲突。\n使用模块化以后：\n// student.jsconst name = &#x27;zhangsan&#x27;;const age = &#x27;18&#x27;;function getTel ()&#123;    return &#x27;13333333333&#x27;;&#125;function getSubject ()&#123;    return [&#x27;Java&#x27;, &#x27;C++&#x27;, &#x27;高等数学&#x27;];&#125;export default &#123; name, age, getTel &#125;;// index.jsimport student from &#x27;./student.js&#x27;;\n\n&lt;!-- index.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;script type=&quot;module&quot; src=&quot;index.js&quot;&gt;&lt;/script&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;/body&gt;&lt;/html&gt;\n\n此时在浏览器控制台是无法获取到 student.name 变量的，而且在导入模块时能够对冲突的变量重命名，解决了数据安全、全局污染问题。\n2、依赖混乱问题\n在使用模块化以前，直接在 html 文件中引入 js 的顺序至关重要，尤其是需要引入多个 js 文件时，特别需要关注他们的依赖关系来确定引入顺序，十分麻烦。使用模块化后，可以在各个 js 文件中显式导入需要使用到的模块，而不用关心 html 文件中引入 js 的顺序。\n数据引入问题思考同一代码在 CommonJS 规范和 ES6 规范的执行结果：\n\nCommonJS 规范\n\n// data.jslet sum = 1;function increment() &#123;    sum += 1;&#125;module.exports = &#123; sum, increment &#125;;// index.jsconst &#123; sum, increment &#125; = require(&#x27;./data.js&#x27;);console.log(sum);increment();increment();console.log(sum);\n\n\n输出：\n1data: 2data: 31\n\n\nES6 规范\n\n// data.jslet sum = 1;function increment() &#123;    sum += 1;&#125;export &#123; sum, increment &#125;;// index.jsimport &#123; sum, increment &#125; from &#x27;./data.js&#x27;;console.log(sum);increment();increment();console.log(sum);\n\n\n输出：\n1data: 2data: 33\n\n对比两者发现，ES6 规范中执行完函数后的 sum 的值不一样了，是因为 index.js 和 data.js 中的 sum 是同一片内存空间（在 CommonJS 规范中导入是将值进行了复制），为了避免这种情况应该在 data.js 中声明常量而不是变量，即改为 const sum = 1。\n其它规范AMD 规范 是 RequireJS 在推广过程中对模块定义的规范化产出。\nCMD 规范 是 SeaJS 在推广过程中对模块定义的规范化产出。\n","categories":["学习笔记","编程语言","前端知识","JavaScript"],"tags":["JavaScript","ESMA6","CommonJS"]},{"title":"Spring Boot 参数校验","url":"/posts/f00bce88.html","content":"Spring Boot 中使用 JSR 对前端传来的数据进行校验的过程。 \n\n\n\n本文省略对返回结果和响应枚举类型的封装。\n\n导入包&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;&lt;/dependency&gt;\n\n在 spring-boot-starter-web 中已包含上述包。\n统一异常处理@Slf4j@RestControllerAdvicepublic class GlobalExceptionHandler &#123;    // 处理 @Valid 校验失败异常    @ExceptionHandler(MethodArgumentNotValidException.class)    public JSONResult&lt;Void&gt; handlerValidationException(MethodArgumentNotValidException e) &#123;        log.warn(&quot;参数校验失败：&quot; + e.getMessage(), e);        String errorMessage = e.getBindingResult()                .getAllErrors()                .stream()                .map(ObjectError::getDefaultMessage)                .collect(Collectors.joining(&quot;;&quot;));        return JSONResult.error(StatusCodeEnum.FAIL.getCode(), errorMessage);    &#125;        // 处理其它异常...&#125;\n\n\n\nJSR 注解校验UserVO\n@Datapublic class UserVO &#123;    @NotNull(message = &quot;用户名不能为空&quot;)    private String username;&#125;\n\nController\n@PostMapping(value=&quot;/save&quot;)// 接口接收参数上添加 @Valid 注解进行校验public JSONResult insert(@RequestBody @Valid UserVO vo)&#123;\tuserService.insert(vo);    return JSONResult.success();&#125;\n\n接收到前端发送请求后会对数据进行校验，如果校验失败会抛出 MethodArgumentNotValidException 异常，全局异常处理器将捕获到异常进行处理。\n测试当前端请求：\n&#123;    &quot;username&quot;: &quot;&quot;&#125;\n\n后端返回：\n&#123;    &quot;code&quot;: 400,    &quot;message&quot;: &quot;用户名不能为空&quot;&#125;\n\n\n","categories":["学习笔记","后端知识","Spring"],"tags":["Spring Boot"]},{"title":"Windows 注册表备忘","url":"/posts/e36ef7eb.html","content":"记录 Windows 系统常用注册表。\n\n系统代理记录清除删除 HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings 中 ProxyServer 和 ProxyOverride 的值\n共享网络默认网关修改修改 HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\SharedAccess\\Parameters 中 ScopeAddress 和 ScopeAddressBackup 的值\nRDP 默认端口修改修改 HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp 中 PortNumber 的值\nWebdav 挂载支持 http修改 HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\WebClient\\Parameters 中 BasicAuthLevel 的值为 2，然后重新启动计算机\n开机自启项可使用 autoruns 管理开机自启项。\nHKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\RunHKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnceHKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunHKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnceHKEY_LOCAL_MACHINE\\SOFTWARE\\WOW6432Node\\Microsoft\\Windows\\CurrentVersion\\Run\n","categories":["学习笔记","运维技巧","折腾记录"],"tags":["Windows","注册表"]},{"title":"Spring Framework","url":"/posts/874e8d58.html","content":"Spring Framework 是一个功能强大的 Java 应用程序框架，旨在提供高效且可扩展的开发环境。它结合了轻量级的容器和依赖注入功能，提供了一种使用 POJO 进行容器配置和面向切面的编程的简单方法，以及一组用于 AOP 的模块。\n\n\n\n\nSpring 两大核心机制：\n\nIoC（控制反转）：工厂模式\nAOP（面向切面编程）：代理模式\n\n开发步骤1、创建 Maven 工程，在 pom.xml 导入依赖：\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-framework-context&lt;/artifactId&gt;    &lt;version&gt;6.2.4&lt;/version&gt;&lt;/dependency&gt;\n\n2、在 resources 路径下创建 spring.xml：\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;bean id=&quot;student&quot; class=&quot;com.kecho.entity.Student&quot;/&gt;&lt;/beans&gt;\n\n3、获取 IoC 容器中已经创建的对象：\nApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);// 通过 bean id 获取，返回值需要强制类型转换Student student = (Student) context.getBean(&quot;student&quot;);// 也可以通过类名获取，但要确保容器中只有一个该类型的 bean// Student student = context.getBean(Student.class);System.out.println(student.toString());\n\n\n\n常用标签beanbean 标签用于创建一个对象，id 是唯一标识，class 是完全限定类名，name 可以同时取多个别名，别名之间可以使用空格或逗号或分号分隔。\n&lt;bean id=&quot;student&quot; class=&quot;com.kecho.entity.Student&quot; name=&quot;student1 student2 student3&quot;/&gt;\n\naliasalias 可用于配置别名，alias 的 name 对应需要取别名的 bean 的 id。\n&lt;bean id=&quot;student&quot; class=&quot;com.kecho.entity.Student&quot;/&gt;&lt;alias name=&quot;student&quot; alias=&quot;stuNew&quot; /&gt;\n\nimportimport 用于导入其它配置文件。\n&lt;import resource=&quot;beans1.xml&quot;/&gt;&lt;import resource=&quot;beans2.xml&quot;/&gt;\n\n\n\n创建顺序IoC 容器默认情况下是通过 spring.xml 中 bean 的配置顺序来决定创建顺序的，配置在前⾯的 bean 会先创建。在不更改配置顺序的前提下，通过 depends-on 来设置 bean 之间的依赖关系，从而调整 bean 的创建顺序。\n&lt;bean id=&quot;student&quot; class=&quot;com.kecho.entity.Student&quot; depends-on=&quot;cat&quot;/&gt;&lt;bean id=&quot;cat&quot; class=&quot;com.kecho.entity.Cat&quot;/&gt;\n\n上述代码的结果是先创建 Cat，再创建 Student 对象。\n创建方式IoC 容器通过读取 spring.xml 配置文件，按照顺序加载 bean 标签来创建对象，相当于替代了手动去 new 一个对象的过程，而创建对象的方式主要有两种：构造函数和 Setter 方法。\n通过构造函数IoC 容器通过对应构造函数去创建对象，这也要求实体类必须有对应的构造函数。\n\n无参构造函数（实体类必须有无参构造函数）\n\n&lt;bean id=&quot;student&quot; class=&quot;com.kecho.entity.Student&quot;&gt;&lt;/bean&gt;\n\n\n有参构造函数（实体类必须有相同参数列表的有参构造函数）\n\n&lt;bean id=&quot;student&quot; class=&quot;com.kecho.entity.Student&quot;&gt;    &lt;constructor-arg name=&quot;id&quot; value=&quot;1&quot;/&gt;    &lt;constructor-arg name=&quot;name&quot; value=&quot;kecho&quot;/&gt;    &lt;constructor-arg name=&quot;age&quot; value=&quot;18&quot;/&gt;&lt;/bean&gt;\n\n使用 name 时，参数顺序必须和构造函数中的参数顺序保持一致，其中 String 类型会自动转 int 类型（实体类 Student 中的 id 和 age 均为 int 类型）。\n你也可以使用 index 来避免顺序不一致导致可能出现的问题：\n&lt;bean id=&quot;student&quot; class=&quot;com.kecho.entity.Student&quot;&gt;    &lt;constructor-arg index=&quot;1&quot; value=&quot;kecho&quot;/&gt;    &lt;constructor-arg index=&quot;2&quot; value=&quot;18&quot;/&gt;    &lt;constructor-arg index=&quot;0&quot; value=&quot;1&quot;/&gt;&lt;/bean&gt;\n\n还可以使用 type 根据参数类型来匹配构造函数创建 bean（如果有多个有参构造函数，通过参数类型无法匹配到唯一的构造函数时会报错）：\n&lt;bean id=&quot;student&quot; class=&quot;com.kecho.entity.Student&quot;&gt;    &lt;constructor-arg type=&quot;int&quot; value=&quot;1&quot;/&gt;    &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;kecho&quot;/&gt;    &lt;constructor-arg type=&quot;int&quot; value=&quot;18&quot;/&gt;&lt;/bean&gt;\n\n\n\n通过 Setter 方法IoC 容器通过 Setter 方法去创建对象，这要求对应字段在实体类中必须有对应的 Setter 方法。\n&lt;bean id=&quot;student&quot; class=&quot;com.kecho.entity.Student&quot;&gt;    &lt;property name=&quot;id&quot; value=&quot;1&quot;/&gt;    &lt;property name=&quot;name&quot; value=&quot;kecho&quot;/&gt;    &lt;property name=&quot;age&quot; value=&quot;18&quot;/&gt;&lt;/bean&gt;\n\n如果我想把 name 的值设置为 &lt;小二&gt;，因为字符串包含了特殊字符，应该改用 CDATA 格式：\n&lt;bean id=&quot;student&quot; class=&quot;com.kecho.entity.Student&quot;&gt;    &lt;property name=&quot;id&quot; value=&quot;1&quot;/&gt;    &lt;property name=&quot;name&quot;&gt;        &lt;value&gt;&lt;![CDATA[&lt;小二&gt;]]]&gt;&lt;/value&gt;    &lt;/property&gt;    &lt;property name=&quot;age&quot; value=&quot;18&quot;/&gt; &lt;/bean&gt;\n\n\n\n两种创建方式的写法非常相似，主要是 constructor-arg 和 property 的不同，接下来的示例主要以 Setter 方法为主，构造器注入同理。\n依赖注入DI 是指 bean 之间的依赖注入，用于设置对象之间的级联关系。此时应该改用 ref 而不能改用 value，否则会抛出类型转换异常。除了 ref，还有数组、 List、Set、Map、Properties 类型，下面将使用 Setter 方式注入展示各种类型的写法：\n实体类 Student：\n@Data@ToString@AllArgsConstructor@NoArgsConstructorpublic class Student &#123;    private String name;    private Cat cat;    private String[] books;    private List&lt;String&gt; hobbys;    private Set&lt;String&gt; games;    private Map&lt;String,String&gt; card;    private String spouse;    private Properties info;&#125;\n\nspring.xml：\n&lt;bean id=&quot;cat&quot; class=&quot;com.kecho.entity.Cat&quot;/&gt;&lt;bean id=&quot;student&quot; class=&quot;com.kecho.entity.Student&quot;&gt;    &lt;!-- 普通值注入 value --&gt;    &lt;property name=&quot;name&quot; value=&quot;张三&quot; /&gt;    &lt;!-- 引用注入 ref --&gt;    &lt;property name=&quot;cat&quot; ref=&quot;cat&quot;/&gt;    &lt;!-- 数组 --&gt;    &lt;property name=&quot;books&quot;&gt;        &lt;array&gt;            &lt;value&gt;红楼梦&lt;/value&gt;            &lt;value&gt;西游记&lt;/value&gt;        &lt;/array&gt;    &lt;/property&gt;    &lt;!-- List --&gt;    &lt;property name=&quot;hobbys&quot;&gt;        &lt;list&gt;            &lt;value&gt;听歌&lt;/value&gt;            &lt;value&gt;敲代码&lt;/value&gt;        &lt;/list&gt;    &lt;/property&gt;    &lt;!-- Set --&gt;    &lt;property name=&quot;games&quot;&gt;        &lt;set&gt;            &lt;value&gt;LOL&lt;/value&gt;            &lt;value&gt;王者荣耀&lt;/value&gt;        &lt;/set&gt;    &lt;/property&gt;    &lt;!-- Map --&gt;    &lt;property name=&quot;card&quot;&gt;        &lt;map&gt;            &lt;entry key=&quot;身份证&quot; value=&quot;123456123412121234&quot;/&gt;        &lt;/map&gt;    &lt;/property&gt;    &lt;!-- null --&gt;    &lt;property name=&quot;spouse&quot;&gt;        &lt;null/&gt;    &lt;/property&gt;    &lt;!-- Properties --&gt;    &lt;property name=&quot;info&quot;&gt;        &lt;props&gt;            &lt;prop key=&quot;学号&quot;&gt;111111&lt;/prop&gt;            &lt;prop key=&quot;性别&quot;&gt;男&lt;/prop&gt;        &lt;/props&gt;    &lt;/property&gt;&lt;/bean&gt;\n\n上面如果改用构造器注入又改怎么写呢？只需要将 property 改成 constructor-arg 即可。\n命名空间c 命名空间c 命名空间对应构造器注入。\n使用 c 命名空间应在 xml 头部引入约束：xmlns:c=&quot;http://www.springframework.org/schema/c&quot;：\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:c=&quot;http://www.springframework.org/schema/c&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;bean id=&quot;cat&quot; class=&quot;com.kecho.entity.Cat&quot; c:name=&quot;咪咪&quot;/&gt;    &lt;bean id=&quot;student&quot; class=&quot;com.kecho.entity.Student&quot;           c:name=&quot;kecho&quot; c:id=&quot;1&quot; c:age=&quot;18&quot; c:cat-ref=&quot;cat&quot;/&gt;&lt;/beans&gt;\n\n\n\np 命名空间p 命名空间对应 Setter 方法注入。\n使用 p 命名空间应在 xml 头部引入约束：xmlns:p=&quot;http://www.springframework.org/schema/p&quot;：\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;bean id=&quot;cat&quot; class=&quot;com.kecho.entity.Cat&quot; p:name=&quot;咪咪&quot;/&gt;        &lt;bean id=&quot;student&quot; class=&quot;com.kecho.entity.Student&quot;     \tp:name=&quot;kecho&quot; p:id=&quot;1&quot; p:age=&quot;18&quot; p:cat-ref=&quot;cat&quot;/&gt;&lt;/beans&gt;\n\n\n\n\n\n作用域bean 是根据 scope 来⽣成，表示 bean 的作⽤域，scope 有4种类型：\n\nsingleton，单例，表示通过容器获取的对象是唯⼀的，默认值。\nprototype，原型，表示通过容器获取的对象是不同的。\nrequest，请求，表示在⼀次 HTTP 请求内有效。\nsession，会话，表示在⼀个⽤户会话内有效。\n\nrequset，session 适⽤于 Web 项⽬。\nsingleton 模式下，只要加载 IoC 容器，⽆论是否从 IoC 中取出 bean，配置⽂件中的 bean 都会被创建。prototype 模式下，如果不从 IoC 中取 bean，则不创建对象，取⼀次 bean，就会创建⼀个对象。\n&lt;bean id=&quot;student&quot; class=&quot;com.kecho.entity.Student&quot; scope=&quot;prototype&quot;/&gt;\n\n也可以通过对类添加注解 @Scope(&quot;prototype&quot;) 来实现同样功能。\n懒加载默认情况下，ApplicationContext 的实现会急切地创建和配置所有的单例 bean，你可以通过将 bean 定义标记为懒加载来阻止单例 bean 的预实例化。懒加载的 bean 告诉 IoC 容器在第一次被请求时创建一个 bean 实例，而不是在启动时。\n&lt;bean id=&quot;student&quot; class=&quot;com.example.Student&quot; lazy-init=&quot;true&quot;/&gt;\n\n当懒加载 bean 是被未懒加载的单例 bean 所依赖时，ApplicationContext 会在启动时创建懒加载 bean。\n你也可以通过使用 &lt;beans&gt; 元素上的 default-lazy-init 属性来控制容器级的懒加载：\n&lt;beans default-lazy-init=&quot;true&quot;&gt;    &lt;!-- no beans will be pre-instantiated... --&gt;&lt;/beans&gt;\n\n\n\n读取外部资源实际开发中，数据库的配置⼀般会单独保存到后缀为 properties 的⽂件中，⽅便维护和修改，如果使⽤ Spring 来加载数据源，就需要在 spring.xml 中读取 properties 中的数据，这就是读取外部资源。\njdbc.properties\nuser = rootpassword = rooturl = jdbc:mysql://localhost:3306/librarydriverName = com.mysql.cj.jdbc.Driver\n\nspring.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;    &lt;!-- 导⼊外部资源 --&gt;    &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt;    &lt;!-- SpEL --&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;com.southwind.entity.DataSource&quot;&gt;        &lt;property name=&quot;user&quot; value=&quot;$&#123;user&#125;&quot;/&gt;        &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt;        &lt;property name=&quot;driverName&quot; value=&quot;$&#123;driverName&#125;&quot;/&gt;        &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n\n\n工厂方法IoC 通过⼯⼚模式创建 bean 有两种⽅式：静态⼯⼚⽅法和实例⼯⼚⽅法，区别在于静态⼯⼚类不需要实例化，实例⼯⼚类需要实例化。\n静态⼯⼚⽅法1、创建 Car 类\n@Data@AllArgsConstructorpublic class Car &#123;\tprivate Integer num;\tprivate String brand;&#125;\n\n2、创建静态⼯⼚类、静态⼯⼚⽅法\npublic class StaticCarFactory&#123;\tprivate static Map&lt;Integer, Car&gt; carMap;\tstatic &#123;         carMap = new HashMap&lt;&gt;();        carMap.put(1,new Car(1,&quot;奥迪&quot;));        carMap.put(2,new Car(2,&quot;奥拓&quot;));\t&#125;\tpublic static Car getCar(Integer num)&#123;\t\treturn carMap.get(num);    &#125;&#125;\n\n3、spring.xml\n&lt;bean id=&quot;car1&quot; class=&quot;com.example.factory.StaticCarFactory&quot; factory-method=&quot;getCar&quot;&gt;\t&lt;constructor-arg value=&quot;1&quot;&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;\n\nfactory-method 指向静态⽅法，constructor-arg 的 value 属性是调⽤静态⽅法传⼊的参数。\n实例⼯⼚⽅法1、创建实例⼯⼚类、⼯⼚⽅法\npublic class InstanceCarFactory&#123;\tprivate Map&lt;Integer, Car&gt; carMap;\tpublic InstanceCarFactory() &#123;         carMap = new HashMap&lt;&gt;();        carMap.put(1,new Car(1,&quot;奥迪&quot;));        carMap.put(2,new Car(2,&quot;奥拓&quot;));\t&#125;\tpublic Car getCar(Integer num)&#123;\t\treturn carMap.get(num);    &#125;&#125;\n\n2、spring.xml\n&lt;bean id=&quot;instanceCarFactory&quot; class=&quot;com.example.factory.InstanceCarFactory&quot;/&gt;&lt;bean id=&quot;car2&quot; factory-bean=&quot;instanceCarFactory&quot; factory-method=&quot;getCar&quot;&gt;\t&lt;constructor-arg value=&quot;2&quot;&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;\n\n静态⼯⼚⽅法创建 Car 对象，不需要实例化⼯⼚对象，因为静态⼯⼚的静态⽅法，不需要创建对象即可调⽤，spring.xml 中只需要配置⼀个 bean，即最终的结果 Car 即可。\n实例⼯⼚⽅法创建 Car 对象，需要实例化⼯⼚对象，因为 getCar ⽅法是⾮静态的，就必须通过实例化对象才能调⽤，所以就必须要创建⼯⼚对象，spring.xml 中需要配置两个 bean，⼀个是⼯⼚ bean，⼀个是 Car bean。\n自动装载已知有两个实体类 Student 和 Cat。\nStudent：\n@Data@ToStringpublic class Student &#123;    private int id;    private String name;    private int age;    private Cat cat;&#125;\n\nCat：\n@Datapublic class Cat &#123;    private String name;&#125;\n\nspring.xml：\n&lt;bean id=&quot;cat&quot; class=&quot;com.kecho.entity.Cat&quot;&gt;    &lt;property name=&quot;name&quot; value=&quot;咪咪&quot;/&gt;&lt;/bean&gt;&lt;bean id=&quot;student&quot; class=&quot;com.kecho.entity.Student&quot; autowire=&quot;byName&quot;&gt;    &lt;property name=&quot;id&quot; value=&quot;1&quot;/&gt;    &lt;property name=&quot;name&quot; value=&quot;kecho&quot;/&gt;    &lt;property name=&quot;age&quot; value=&quot;18&quot;/&gt;&lt;/bean&gt;\n\n最终得到 Student(id=1, name=kecho, age=18, cat=Cat(name=咪咪))，通过 autowire 可以自动地将 cat 装载到 student 中，即使未显示使用 ref 声明。\nautowire 有两个值：byName 和 byType。\nbyName 会去找和 set 方法后面的值相同的 bean id 的 bean 自动装载，没有相同的则会报错。\nbyType 会去找和成员变量的数据类型相同的 bean 自动装载，如果容器中有两个相同类型的 bean 则会报错。\n基于注解开发使用注解开发需要：\n\n导入 context 约束\n配置注解支持\n\n以下创建 bean 时没有使用到 Setter 方法。\n手动创建需要在 xml 中手动声明 bean：\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;    &lt;context:annotation-config/&gt;    &lt;bean id=&quot;cat&quot; class=&quot;com.kecho.entity.Cat&quot;/&gt;    &lt;bean id=&quot;student&quot; class=&quot;com.kecho.entity.Student&quot;/&gt;&lt;/beans&gt;\n\n此时可以使用 @Value 来设置属性值，使用 @Autowired 实现自动装载：\npublic class Student &#123;    @Value(&quot;1&quot;)    private int id;    @Value(&quot;kecho&quot;)    private String name;    @Value(&quot;18&quot;)    private int age;        @Autowired    private Cat cat;&#125;\n\n如果容器中没有这个 bean，@Autowired 会自动装配失败报错，可以使用 @Autowired(require = false) 来允许为空。\n@Autowired 默认通过 byType 的方式来查找 bean，如果存在多个相同类型的 bean 也会无法自动装配，可以加上 @Qualifier(value = &quot;beanid&quot;) 指定装配相应 id 的 bean，不带参数的 @Qualifier 默认指定 id 与属性名对应的 bean。\n\n除了使用 @Autowired，Java 也有自己的注解 @Resource 实现相同的功能，也可以通过 @Resource(name = &quot;bean id&quot;) 指定 bean id 来自动装配对应的 bean。\n不同于 @Autowired 通过 byType 的方式来查找 bean，@Resource 默认通过 byName 的方式实现，如果找不到名字则通过 byType 的方式。\n\n自动扫描为了避免每个 bean 都需要自己手动去创建，可以配置扫描包：\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;    &lt;context:annotation-config/&gt;    &lt;context:component-scan base-package=&quot;com.kecho.entity&quot;/&gt;&lt;/beans&gt;\n\n此时使用 @Component 来自动加载：\n@Componentpublic class Student &#123;    @Value(&quot;1&quot;)    private int id;    @Value(&quot;kecho&quot;)    private String name;    @Value(&quot;18&quot;)    private int age;    @Autowired(required = false)    private Cat cat;&#125;\n\n除了 @Component 外，还有 @Repository、@Service、@Controller，这些注解的功能是一样的。\n@Configuration除了在 xml 配置文件中进行创建 bean、配置 context 约束、配置扫描包路径、配置注解的支持等等，还可以在 Java 类中进行配置：\nMyConfig 类：\n@Configuration // 相当于 beans 标签public class MyConfig &#123;    // 相当于一个 bean 标签    @Bean    public Student myStudent() &#123;  // Student 是 bean 的类型，myStudent 是 bean id        return new Student(1, &quot;kecho&quot;, 18);    &#125;&#125;\n\n获取 bean：\n// 不再通过 xml 文件获取上下文ApplicationContext context = new AnnotationConfigApplicationContext(MyConfig.class);User user = context.getBean(&quot;myUser&quot;, User.class);\n\n\n\n如果要自动扫描包来加载 bean，可以为 MyConfig 类设置 @ComponentScan(&quot;com.kecho.entity&quot;)，同时搭配 @Component 来自动加载 bean。如下：\nMyConfig 类：\n@Configuration@ComponentScan(&quot;com.kecho.entity&quot;)public class MyConfig &#123;&#125;\n\nStudent 类：\n@Componentpublic class Student &#123;    @Value(&quot;1&quot;)    private int id;    @Value(&quot;kecho&quot;)    private String name;    @Value(&quot;18&quot;)    private int age;    @Autowired(required = false)    private Cat cat;&#125;\n\n\n\n\n\nIoC控制反转（Inversion of Control，简称 IoC）是一种设计思想，它将对象的创建和依赖关系的管理交给容器，而不是在代码中直接控制对象的创建和依赖关系。IoC 的核心思想是通过容器来管理对象的生命周期和依赖关系，从而实现对象之间的松耦合。\n思想/* dao */public interface Fruit &#123;    public void get();&#125;/* daoImpl */public class Apple implements Fruit &#123;    public void get()&#123;        System.out.println(&quot;get a Apple&quot;);    &#125;&#125;public class Banana implements Fruit &#123;    public void get()&#123;        System.out.println(&quot;get a Banana&quot;);    &#125;&#125;/* service */public interface UserService &#123;    public void getFruit();&#125;/* serviceImpl */public UserServiceImpl implements UserService &#123;    private Fruit fruit = new Apple();        public void getFruit() &#123;        fruit.get();    &#125;&#125;/* 主程序测试 */public class MyTest &#123;    public static void main(String[] args) &#123;        UserService user = new UserServiceImpl();        user.getFruit(); // 输出 &quot;get a Apple&quot;     &#125;&#125;\n\n目前的控制权在业务层，每次用户需求改变时业务层也要跟着改变，即需要修改 UserServiceImpl 中的代码，如果工程量较大修改起来会很麻烦，而且修改代码容易对其它业务造成影响，可以考虑把控制权交给用户。\n修改业务层的代码实现控制权的转换，程序由主动创建对象变为被动接收对象：\n/* serviceImpl */public class UserServiceImpl implements UserService &#123;    private Fruit fruit;        // 利用 set 方法动态获取值的注入    public void setFruit(Fruit fruit) &#123;        this.fruit = fruit;    &#125;    public void getFruit() &#123;        this.fruit.get();    &#125;&#125;/* 主程序测试 */public class MyTest &#123;    public static void main(String[] args) &#123;        UserService user = new UserServiceImpl();        user.setFruit(new Apple());        //user.setFruit(new Banana());        user.getFruit();     &#125;&#125;\n\n在 spring.xml 中就是这么配置：\n&lt;bean id=&quot;apple&quot; class=&quot;com.example.dao.Apple&quot;/&gt;&lt;bean id=&quot;banana&quot; class=&quot;com.example.dao.Banana&quot;/&gt;&lt;bean id=&quot;userServiceImpl&quot; class=&quot;com.example.service.UserServiceImpl&quot;&gt;    &lt;property name=&quot;fruit&quot; ref=&quot;apple&quot; /&gt;&lt;/bean&gt;\n\n\n\n实现原理核⼼技术点：XML 解析 + 反射机制\n具体的思路：\n1、根据需求编写 XML ⽂件，配置需要创建的 bean。\n2、编写程序读取 XML ⽂件，获取 bean 相关信息，类、属性、id。\n3、根据第 2 步获取到的信息，结合反射机制动态创建对象，同时完成属性的赋值。\n4、将创建好的 bean 存⼊ Map 集合，设置 key - value 映射，key 就是 bean 中 id 值，value 就是 bean 对象。\n5、提供⽅法从 Map 中通过 id 获取到对应的 value。\n下面将自定义一个 MyClassPathXmlApplicationContext 类来实现。\n首先需要在 pom.xml 引入依赖解析 xml 文件：\n&lt;dependency&gt;    &lt;groupId&gt;dom4j&lt;/groupId&gt;    &lt;artifactId&gt;dom4j&lt;/artifactId&gt;    &lt;version&gt;1.6.1&lt;/version&gt;&lt;/dependency&gt;\n\n自定义 MyClassPathXmlApplicationContext 类（这里假设 bean 的属性仅为 int 或 String 类型）：\npublic class MyClassPathXmlApplicationContext implements ApplicationContext &#123;    private Map&lt;String, Object&gt; iocMap;    public MyClassPathXmlApplicationContext(String path) &#123;        iocMap = new HashMap&lt;&gt;();        parseXml(path);    &#125;    public void parseXml(String path)&#123;        SAXReader reader = new SAXReader();        try &#123;            Document document = reader.read(&quot;src/main/resources/&quot; + path);            Element rootElement = document.getRootElement();            Iterator&lt;Element&gt; elementIterator = rootElement.elementIterator();            while (elementIterator.hasNext()) &#123;                Element bean = elementIterator.next();                String beanID = bean.attributeValue(&quot;id&quot;);                String beanClassName = bean.attributeValue(&quot;class&quot;);                // 反射创建对象                Class myClass = Class.forName(beanClassName);                Constructor constructor = myClass.getConstructor();                Object object = constructor.newInstance();                // 给属性赋值                Iterator&lt;Element&gt; propertyIterator = bean.elementIterator();                while (propertyIterator.hasNext()) &#123;                    Element property = propertyIterator.next();                    String propertyName = property.attributeValue(&quot;name&quot;);                    String propertyValue = property.attributeValue(&quot;value&quot;);                    // 获取 setter 方法                    String methodName = &quot;set&quot; + propertyName.substring(0, 1).toUpperCase() + propertyName.substring(1);                    // 获取属性和方法                    Field field = myClass.getDeclaredField(propertyName);                    Method method = myClass.getMethod(methodName, field.getType());                    Object value = propertyValue;                    // 类型转换（这里假设 bean 的属性仅为 int 或 String 类型）                    switch (field.getType().getName())&#123;                        case &quot;java.lang.String&quot;:                            break;                        case &quot;int&quot;:                        case &quot;java.lang.Integer&quot;:                            value = Integer.parseInt(propertyValue);                            break;                    &#125;                    // 调用方法                    method.invoke(object, value);                &#125;                // 存入 Map                iocMap.put(beanID, object);            &#125;        &#125; catch (Exception e)&#123;            e.printStackTrace();        &#125;    &#125;        @Override    public Object getBean(String beanID) throws BeansException &#123;        return iocMap.get(beanID);    &#125;        // 省略其它需要重写的方法......&#125;\n\nspring.xml 配置：\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd &quot;&gt;    &lt;bean id=&quot;student&quot; class=&quot;com.kecho.entity.Student&quot;&gt;        &lt;property name=&quot;id&quot; value=&quot;1&quot;/&gt;        &lt;property name=&quot;name&quot; value=&quot;kecho&quot;/&gt;        &lt;property name=&quot;age&quot; value=&quot;18&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n测试类：\npublic static void main(String[] args  )&#123;    ApplicationContext context = new MyClassPathXmlApplicationContext(&quot;spring.xml&quot;);    Student student = (Student) context.getBean(&quot;student&quot;);    System.out.println(student);&#125;\n\n\n\n\nAOP","categories":["学习笔记","后端知识","Spring"],"tags":["Spring"]},{"title":"常用编程语言基础语法对比","url":"/posts/d0f4f654.html","content":"本文将对 Java、Go、Python 等编程语言的基础语法进行对比。\n\n\n导入包\n                \n                    JavaGoPython\n                \n                package com.example.main;import com.example.myapp.MyClass;import com.example.main.TestClass;package mainimport (    &quot;fmt&quot;    &quot;foo/bar&quot; // 导入本地包    myBar &quot;foo/bar&quot; // 别名    &quot;github.com/username/myproject/foo&quot; // 导入三方包)import module_name_1import module_name_2 as aliasfrom module_name_3 import class_name, func_namefrom module_name_4 import *  # 导入所有内容module = __import__(&#x27;module_name_5&#x27;)  # 动态导入\n          \n\n\n控制结构\n                \n                    JavaGoPython\n                \n                if 结构\nif ( condition1 ) &#123;    // ...&#125; else if ( condition2 ) &#123;    // ...&#125; else &#123;    // ...&#125;\n\nswitch 结构，多行语句不需要花括号但需要手动写 break;\nswitch ( val ) &#123;    case val1:        // ...        // ...        break;    case val2:        // ...        break;    default:        // ...&#125;\n\n循环结构\nfor ( int i = 0; i &lt; 10; i++ ) &#123;    count++;&#125;while ( condition ) &#123;    // ...&#125;do &#123;    // ...&#125; while ( condition );\n不需要小括号\n\nif 结构\nif condition1 &#123;    // ...&#125; else if condition2 &#123;    // ...    &#125; else &#123;    // ...&#125;\n\nswitch 结构，多行语句不需要花括号且不需要手动写 break;\nswitch val &#123;    case val1:        // ...        // ...    case val2:        // ...    default:        // ...&#125;\n\n循环结构，没有 while 关键字但有 for - range 结构\nfor i := 0; i &lt; 10; i++ &#123;    // ...&#125;for condition &#123;    // ...&#125;for pos, char := range myStr &#123;    // ...&#125;\n需要冒号，不需要花括号，小括号可省略，\n\nif 结构\nif condition1:    # ...elif condition2:    # ...elif condition3:    # ...else:    # ...\n\n没有 switch 结构，可以使用 and 或 or 来组合多个条件\nif condition1 or condition2:    # ...else:    # ...\n\n循环结构\nfor i in range(10):    # ...for letter in &#x27;Python&#x27;:   print(&quot;当前字母: %s&quot; % letter)while condition:    # ...\n          \n","categories":["学习笔记","后端知识","编程语言"]}]