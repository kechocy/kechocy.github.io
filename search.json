[{"title":"Spring Boot 参数校验","url":"/psts/f00bce88.html","content":"Spring Boot 中使用 JSR 对前端传来的数据进行校验的过程。 \n\n\n\n省略对返回结果和响应枚举类型的封装\n\n导入包&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;&lt;/dependency&gt;\n\n在 spring-boot-starter-web 中已包含上述包\n统一异常处理@Slf4j@RestControllerAdvicepublic class GlobalExceptionHandler &#123;    // 处理 @Valid 校验失败异常    @ExceptionHandler(MethodArgumentNotValidException.class)    public JSONResult&lt;Void&gt; handlerValidationException(MethodArgumentNotValidException e) &#123;        log.warn(&quot;参数校验失败：&quot; + e.getMessage(), e);        String errorMessage = e.getBindingResult()                .getAllErrors()                .stream()                .map(ObjectError::getDefaultMessage)                .collect(Collectors.joining(&quot;;&quot;));        return JSONResult.error(StatusCodeEnum.FAIL.getCode(), errorMessage);    &#125;        // 处理其它异常...&#125;\n\n\n\nJSR 注解校验UserVO\n@Datapublic class UserVO &#123;    @NotNull(message = &quot;用户名不能为空&quot;)    private String username;&#125;\n\nController\n@PostMapping(value=&quot;/save&quot;)// 接口接收参数上添加 @Valid 注解进行校验public JSONResult insert(@RequestBody @Valid UserVO vo)&#123;\tuserService.insert(vo);    return JSONResult.success();&#125;\n\n接收到前端发送请求后会对数据进行校验，如果校验失败会抛出 MethodArgumentNotValidException 异常，全局异常处理器将捕获到异常进行处理。\n测试当前端请求：\n&#123;    &quot;username&quot;: &quot;&quot;&#125;\n\n后端返回：\n&#123;    &quot;code&quot;: 400,    &quot;message&quot;: &quot;用户名不能为空&quot;&#125;\n\n\n","categories":["Java","Spring Boot"],"tags":["Spring Boot"]},{"title":"Spring Framework","url":"/psts/874e8d58.html","content":"Spring Framework 是一个功能强大的 Java 应用程序框架，旨在提供高效且可扩展的开发环境。它结合了轻量级的容器和依赖注入功能，提供了一种使用 POJO 进行容器配置和面向切面的编程的简单方法，以及一组用于 AOP 的模块。\n\n\n\n\nSpring 两大核心机制\n\nIoC（控制反转）：工厂模式\nAOP（面向切面编程）：代理模式\n\n开发步骤1、创建 Maven 工程，在 pom.xml 导入依赖：\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-framework-context&lt;/artifactId&gt;    &lt;version&gt;6.2.4&lt;/version&gt;&lt;/dependency&gt;\n\n2、在 resources 路径下创建 spring.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;bean id=&quot;student&quot; class=&quot;com.kecho.entity.Student&quot;/&gt;&lt;/beans&gt;\n\n3、获取 IoC 容器中已经创建的对象：\nApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);// 通过 bean id 获取，返回值需要强制类型转换Student student = (Student) context.getBean(&quot;student&quot;);// 也可以通过类名获取，但要确保容器中只有一个该类型的 bean// Student student = context.getBean(Student.class);System.out.println(student.toString());\n\n\n\n常用标签beanbean 标签用于创建一个对象，id 是唯一标识，class 是完全限定类名，name 可以同时取多个别名，别名之间可以使用空格或逗号或分号分隔。\n&lt;bean id=&quot;student&quot; class=&quot;com.kecho.entity.Student&quot; name=&quot;student1 student2 student3&quot;/&gt;\n\naliasalias 可用于配置别名，alias 的 name 对应需要取别名的 bean 的 id\n&lt;bean id=&quot;student&quot; class=&quot;com.kecho.entity.Student&quot;/&gt;&lt;alias name=&quot;student&quot; alias=&quot;stuNew&quot; /&gt;\n\nimportimport 用于导入其它配置文件\n&lt;import resource=&quot;beans1.xml&quot;/&gt;&lt;import resource=&quot;beans2.xml&quot;/&gt;\n\n\n\n创建顺序IoC 容器默认情况下是通过 spring.xml 中 bean 的配置顺序来决定创建顺序的，配置在前⾯的 bean 会先创建。在不更改 spring.xml 配置顺序的前提下，通过 depends-on 来设置 bean 之间的依赖关系，从而调整 bean 的创建顺序。\n&lt;bean id=&quot;student&quot; class=&quot;com.kecho.entity.Student&quot; depends-on=&quot;cat&quot;/&gt;&lt;bean id=&quot;cat&quot; class=&quot;com.kecho.entity.Cat&quot;/&gt;\n\n上述代码的结果是先创建 Cat，再创建 Student 对象。\n创建方式IoC 容器通过读取 spring.xml 配置文件，按照顺序加载 bean 标签来创建对象，相当于替代了手动去 new 一个对象的过程，而创建对象的方式主要有两种：构造函数和 Setter 方法。\n通过构造函数IoC 容器通过对应构造函数去创建对象，这也要求实体类必须有对应的构造函数。\n\n无参构造函数（实体类必须有无参构造函数）\n\n&lt;bean id=&quot;student&quot; class=&quot;com.kecho.entity.Student&quot;&gt;&lt;/bean&gt;\n\n\n有参构造函数（实体类必须有相同参数列表的有参构造函数）\n\n&lt;bean id=&quot;student&quot; class=&quot;com.kecho.entity.Student&quot;&gt;    &lt;constructor-arg name=&quot;id&quot; value=&quot;1&quot;/&gt;    &lt;constructor-arg name=&quot;name&quot; value=&quot;kecho&quot;/&gt;    &lt;constructor-arg name=&quot;age&quot; value=&quot;18&quot;/&gt;&lt;/bean&gt;\n\n使用 name 时，参数顺序必须和构造函数中的参数顺序保持一致，其中 String 类型会自动转 int 类型（实体类 Student 中的 id 和 age 均为 int 类型）。\n你也可以使用 index 来避免顺序不一致导致可能出现的问题：\n&lt;bean id=&quot;student&quot; class=&quot;com.kecho.entity.Student&quot;&gt;    &lt;constructor-arg index=&quot;1&quot; value=&quot;kecho&quot;/&gt;    &lt;constructor-arg index=&quot;2&quot; value=&quot;18&quot;/&gt;    &lt;constructor-arg index=&quot;0&quot; value=&quot;1&quot;/&gt;&lt;/bean&gt;\n\n还可以使用 type 根据参数类型来匹配构造函数创建 bean（如果有多个有参构造函数，通过参数类型无法匹配到唯一的构造函数时会报错）：\n&lt;bean id=&quot;student&quot; class=&quot;com.kecho.entity.Student&quot;&gt;    &lt;constructor-arg type=&quot;int&quot; value=&quot;1&quot;/&gt;    &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;kecho&quot;/&gt;    &lt;constructor-arg type=&quot;int&quot; value=&quot;18&quot;/&gt;&lt;/bean&gt;\n\n\n\n通过 Setter 方法IoC 容器通过 Setter 方法去创建对象，这要求对应字段在实体类中必须有对应的 Setter 方法。\n&lt;bean id=&quot;student&quot; class=&quot;com.kecho.entity.Student&quot;&gt;    &lt;property name=&quot;id&quot; value=&quot;1&quot;/&gt;    &lt;property name=&quot;name&quot; value=&quot;kecho&quot;/&gt;    &lt;property name=&quot;age&quot; value=&quot;18&quot;/&gt;&lt;/bean&gt;\n\n如果我想把 name 的值设置为 &lt;小二&gt;，因为字符串包含了特殊字符，应该改用 CDATA 格式：\n&lt;bean id=&quot;student&quot; class=&quot;com.kecho.entity.Student&quot;&gt;    &lt;property name=&quot;id&quot; value=&quot;1&quot;/&gt;    &lt;property name=&quot;name&quot;&gt;        &lt;value&gt;&lt;![CDATA[&lt;小二&gt;]]]&gt;&lt;/value&gt;    &lt;/property&gt;    &lt;property name=&quot;age&quot; value=&quot;18&quot;/&gt; &lt;/bean&gt;\n\n\n\n两种创建方式的写法非常相似，主要是 constructor-arg 和 property 的不同，接下来的示例主要以 Setter 方法为主，构造器注入同理。\n依赖注入DI 是指 bean 之间的依赖注入，用于设置对象之间的级联关系。此时应该改用 ref 而不能改用 value，否则会抛出类型转换异常。除了 ref，还有数组、 List、Set、Map、Properties 类型，下面将使用 Setter 方式注入展示各种类型的写法：\n实体类 Student：\n@Data@ToString@AllArgsConstructor@NoArgsConstructorpublic class Student &#123;    private String name;    private Cat cat;    private String[] books;    private List&lt;String&gt; hobbys;    private Set&lt;String&gt; games;    private Map&lt;String,String&gt; card;    private String spouse;    private Properties info;&#125;\n\nspring.xml：\n&lt;bean id=&quot;cat&quot; class=&quot;com.kecho.entity.Cat&quot;/&gt;&lt;bean id=&quot;student&quot; class=&quot;com.kecho.entity.Student&quot;&gt;    &lt;!-- 普通值注入 value --&gt;    &lt;property name=&quot;name&quot; value=&quot;张三&quot; /&gt;    &lt;!-- 引用注入 ref --&gt;    &lt;property name=&quot;cat&quot; ref=&quot;cat&quot;/&gt;    &lt;!-- 数组 --&gt;    &lt;property name=&quot;books&quot;&gt;        &lt;array&gt;            &lt;value&gt;红楼梦&lt;/value&gt;            &lt;value&gt;西游记&lt;/value&gt;        &lt;/array&gt;    &lt;/property&gt;    &lt;!-- List --&gt;    &lt;property name=&quot;hobbys&quot;&gt;        &lt;list&gt;            &lt;value&gt;听歌&lt;/value&gt;            &lt;value&gt;敲代码&lt;/value&gt;        &lt;/list&gt;    &lt;/property&gt;    &lt;!-- Set --&gt;    &lt;property name=&quot;games&quot;&gt;        &lt;set&gt;            &lt;value&gt;LOL&lt;/value&gt;            &lt;value&gt;王者荣耀&lt;/value&gt;        &lt;/set&gt;    &lt;/property&gt;    &lt;!-- Map --&gt;    &lt;property name=&quot;card&quot;&gt;        &lt;map&gt;            &lt;entry key=&quot;身份证&quot; value=&quot;123456123412121234&quot;/&gt;        &lt;/map&gt;    &lt;/property&gt;    &lt;!-- null --&gt;    &lt;property name=&quot;spouse&quot;&gt;        &lt;null/&gt;    &lt;/property&gt;    &lt;!-- Properties --&gt;    &lt;property name=&quot;info&quot;&gt;        &lt;props&gt;            &lt;prop key=&quot;学号&quot;&gt;111111&lt;/prop&gt;            &lt;prop key=&quot;性别&quot;&gt;男&lt;/prop&gt;        &lt;/props&gt;    &lt;/property&gt;&lt;/bean&gt;\n\n上面如果改用构造器注入又改怎么写呢？只需要将 property 改成 constructor-arg 即可。\n命名空间c 命名空间c 命名空间对应构造器注入\n使用 c 命名空间应在 xml 头部引入约束：xmlns:c=&quot;http://www.springframework.org/schema/c&quot;：\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:c=&quot;http://www.springframework.org/schema/c&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;bean id=&quot;cat&quot; class=&quot;com.kecho.entity.Cat&quot; c:name=&quot;咪咪&quot;/&gt;    &lt;bean id=&quot;student&quot; class=&quot;com.kecho.entity.Student&quot;           c:name=&quot;kecho&quot; c:id=&quot;1&quot; c:age=&quot;18&quot; c:cat-ref=&quot;cat&quot;/&gt;&lt;/beans&gt;\n\n\n\np 命名空间p 命名空间对应 Setter 方法注入。\n使用 p 命名空间应在 xml 头部引入约束：xmlns:p=&quot;http://www.springframework.org/schema/p&quot;：\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;bean id=&quot;cat&quot; class=&quot;com.kecho.entity.Cat&quot; p:name=&quot;咪咪&quot;/&gt;        &lt;bean id=&quot;student&quot; class=&quot;com.kecho.entity.Student&quot;     \tp:name=&quot;kecho&quot; p:id=&quot;1&quot; p:age=&quot;18&quot; p:cat-ref=&quot;cat&quot;/&gt;&lt;/beans&gt;\n\n\n\n\n\n作用域bean 是根据 scope 来⽣成，表示 bean 的作⽤域，scope 有4种类型：\n\nsingleton，单例，表示通过容器获取的对象是唯⼀的，默认值。\nprototype，原型，表示通过容器获取的对象是不同的。\nrequest，请求，表示在⼀次 HTTP 请求内有效。\nsession，会话，表示在⼀个⽤户会话内有效。\n\nrequset，session 适⽤于 Web 项⽬。\nsingleton 模式下，只要加载 IoC 容器，⽆论是否从 IoC 中取出 bean，配置⽂件中的 bean 都会被创建。prototype 模式下，如果不从 IoC 中取 bean，则不创建对象，取⼀次 bean，就会创建⼀个对象。\n&lt;bean id=&quot;student&quot; class=&quot;com.kecho.entity.Student&quot; scope=&quot;prototype&quot;/&gt;\n\n也可以通过对类添加注解 @Scope(&quot;prototype&quot;) 来实现同样功能。\n懒加载默认情况下，ApplicationContext 的实现会急切地创建和配置所有的单例 bean，你可以通过将 bean 定义标记为懒加载来阻止单例 bean 的预实例化。懒加载的 bean 告诉 IoC 容器在第一次被请求时创建一个 bean 实例，而不是在启动时。\n&lt;bean id=&quot;student&quot; class=&quot;com.example.Student&quot; lazy-init=&quot;true&quot;/&gt;\n\n当懒加载 bean 是被未懒加载的单例 bean 所依赖时，ApplicationContext 会在启动时创建懒加载 bean。\n你也可以通过使用 &lt;beans&gt; 元素上的 default-lazy-init 属性来控制容器级的懒加载：\n&lt;beans default-lazy-init=&quot;true&quot;&gt;    &lt;!-- no beans will be pre-instantiated... --&gt;&lt;/beans&gt;\n\n\n\n读取外部资源实际开发中，数据库的配置⼀般会单独保存到后缀为 properties 的⽂件中，⽅便维护和修改，如果使⽤ Spring 来加载数据源，就需要在 spring.xml 中读取 properties 中的数据，这就是读取外部资源。\njdbc.properties\nuser = rootpassword = rooturl = jdbc:mysql://localhost:3306/librarydriverName = com.mysql.cj.jdbc.Driver\n\nspring.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;    &lt;!-- 导⼊外部资源 --&gt;    &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt;    &lt;!-- SpEL --&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;com.southwind.entity.DataSource&quot;&gt;        &lt;property name=&quot;user&quot; value=&quot;$&#123;user&#125;&quot;/&gt;        &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt;        &lt;property name=&quot;driverName&quot; value=&quot;$&#123;driverName&#125;&quot;/&gt;        &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n\n\n工厂方法IoC 通过⼯⼚模式创建 bean 有两种⽅式：静态⼯⼚⽅法实例⼯⼚⽅法区别在于静态⼯⼚类不需要实例化，实例⼯⼚类需要实例化。\n静态⼯⼚⽅法1、创建 Car 类\n@Data@AllArgsConstructorpublic class Car &#123;\tprivate Integer num;\tprivate String brand;&#125;\n\n2、创建静态⼯⼚类、静态⼯⼚⽅法\npublic class StaticCarFactory&#123;\tprivate static Map&lt;Integer, Car&gt; carMap;\tstatic &#123;         carMap = new HashMap&lt;&gt;();        carMap.put(1,new Car(1,&quot;奥迪&quot;));        carMap.put(2,new Car(2,&quot;奥拓&quot;));\t&#125;\tpublic static Car getCar(Integer num)&#123;\t\treturn carMap.get(num);    &#125;&#125;\n\n3、spring.xml\n&lt;bean id=&quot;car1&quot; class=&quot;com.example.factory.StaticCarFactory&quot; factory-method=&quot;getCar&quot;&gt;\t&lt;constructor-arg value=&quot;1&quot;&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;\n\nfactory-method 指向静态⽅法\nconstructor-arg 的 value 属性是调⽤静态⽅法传⼊的参数\n实例⼯⼚⽅法1、创建实例⼯⼚类、⼯⼚⽅法\npublic class InstanceCarFactory&#123;\tprivate Map&lt;Integer, Car&gt; carMap;\tpublic InstanceCarFactory() &#123;         carMap = new HashMap&lt;&gt;();        carMap.put(1,new Car(1,&quot;奥迪&quot;));        carMap.put(2,new Car(2,&quot;奥拓&quot;));\t&#125;\tpublic Car getCar(Integer num)&#123;\t\treturn carMap.get(num);    &#125;&#125;\n\n2、spring.xml\n&lt;bean id=&quot;instanceCarFactory&quot; class=&quot;com.example.factory.InstanceCarFactory&quot;/&gt;&lt;bean id=&quot;car2&quot; factory-bean=&quot;instanceCarFactory&quot; factory-method=&quot;getCar&quot;&gt;\t&lt;constructor-arg value=&quot;2&quot;&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;\n\n静态⼯⼚⽅法创建 Car 对象，不需要实例化⼯⼚对象，因为静态⼯⼚的静态⽅法，不需要创建对象即可调⽤，spring.xml 中只需要配置⼀个 bean，即最终的结果 Car 即可。\n实例⼯⼚⽅法创建 Car 对象，需要实例化⼯⼚对象，因为 getCar ⽅法是⾮静态的，就必须通过实例化对象才能调⽤，所以就必须要创建⼯⼚对象，spring.xml 中需要配置两个 bean，⼀个是⼯⼚ bean，⼀个是 Car bean。\n自动装载已知有两个实体类 Student 和 Cat。\nStudent：\n@Data@ToStringpublic class Student &#123;    private int id;    private String name;    private int age;    private Cat cat;&#125;\n\nCat：\n@Datapublic class Cat &#123;    private String name;&#125;\n\nspring.xml：\n&lt;bean id=&quot;cat&quot; class=&quot;com.kecho.entity.Cat&quot;&gt;    &lt;property name=&quot;name&quot; value=&quot;咪咪&quot;/&gt;&lt;/bean&gt;&lt;bean id=&quot;student&quot; class=&quot;com.kecho.entity.Student&quot; autowire=&quot;byName&quot;&gt;    &lt;property name=&quot;id&quot; value=&quot;1&quot;/&gt;    &lt;property name=&quot;name&quot; value=&quot;kecho&quot;/&gt;    &lt;property name=&quot;age&quot; value=&quot;18&quot;/&gt;&lt;/bean&gt;\n\n最终得到 Student(id=1, name=kecho, age=18, cat=Cat(name=咪咪))，通过 autowire 可以自动地将 cat 装载到 student 中，即使未显示使用 ref 声明。\nautowire 有两个值：byName 和 byType。\nbyName 会去找和 set 方法后面的值相同的 bean id 的 bean 自动装载，没有相同的则会报错。\nbyType 会去找和成员变量的数据类型相同的 bean 自动装载，如果容器中有两个相同类型的 bean 则会报错。\n基于注解开发使用注解开发需要：\n\n导入 context 约束\n配置注解支持\n\n以下创建 bean 时没有使用到 Setter 方法。\n手动创建需要在 xml 中手动声明 bean：\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;    &lt;context:annotation-config/&gt;    &lt;bean id=&quot;cat&quot; class=&quot;com.kecho.entity.Cat&quot;/&gt;    &lt;bean id=&quot;student&quot; class=&quot;com.kecho.entity.Student&quot;/&gt;&lt;/beans&gt;\n\n此时可以使用 @Value 来设置属性值，使用 @Autowired 实现自动装载：\npublic class Student &#123;    @Value(&quot;1&quot;)    private int id;    @Value(&quot;kecho&quot;)    private String name;    @Value(&quot;18&quot;)    private int age;        @Autowired    private Cat cat;&#125;\n\n如果容器中没有这个 bean，@Autowired 会自动装配失败报错，可以使用 @Autowired(require &#x3D; false)  来允许为空。\n@Autowired 默认通过 byType 的方式来查找 bean，如果存在多个相同类型的 bean 也会无法自动装配，可以加上 @Qualifier(value = &quot;beanid&quot;) 指定装配相应 id 的 bean，不带参数的 @Qualifier  默认指定 id 与属性名对应的 bean。\n\n除了使用 @Autowired，Java 也有自己的注解 @Resource 实现相同的功能，也可以通过 @Resource(name = &quot;bean id&quot;) 指定 bean id 来自动装配对应的 bean。\n不同于 @Autowired 通过 byType 的方式来查找 bean，@Resource 默认通过 byName 的方式实现，如果找不到名字则通过 byType 的方式。\n\n自动扫描为了避免每个 bean 都需要自己手动去创建，可以配置扫描包：\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;    &lt;context:annotation-config/&gt;    &lt;context:component-scan base-package=&quot;com.kecho.entity&quot;/&gt;&lt;/beans&gt;\n\n此时使用 @Component 来自动加载：\n@Componentpublic class Student &#123;    @Value(&quot;1&quot;)    private int id;    @Value(&quot;kecho&quot;)    private String name;    @Value(&quot;18&quot;)    private int age;    @Autowired(required = false)    private Cat cat;&#125;\n\n除了 @Component 外，还有 @Repository 、@Service、@Controller ，这些注解的功能是一样的。\n@Configuration除了在 xml 配置文件中进行创建 bean、配置 context 约束、配置扫描包路径、配置注解的支持等等，还可以在 Java 类中进行配置：\nMyConfig 类：\n@Configuration // 相当于 beans 标签public class MyConfig &#123;    // 相当于一个 bean 标签    @Bean    public Student myStudent() &#123;  // Student 是 bean 的类型，myStudent 是 bean id        return new Student(1, &quot;kecho&quot;, 18);    &#125;&#125;\n\n获取 bean：\n// 不再通过 xml 文件获取上下文ApplicationContext context = new AnnotationConfigApplicationContext(MyConfig.class);User user = context.getBean(&quot;myUser&quot;, User.class);\n\n\n\n如果要自动扫描包来加载 bean，可以为 MyConfig 类设置 @ComponentScan(&quot;com.kecho.entity&quot;)，同时搭配 @Component 来自动加载 bean。如下：\nMyConfig 类：\n@Configuration@ComponentScan(&quot;com.kecho.entity&quot;)public class MyConfig &#123;&#125;\n\nStudent 类：\n@Componentpublic class Student &#123;    @Value(&quot;1&quot;)    private int id;    @Value(&quot;kecho&quot;)    private String name;    @Value(&quot;18&quot;)    private int age;    @Autowired(required = false)    private Cat cat;&#125;\n\n\n\n\n\nIoC控制反转（Inversion of Control，简称 IoC）是一种设计思想，它将对象的创建和依赖关系的管理交给容器，而不是在代码中直接控制对象的创建和依赖关系。IoC 的核心思想是通过容器来管理对象的生命周期和依赖关系，从而实现对象之间的松耦合。\n思想/* dao */public interface Fruit &#123;    public void get();&#125;/* daoImpl */public class Apple implements Fruit &#123;    public void get()&#123;        System.out.println(&quot;get a Apple&quot;);    &#125;&#125;public class Banana implements Fruit &#123;    public void get()&#123;        System.out.println(&quot;get a Banana&quot;);    &#125;&#125;/* service */public interface UserService &#123;    public void getFruit();&#125;/* serviceImpl */public UserServiceImpl implements UserService &#123;    private Fruit fruit = new Apple();        public void getFruit() &#123;        fruit.get();    &#125;&#125;/* 主程序测试 */public class MyTest &#123;    public static void main(String[] args) &#123;        UserService user = new UserServiceImpl();        user.getFruit(); // 输出 &quot;get a Apple&quot;     &#125;&#125;\n\n目前的控制权在业务层，每次用户需求改变时业务层也要跟着改变，即需要修改 UserServiceImpl 中的代码，如果工程量较大修改起来会很麻烦，而且修改代码容易对其它业务造成影响，可以考虑把控制权交给用户。\n修改业务层的代码实现控制权的转换，程序由主动创建对象变为被动接收对象：\n/* serviceImpl */public class UserServiceImpl implements UserService &#123;    private Fruit fruit;        // 利用 set 方法动态获取值的注入    public void setFruit(Fruit fruit) &#123;        this.fruit = fruit;    &#125;    public void getFruit() &#123;        this.fruit.get();    &#125;&#125;/* 主程序测试 */public class MyTest &#123;    public static void main(String[] args) &#123;        UserService user = new UserServiceImpl();        user.setFruit(new Apple());        //user.setFruit(new Banana());        user.getFruit();     &#125;&#125;\n\n在 spring.xml 中就是这么配置：\n&lt;bean id=&quot;apple&quot; class=&quot;com.example.dao.Apple&quot;/&gt;&lt;bean id=&quot;banana&quot; class=&quot;com.example.dao.Banana&quot;/&gt;&lt;bean id=&quot;userServiceImpl&quot; class=&quot;com.example.service.UserServiceImpl&quot;&gt;    &lt;property name=&quot;fruit&quot; ref=&quot;apple&quot; /&gt;&lt;/bean&gt;\n\n\n\n实现原理核⼼技术点：XML 解析 + 反射机制\n具体的思路：\n1、根据需求编写 XML ⽂件，配置需要创建的 bean。\n2、编写程序读取 XML ⽂件，获取 bean 相关信息，类、属性、id。\n3、根据第 2 步获取到的信息，结合反射机制动态创建对象，同时完成属性的赋值。\n4、将创建好的 bean 存⼊ Map 集合，设置 key - value 映射，key 就是 bean 中 id 值，value 就是 bean 对象。\n5、提供⽅法从 Map 中通过 id 获取到对应的 value。\n下面将自定义一个 MyClassPathXmlApplicationContext 类来实现。\n首先需要在 pom.xml 引入依赖解析 xml 文件：\n&lt;dependency&gt;    &lt;groupId&gt;dom4j&lt;/groupId&gt;    &lt;artifactId&gt;dom4j&lt;/artifactId&gt;    &lt;version&gt;1.6.1&lt;/version&gt;&lt;/dependency&gt;\n\n自定义 MyClassPathXmlApplicationContext 类（这里假设 bean 的属性仅为 int 或 String 类型）：\npublic class MyClassPathXmlApplicationContext implements ApplicationContext &#123;    private Map&lt;String, Object&gt; iocMap;    public MyClassPathXmlApplicationContext(String path) &#123;        iocMap = new HashMap&lt;&gt;();        parseXml(path);    &#125;    public void parseXml(String path)&#123;        SAXReader reader = new SAXReader();        try &#123;            Document document = reader.read(&quot;src/main/resources/&quot; + path);            Element rootElement = document.getRootElement();            Iterator&lt;Element&gt; elementIterator = rootElement.elementIterator();            while (elementIterator.hasNext()) &#123;                Element bean = elementIterator.next();                String beanID = bean.attributeValue(&quot;id&quot;);                String beanClassName = bean.attributeValue(&quot;class&quot;);                // 反射创建对象                Class myClass = Class.forName(beanClassName);                Constructor constructor = myClass.getConstructor();                Object object = constructor.newInstance();                // 给属性赋值                Iterator&lt;Element&gt; propertyIterator = bean.elementIterator();                while (propertyIterator.hasNext()) &#123;                    Element property = propertyIterator.next();                    String propertyName = property.attributeValue(&quot;name&quot;);                    String propertyValue = property.attributeValue(&quot;value&quot;);                    // 获取 setter 方法                    String methodName = &quot;set&quot; + propertyName.substring(0, 1).toUpperCase() + propertyName.substring(1);                    // 获取属性和方法                    Field field = myClass.getDeclaredField(propertyName);                    Method method = myClass.getMethod(methodName, field.getType());                    Object value = propertyValue;                    // 类型转换（这里假设 bean 的属性仅为 int 或 String 类型）                    switch (field.getType().getName())&#123;                        case &quot;java.lang.String&quot;:                            break;                        case &quot;int&quot;:                        case &quot;java.lang.Integer&quot;:                            value = Integer.parseInt(propertyValue);                            break;                    &#125;                    // 调用方法                    method.invoke(object, value);                &#125;                // 存入 Map                iocMap.put(beanID, object);            &#125;        &#125; catch (Exception e)&#123;            e.printStackTrace();        &#125;    &#125;        @Override    public Object getBean(String beanID) throws BeansException &#123;        return iocMap.get(beanID);    &#125;        // 省略其它需要重写的方法......&#125;\n\nspring.xml 配置：\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd &quot;&gt;    &lt;bean id=&quot;student&quot; class=&quot;com.kecho.entity.Student&quot;&gt;        &lt;property name=&quot;id&quot; value=&quot;1&quot;/&gt;        &lt;property name=&quot;name&quot; value=&quot;kecho&quot;/&gt;        &lt;property name=&quot;age&quot; value=&quot;18&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n测试类：\npublic static void main(String[] args  )&#123;    ApplicationContext context = new MyClassPathXmlApplicationContext(&quot;spring.xml&quot;);    Student student = (Student) context.getBean(&quot;student&quot;);    System.out.println(student);&#125;\n\n\n\n\nAOP","categories":["Java","Spring"],"tags":["Spring"]}]