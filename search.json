[{"title":"JavaScript 模块化规范的使用说明","url":"/posts/2b046bca.html","content":"本文介绍了常用的 JavaScript 模块化规范的使用说明，包含 ESMA6、CommonJS 等其它规范。\n\n\n视频链接\nESMA6 使用 import 关键字导入\nCommonJS 使用 require 关键字导入\nES6 模块规范ES6 模块规范主要用于客户端，也可用于服务端。\n使用方式服务端：\n\n将 .js 文件改为 .mjs 文件\n在 package.json 中添加定义 &#39;type&#39;: &#39;module&#39;\n\n浏览器端：\n\n在 html 文件中使用 &lt;script type=&quot;module&quot; src=&quot;index.js&quot;&gt;&lt;/script&gt; 引入。\n直接在本地使用浏览器打开 html 文件浏览器会报错，请启动 web 服务器后通过 IP:端口 访问网页。\n\n\n\n导出数据导出有三种方式：\n\n分别导出\n\n// student.jsexport const name = &#x27;zhangsan&#x27;;export const age = &#x27;18&#x27;;export function getTel ()&#123;    return &#x27;13333333333&#x27;;&#125;function getSubject ()&#123;    return [&#x27;Java&#x27;, &#x27;C++&#x27;, &#x27;高等数学&#x27;];&#125;// index.js// import &#123; name as newName, age, getTel &#125; from &#x27;./student.js&#x27;;// console.log(newName);\n\n\n统一导出\n\n// student.jsconst name = &#x27;zhangsan&#x27;;const age = &#x27;18&#x27;;function getTel ()&#123;    return &#x27;13333333333&#x27;;&#125;function getSubject ()&#123;    return [&#x27;Java&#x27;, &#x27;C++&#x27;, &#x27;高等数学&#x27;];&#125;export &#123; name, age, getTel &#125;;// index.js// import &#123; name as newName, age, getTel &#125; from &#x27;./student.js&#x27;;// console.log(newName);\n\n\n默认导出\n\n// student.jsconst name = &#x27;zhangsan&#x27;;const age = &#x27;18&#x27;;function getTel ()&#123;    return &#x27;13333333333&#x27;;&#125;function getSubject ()&#123;    return [&#x27;Java&#x27;, &#x27;C++&#x27;, &#x27;高等数学&#x27;];&#125;// export default &#123;//     name: name,//     age: age,//     getTel: getTel// &#125;;// 可省略书写export default &#123; name, age, getTel &#125;;// index.js// import student from &#x27;./student.js&#x27;;// console.log(student.name);\n\n导入数据除了使用相对应的导入方式外，还可以进行全部导入：\n// index.jsimport * as student from &#x27;./student.js&#x27;;console.log(student.name);\n\n\n也可以根据事件来进行动态导入：\n// student.jsconst name = &#x27;zhangsan&#x27;;const age = &#x27;18&#x27;;function getTel ()&#123;    return &#x27;13333333333&#x27;;&#125;function getSubject ()&#123;    return [&#x27;Java&#x27;, &#x27;C++&#x27;, &#x27;高等数学&#x27;];&#125;export &#123; name, age, getTel &#125;;// index.jsconst btn = document.getElementById(&#x27;btn&#x27;);btn.onclick = async() =&gt; &#123;    const result = await import(&#x27;./student.js&#x27;);    console.log(result);&#125;\n\n\nCommonJS 规范CommonJS 规范主要用于服务端\n使用方式如果想要在浏览器端使用，可以通过 browserify 将原本的 js 文件进行翻译，再将翻译后的文件在 html 中引用。\n导出数据在 CommonJS 规范中有两种导出方式，导出的是一个普通对象，默认为 &#123;&#125;。\n\n通过 exports：\n\n// student.jsconst name = &#x27;zhangsan&#x27;;const age = &#x27;18&#x27;;function getTel ()&#123;    return &#x27;13333333333&#x27;;&#125;function getSubject ()&#123;    return [&#x27;Java&#x27;, &#x27;C++&#x27;, &#x27;高等数学&#x27;];&#125;exports.name = name;exports.age = age;exports.getTel = getTel;// 也可以写成 module.exports.name = name;// index.js// const student = require(&#x27;./student.js&#x27;);// console.log(student.name);\n\n\n通过 module.exports：\n\n// student.jsconst name = &#x27;zhangsan&#x27;;const age = &#x27;18&#x27;;function getTel ()&#123;    return &#x27;13333333333&#x27;;&#125;function getSubject ()&#123;    return [&#x27;Java&#x27;, &#x27;C++&#x27;, &#x27;高等数学&#x27;];&#125;// module.exports = &#123;//     name: name,//     age: age,//     getTel: getTel// &#125;;// 可省略书写module.exports = &#123; name, age, getTel &#125;;// 不能写成 exports = &#123; name, age, getTel &#125;;// index.js// const student = require(&#x27;./student.js&#x27;);// console.log(student.name);\n\n导入数据导入时还能通过解构赋值：\n// index.jsconst &#123; name: newName, age, getTel &#125; = require(&#x27;./student.js&#x27;); // 解构导入并重命名console.log(newName);\n\n也可以根据事件来进行动态导入：\n// index.jsconst btn = document.getElementById(&#x27;btn&#x27;);btn.onclick = async() =&gt; &#123;    const result = await require(&#x27;./student.js&#x27;);    console.log(result);&#125;\n\n\n\n注意注意点如下：\n\n每个模块内部的：this、exports、module.exports 在初始时都指向同一个空对象。console.log(this===exports &amp;&amp; exports === module.exports); // true。\n无论如何修改导出对象，最终导出的都是 module.exports 的值。\nexports 是对 module.exports 的初始引用，仅为了方便给导出对象添加属性，所以不能使用 exports = value 的形式导出数据，可以使用 exports.value = value 、module.exports = value 导出数据。\n\n思考以下代码在导入时获取到的数据是什么？\n// student.jsconst name = &#x27;zhangsan&#x27;;const age = &#x27;18&#x27;;function getTel ()&#123;    return &#x27;13333333333&#x27;;&#125;function getSubject ()&#123;    return [&#x27;Java&#x27;, &#x27;C++&#x27;, &#x27;高等数学&#x27;];&#125;exports = &#123; a: 1 &#125;;exports.b = 2;module.exports.c = 3;module.exports = &#123; d: 4 &#125;;\n\n// index.jsconst student = require(&#x27;./student.js&#x27;);console.log(student);// 输出：&#123; d: 4 &#125;\n\n分析：\n\nexports -&gt; &#123;&#125; &lt;- module.exports\nexports -&gt; &#123; a: 1 &#125; ；module.exports -&gt; &#123;&#125;\nexports -&gt; &#123; a: 1, b: 2 &#125;；module.exports -&gt; &#123;&#125;\nexports -&gt; &#123; a: 1, b: 2 &#125;；module.exports -&gt; &#123; c: 3 &#125;\nexports -&gt; &#123; a: 1, b: 2 &#125;；没有东西指向 &#123; c: 3 &#125; ；module.exports -&gt; &#123; d: 4 &#125;\n\n导入时执行两种规范在导入时都会执行代码。如果有一个文件如下：\n// log.jsconsole.log(&#x27;hello world!&#x27;);\n\n导入时 console.log(&#39;hello world!&#39;) 会执行\n// import &#x27;./log.js&#x27;;  // ES 规范// const student = require(&#x27;./student.js&#x27;);  // CommonJS 规范// 会输出：// hello\n\n数据引入问题思考同一代码在 CommonJS 规范和 ES6 规范的执行结果：\n\nCommonJS 规范\n\n// data.jslet sum = 1;function increment() &#123;    sum += 1;&#125;module.exports = &#123; sum, increment &#125;;// index.jsconst &#123; sum, increment &#125; = require(&#x27;./data.js&#x27;);console.log(sum);increment();increment();console.log(sum);\n\n\n输出：\n1data: 2data: 31\n\n\nES6 规范\n\n// data.jslet sum = 1;function increment() &#123;    sum += 1;&#125;export &#123; sum, increment &#125;;// index.jsimport &#123; sum, increment &#125; from &#x27;./data.js&#x27;;console.log(sum);increment();increment();console.log(sum);\n\n\n输出：\n1data: 2data: 33\n\n对比两者发现，ES6 规范中执行完函数后的 sum 的值不一样了，是因为 index.js 和 data.js 中的 sum 是同一片内存空间（在 CommonJS 规范中导入是将值进行了复制），为了避免这种情况应该在 data.js 中声明常量而不是变量，即改为 const sum = 1。\n模块化的好处模块化能够有效解决：\n\n全局污染问题\n数据安全问题\n依赖混乱问题\n\n在使用模块化以前：\n// student.jsconst name = &#x27;zhangsan&#x27;;const age = &#x27;18&#x27;;function getTel ()&#123;    return &#x27;13333333333&#x27;;&#125;function getSubject ()&#123;    return [&#x27;Java&#x27;, &#x27;C++&#x27;, &#x27;高等数学&#x27;];&#125;\n\n&lt;!-- index.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;student.js&quot;&gt;&lt;/script&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;/body&gt;&lt;/html&gt;\n\n使用模块化以后：\n// student.jsconst name = &#x27;zhangsan&#x27;;const age = &#x27;18&#x27;;function getTel ()&#123;    return &#x27;13333333333&#x27;;&#125;function getSubject ()&#123;    return [&#x27;Java&#x27;, &#x27;C++&#x27;, &#x27;高等数学&#x27;];&#125;export default &#123; name, age, getTel &#125;;// index.jsimport student from &#x27;./student.js&#x27;;\n\n&lt;!-- index.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;script type=&quot;module&quot; src=&quot;index.js&quot;&gt;&lt;/script&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;/body&gt;&lt;/html&gt;\n\n1、全局污染\n使用模块化以前，如果引入的多个文件有相同的变量名会产生冲突。使用模块化以后，相同的变量名都会有自己的作用域。\n2、数据安全问题\n使用模块化以前，此时在浏览器控制台是能够获取到 name、age 等变量的。使用模块化以后，此时在浏览器控制台是无法获取到 student.name 变量的。\n3、依赖混乱问题\n在使用模块化以前，直接在 html 文件中引入 js 的顺序至关重要，尤其是需要引入多个 js 文件时，特别需要关注他们的依赖关系来确定引入顺序，十分麻烦。使用模块化后，可以在各个 js 文件中显式导入需要使用到的模块，而不用关心 html 文件中引入 js 的顺序。\n其它规范AMD 规范 是 RequireJS 在推广过程中对模块定义的规范化产出。\nCMD 规范 是 SeaJS 在推广过程中对模块定义的规范化产出。\n","categories":["学习笔记","前端知识"],"tags":["JavaScript","ESMA6","CommonJS"]},{"title":"KMP 算法实现及改良","url":"/posts/853edc9f.html","content":"与每趟匹配失败都从头开始重新比较的暴力匹配算法不同，KMP 算法会按照已记录的数组移动到指定位置开始比较，能大幅提高效率。而该数组记录的内容仅与模式串本身结构相关，与主串无关。\n\n\n理论知识设：\n\nababcabcacbab 为主串, i 为主串的遍历指针\nabcac 为子串， j 为子串（也称模式串）的遍历指针\npm 数组  为对应字符串的部分匹配值\nnext 数组 由 pm 数组 右移一位得到，其中规定 next[0] = -1\n\n\n\n\nindex\n0\n1\n2\n3\n4\n\n\n\nchar\na\nb\nc\na\nc\n\n\npm\n0\n0\n0\n1\n0\n\n\nnext\n-1\n0\n0\n0\n1\n\n\n在 KMP 算法匹配过程中，假设第 j 位失配（从 0 编号）\n已知：移动位数 = 已经匹配的字符数（0 ~ j-1 共 j 个） - 最后一个匹配字符的部分匹配值（pm[j-1]）\n记为：move = j - pm[j-1]\n替换：move = j - next[j]\n则 j 需要回退到 j - move 位置，即  j = j - move = j - (j - next[j]) = next[j] ，即 j 回退到 next[j] 位置\n具体匹配过程：\n\n第一次匹配（失配时 i = 2, j = 2）\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ni：\n0\n1\n2\n\n\n\n\n\n\n\n\n\n\n\n\n主串：\na\nb\na\nb\nc\na\nb\nc\na\nc\nb\na\nb\n\n\n子串：\na\nb\nc\n\n\n\n\n\n\n\n\n\n\n\n\nj：\n0\n1\n2\n\n\n\n\n\n\n\n\n\n\n\n\n\n子串应向后移动 2 位，j = 2 —-&gt; j = 0 （next[2] == 0），i = 2 —-&gt; i = 2 （ i 不变）\n\n\n第二次匹配（失配时 i = 6, j = 4）\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ni：\n0\n1\n2\n3\n4\n5\n6\n\n\n\n\n\n\n\n\n主串：\na\nb\na\nb\nc\na\nb\nc\na\nc\nb\na\nb\n\n\n子串：\n#\n#\na\nb\nc\na\nc\n\n\n\n\n\n\n\n\nj：\n\n\n0\n1\n2\n3\n4\n\n\n\n\n\n\n\n\n\n子串应继续向后移动 3 位，j = 4 —-&gt; j = 1 （next[4] == 1），i = 6 —-&gt; i = 6 （ i 不变）\n\n\n第三次匹配（匹配成功 i = 10, j = 5）\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ni：\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n\n主串：\na\nb\na\nb\nc\na\nb\nc\na\nc\nb\na\nb\n\n\n子串：\n#\n#\n*\n*\n*\na\nb\nc\na\nc\n\n\n\n\n\nj：\n\n\n\n\n\n0\n1\n2\n3\n4\n5\n\n\n\n\n\n匹配成功，返回子串在主串中的首位置：i - j = 5\n\n\n\n所以 KMP 算法如何实现的问题就转化为如何构建 next 数组的问题。\n手动如何求 next 数组呢？\n\n法一：先求部分匹配值，再右移得到 next 数组\n法二：由 [0…j-1]个字符（已经匹配成功的字符）组成的串的最长相等前后缀长度就是 next[j]\n\n\n注：不同书中定义的 next 数组含义不同，有的是没有右移之前的，有的是右移一位的（如本文），有的是右移一位后数值再加 1 的，要具体情况具体分析。另外，本文中数组从 0 开始存字符，有的书可能从 1 开始，对应的代码会有些许差别。\n\n代码实现第一步：求 next 数组\nvoid getNextTable(string pattern,int nextTable[])&#123;      nextTable[0] = -1; //第一个默认为-1      int j=0; //j表示next数组下标      int k=nextTable[j]; //k表示next数组的值      while(j &lt; pattern.size())&#123; //求next[j+1]          if(k==-1 || pattern[j] == pattern[k])&#123;              nextTable[++j]=++k;              //相当于 j++; next[j]=k+1; 计算出 next[j+1]，然后令 k=next[j]; 继续循环        &#125;else&#123;              k = nextTable[k];          &#125;      &#125;  &#125;\n\n第二步：根据 next 数组编写 KMP 算法\nint KMP(string pattern, string str,int nextTable[])&#123;      getNextTable(pattern,nextTable);//得到next数组      int i=0; int j=0;      while(i&lt;str.size() &amp;&amp; j&lt;pattern.size())&#123;          if(j==-1 || pattern[j]==str[i])&#123;              i++;             j++; //匹配成功则继续匹配          &#125;        else              j = nextTable[j];//匹配失败则回溯          &#125;      if(j==pattern.size())          return i-j; //返回子串在主串的首位置(下标从零开始)      else          return -1;  &#125; \n\n第三步：测试\n#include &lt;iostream&gt;  using namespace std;  int main()&#123;      string s=&quot;abcac&quot;;      string d=&quot;ababcabcacbab&quot;;      int nextTable[s.size()];     cout&lt;&lt;KMP(s,d,nextTable)&lt;&lt;endl; //匹配成功返回子串在主串的首位置，不匹配返回 -1    return 0;&#125;\n\n算法改良假设 j == 3 时失配，而 next[3] == 2, next[2] == 1, next[1] == 0, next[0] == -1 （由计算 next 数组的规则可知，此时模式串中第 0、1、2 个字符必相同），则 j 需要依次回退到 2、1、0，我们可以改善 next 数组，让 j 直接回退到 0 位置，减少无效判断次数。\n用 nextval数组 表示改良后的 next数组，过程如下：\n\n先算出 next 数组（next[0] = -1）\n如果第 j 个字符和 j 的 next 所指向的字符相同，则它们的 nextval 值相同；否则让 j 的 nextval 值与 next 值相等。\n\n代码如下：\nvoid getNextvalTable(string pattern,int nextvalTable[])&#123;      nextvalTable[0] = -1; //第一个默认为-1      int j=0; //j表示nextval数组下标      int k=nextvalTable[j]; //k表示nextval数组的值      while(j &lt; pattern.size())&#123; //求nextval[j+1]          if(k==-1 || pattern[j] == pattern[k])&#123;              if(pattern[++j] == pattern[++k])                nextvalTable[j] = nextvalTable[k];             else                nextvalTable[j] = k; //相当于nextval[j+1]=k+1; k=nextval[j+1]; j++;          &#125;else&#123;              k = nextvalTable[k];          &#125;      &#125;  &#125;\n\nKMP 算法只要将其调用的函数 getNextTable 改为 getNextvalTable ，其余保持不变。\n手动计算部分匹配值部分匹配值为字符串的前缀和后缀的最长相等前后缀长度，以 ababa 为例：\n\na 的前缀和后缀都为空集，最长相等前后缀长度为 0\nab 的前缀为 { a }，后缀为 { b } ，交集为空集，最长相等前后缀长度为 0\naba 的前缀为 { a, ab }，后缀为 { a, ba }，交集为 { a }，最长相等前后缀长度为 1\nabab 的前缀为 { a, ab, aba }，后缀为 { b, ab, bab }，交集为 { ab }，最长相等前后缀长度为 2\nababa 的前缀为 { a, ab, aba, abab }，后缀为 { a, ba, aba, baba }，交集为 { a, aba }，最长相等前后缀长度为 3所以字符串 ababa 的部分匹配值为 00123\n\n参考《王道数据结构考研复习指导》\n","categories":["学习笔记","数据结构与算法"],"tags":["KMP"]},{"title":"Spring Boot 参数校验","url":"/posts/f00bce88.html","content":"Spring Boot 中使用 JSR 对前端传来的数据进行校验的过程。 \n\n\n\n本文省略对返回结果和响应枚举类型的封装。\n\n导入包&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;&lt;/dependency&gt;\n\n在 spring-boot-starter-web 中已包含上述包。\n统一异常处理@Slf4j@RestControllerAdvicepublic class GlobalExceptionHandler &#123;    // 处理 @Valid 校验失败异常    @ExceptionHandler(MethodArgumentNotValidException.class)    public JSONResult&lt;Void&gt; handlerValidationException(MethodArgumentNotValidException e) &#123;        log.warn(&quot;参数校验失败：&quot; + e.getMessage(), e);        String errorMessage = e.getBindingResult()                .getAllErrors()                .stream()                .map(ObjectError::getDefaultMessage)                .collect(Collectors.joining(&quot;;&quot;));        return JSONResult.error(StatusCodeEnum.FAIL.getCode(), errorMessage);    &#125;        // 处理其它异常...&#125;\n\n\n\nJSR 注解校验UserVO\n@Datapublic class UserVO &#123;    @NotNull(message = &quot;用户名不能为空&quot;)    private String username;&#125;\n\nController\n@PostMapping(value=&quot;/save&quot;)// 接口接收参数上添加 @Valid 注解进行校验public JSONResult insert(@RequestBody @Valid UserVO vo)&#123;\tuserService.insert(vo);    return JSONResult.success();&#125;\n\n接收到前端发送请求后会对数据进行校验，如果校验失败会抛出 MethodArgumentNotValidException 异常，全局异常处理器将捕获到异常进行处理。\n测试当前端请求：\n&#123;    &quot;username&quot;: &quot;&quot;&#125;\n\n后端返回：\n&#123;    &quot;code&quot;: 400,    &quot;message&quot;: &quot;用户名不能为空&quot;&#125;\n\n\n","categories":["学习笔记","后端知识"],"tags":["Spring Boot"]},{"title":"Spring Framework","url":"/posts/874e8d58.html","content":"Spring Framework 是一个功能强大的 Java 应用程序框架，旨在提供高效且可扩展的开发环境。它结合了轻量级的容器和依赖注入功能，提供了一种使用 POJO 进行容器配置和面向切面的编程的简单方法，以及一组用于 AOP 的模块。\n\n\n\n\nSpring 两大核心机制：\n\nIoC（控制反转）：工厂模式\nAOP（面向切面编程）：代理模式\n\n开发步骤1、创建 Maven 工程，在 pom.xml 导入依赖：\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-framework-context&lt;/artifactId&gt;    &lt;version&gt;6.2.4&lt;/version&gt;&lt;/dependency&gt;\n\n2、在 resources 路径下创建 spring.xml：\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;bean id=&quot;student&quot; class=&quot;com.kecho.entity.Student&quot;/&gt;&lt;/beans&gt;\n\n3、获取 IoC 容器中已经创建的对象：\nApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);// 通过 bean id 获取，返回值需要强制类型转换Student student = (Student) context.getBean(&quot;student&quot;);// 也可以通过类名获取，但要确保容器中只有一个该类型的 bean// Student student = context.getBean(Student.class);System.out.println(student.toString());\n\n\n\n常用标签beanbean 标签用于创建一个对象，id 是唯一标识，class 是完全限定类名，name 可以同时取多个别名，别名之间可以使用空格或逗号或分号分隔。\n&lt;bean id=&quot;student&quot; class=&quot;com.kecho.entity.Student&quot; name=&quot;student1 student2 student3&quot;/&gt;\n\naliasalias 可用于配置别名，alias 的 name 对应需要取别名的 bean 的 id。\n&lt;bean id=&quot;student&quot; class=&quot;com.kecho.entity.Student&quot;/&gt;&lt;alias name=&quot;student&quot; alias=&quot;stuNew&quot; /&gt;\n\nimportimport 用于导入其它配置文件。\n&lt;import resource=&quot;beans1.xml&quot;/&gt;&lt;import resource=&quot;beans2.xml&quot;/&gt;\n\n\n\n创建顺序IoC 容器默认情况下是通过 spring.xml 中 bean 的配置顺序来决定创建顺序的，配置在前⾯的 bean 会先创建。在不更改配置顺序的前提下，通过 depends-on 来设置 bean 之间的依赖关系，从而调整 bean 的创建顺序。\n&lt;bean id=&quot;student&quot; class=&quot;com.kecho.entity.Student&quot; depends-on=&quot;cat&quot;/&gt;&lt;bean id=&quot;cat&quot; class=&quot;com.kecho.entity.Cat&quot;/&gt;\n\n上述代码的结果是先创建 Cat，再创建 Student 对象。\n创建方式IoC 容器通过读取 spring.xml 配置文件，按照顺序加载 bean 标签来创建对象，相当于替代了手动去 new 一个对象的过程，而创建对象的方式主要有两种：构造函数和 Setter 方法。\n通过构造函数IoC 容器通过对应构造函数去创建对象，这也要求实体类必须有对应的构造函数。\n\n无参构造函数（实体类必须有无参构造函数）\n\n&lt;bean id=&quot;student&quot; class=&quot;com.kecho.entity.Student&quot;&gt;&lt;/bean&gt;\n\n\n有参构造函数（实体类必须有相同参数列表的有参构造函数）\n\n&lt;bean id=&quot;student&quot; class=&quot;com.kecho.entity.Student&quot;&gt;    &lt;constructor-arg name=&quot;id&quot; value=&quot;1&quot;/&gt;    &lt;constructor-arg name=&quot;name&quot; value=&quot;kecho&quot;/&gt;    &lt;constructor-arg name=&quot;age&quot; value=&quot;18&quot;/&gt;&lt;/bean&gt;\n\n使用 name 时，参数顺序必须和构造函数中的参数顺序保持一致，其中 String 类型会自动转 int 类型（实体类 Student 中的 id 和 age 均为 int 类型）。\n你也可以使用 index 来避免顺序不一致导致可能出现的问题：\n&lt;bean id=&quot;student&quot; class=&quot;com.kecho.entity.Student&quot;&gt;    &lt;constructor-arg index=&quot;1&quot; value=&quot;kecho&quot;/&gt;    &lt;constructor-arg index=&quot;2&quot; value=&quot;18&quot;/&gt;    &lt;constructor-arg index=&quot;0&quot; value=&quot;1&quot;/&gt;&lt;/bean&gt;\n\n还可以使用 type 根据参数类型来匹配构造函数创建 bean（如果有多个有参构造函数，通过参数类型无法匹配到唯一的构造函数时会报错）：\n&lt;bean id=&quot;student&quot; class=&quot;com.kecho.entity.Student&quot;&gt;    &lt;constructor-arg type=&quot;int&quot; value=&quot;1&quot;/&gt;    &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;kecho&quot;/&gt;    &lt;constructor-arg type=&quot;int&quot; value=&quot;18&quot;/&gt;&lt;/bean&gt;\n\n\n\n通过 Setter 方法IoC 容器通过 Setter 方法去创建对象，这要求对应字段在实体类中必须有对应的 Setter 方法。\n&lt;bean id=&quot;student&quot; class=&quot;com.kecho.entity.Student&quot;&gt;    &lt;property name=&quot;id&quot; value=&quot;1&quot;/&gt;    &lt;property name=&quot;name&quot; value=&quot;kecho&quot;/&gt;    &lt;property name=&quot;age&quot; value=&quot;18&quot;/&gt;&lt;/bean&gt;\n\n如果我想把 name 的值设置为 &lt;小二&gt;，因为字符串包含了特殊字符，应该改用 CDATA 格式：\n&lt;bean id=&quot;student&quot; class=&quot;com.kecho.entity.Student&quot;&gt;    &lt;property name=&quot;id&quot; value=&quot;1&quot;/&gt;    &lt;property name=&quot;name&quot;&gt;        &lt;value&gt;&lt;![CDATA[&lt;小二&gt;]]]&gt;&lt;/value&gt;    &lt;/property&gt;    &lt;property name=&quot;age&quot; value=&quot;18&quot;/&gt; &lt;/bean&gt;\n\n\n\n两种创建方式的写法非常相似，主要是 constructor-arg 和 property 的不同，接下来的示例主要以 Setter 方法为主，构造器注入同理。\n依赖注入DI 是指 bean 之间的依赖注入，用于设置对象之间的级联关系。此时应该改用 ref 而不能改用 value，否则会抛出类型转换异常。除了 ref，还有数组、 List、Set、Map、Properties 类型，下面将使用 Setter 方式注入展示各种类型的写法：\n实体类 Student：\n@Data@ToString@AllArgsConstructor@NoArgsConstructorpublic class Student &#123;    private String name;    private Cat cat;    private String[] books;    private List&lt;String&gt; hobbys;    private Set&lt;String&gt; games;    private Map&lt;String,String&gt; card;    private String spouse;    private Properties info;&#125;\n\nspring.xml：\n&lt;bean id=&quot;cat&quot; class=&quot;com.kecho.entity.Cat&quot;/&gt;&lt;bean id=&quot;student&quot; class=&quot;com.kecho.entity.Student&quot;&gt;    &lt;!-- 普通值注入 value --&gt;    &lt;property name=&quot;name&quot; value=&quot;张三&quot; /&gt;    &lt;!-- 引用注入 ref --&gt;    &lt;property name=&quot;cat&quot; ref=&quot;cat&quot;/&gt;    &lt;!-- 数组 --&gt;    &lt;property name=&quot;books&quot;&gt;        &lt;array&gt;            &lt;value&gt;红楼梦&lt;/value&gt;            &lt;value&gt;西游记&lt;/value&gt;        &lt;/array&gt;    &lt;/property&gt;    &lt;!-- List --&gt;    &lt;property name=&quot;hobbys&quot;&gt;        &lt;list&gt;            &lt;value&gt;听歌&lt;/value&gt;            &lt;value&gt;敲代码&lt;/value&gt;        &lt;/list&gt;    &lt;/property&gt;    &lt;!-- Set --&gt;    &lt;property name=&quot;games&quot;&gt;        &lt;set&gt;            &lt;value&gt;LOL&lt;/value&gt;            &lt;value&gt;王者荣耀&lt;/value&gt;        &lt;/set&gt;    &lt;/property&gt;    &lt;!-- Map --&gt;    &lt;property name=&quot;card&quot;&gt;        &lt;map&gt;            &lt;entry key=&quot;身份证&quot; value=&quot;123456123412121234&quot;/&gt;        &lt;/map&gt;    &lt;/property&gt;    &lt;!-- null --&gt;    &lt;property name=&quot;spouse&quot;&gt;        &lt;null/&gt;    &lt;/property&gt;    &lt;!-- Properties --&gt;    &lt;property name=&quot;info&quot;&gt;        &lt;props&gt;            &lt;prop key=&quot;学号&quot;&gt;111111&lt;/prop&gt;            &lt;prop key=&quot;性别&quot;&gt;男&lt;/prop&gt;        &lt;/props&gt;    &lt;/property&gt;&lt;/bean&gt;\n\n上面如果改用构造器注入又改怎么写呢？只需要将 property 改成 constructor-arg 即可。\n命名空间c 命名空间c 命名空间对应构造器注入。\n使用 c 命名空间应在 xml 头部引入约束：xmlns:c=&quot;http://www.springframework.org/schema/c&quot;：\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:c=&quot;http://www.springframework.org/schema/c&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;bean id=&quot;cat&quot; class=&quot;com.kecho.entity.Cat&quot; c:name=&quot;咪咪&quot;/&gt;    &lt;bean id=&quot;student&quot; class=&quot;com.kecho.entity.Student&quot;           c:name=&quot;kecho&quot; c:id=&quot;1&quot; c:age=&quot;18&quot; c:cat-ref=&quot;cat&quot;/&gt;&lt;/beans&gt;\n\n\n\np 命名空间p 命名空间对应 Setter 方法注入。\n使用 p 命名空间应在 xml 头部引入约束：xmlns:p=&quot;http://www.springframework.org/schema/p&quot;：\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;bean id=&quot;cat&quot; class=&quot;com.kecho.entity.Cat&quot; p:name=&quot;咪咪&quot;/&gt;        &lt;bean id=&quot;student&quot; class=&quot;com.kecho.entity.Student&quot;     \tp:name=&quot;kecho&quot; p:id=&quot;1&quot; p:age=&quot;18&quot; p:cat-ref=&quot;cat&quot;/&gt;&lt;/beans&gt;\n\n\n\n\n\n作用域bean 是根据 scope 来⽣成，表示 bean 的作⽤域，scope 有4种类型：\n\nsingleton，单例，表示通过容器获取的对象是唯⼀的，默认值。\nprototype，原型，表示通过容器获取的对象是不同的。\nrequest，请求，表示在⼀次 HTTP 请求内有效。\nsession，会话，表示在⼀个⽤户会话内有效。\n\nrequset，session 适⽤于 Web 项⽬。\nsingleton 模式下，只要加载 IoC 容器，⽆论是否从 IoC 中取出 bean，配置⽂件中的 bean 都会被创建。prototype 模式下，如果不从 IoC 中取 bean，则不创建对象，取⼀次 bean，就会创建⼀个对象。\n&lt;bean id=&quot;student&quot; class=&quot;com.kecho.entity.Student&quot; scope=&quot;prototype&quot;/&gt;\n\n也可以通过对类添加注解 @Scope(&quot;prototype&quot;) 来实现同样功能。\n懒加载默认情况下，ApplicationContext 的实现会急切地创建和配置所有的单例 bean，你可以通过将 bean 定义标记为懒加载来阻止单例 bean 的预实例化。懒加载的 bean 告诉 IoC 容器在第一次被请求时创建一个 bean 实例，而不是在启动时。\n&lt;bean id=&quot;student&quot; class=&quot;com.example.Student&quot; lazy-init=&quot;true&quot;/&gt;\n\n当懒加载 bean 是被未懒加载的单例 bean 所依赖时，ApplicationContext 会在启动时创建懒加载 bean。\n你也可以通过使用 &lt;beans&gt; 元素上的 default-lazy-init 属性来控制容器级的懒加载：\n&lt;beans default-lazy-init=&quot;true&quot;&gt;    &lt;!-- no beans will be pre-instantiated... --&gt;&lt;/beans&gt;\n\n\n\n读取外部资源实际开发中，数据库的配置⼀般会单独保存到后缀为 properties 的⽂件中，⽅便维护和修改，如果使⽤ Spring 来加载数据源，就需要在 spring.xml 中读取 properties 中的数据，这就是读取外部资源。\njdbc.properties\nuser = rootpassword = rooturl = jdbc:mysql://localhost:3306/librarydriverName = com.mysql.cj.jdbc.Driver\n\nspring.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;    &lt;!-- 导⼊外部资源 --&gt;    &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt;    &lt;!-- SpEL --&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;com.southwind.entity.DataSource&quot;&gt;        &lt;property name=&quot;user&quot; value=&quot;$&#123;user&#125;&quot;/&gt;        &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt;        &lt;property name=&quot;driverName&quot; value=&quot;$&#123;driverName&#125;&quot;/&gt;        &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n\n\n工厂方法IoC 通过⼯⼚模式创建 bean 有两种⽅式：静态⼯⼚⽅法和实例⼯⼚⽅法，区别在于静态⼯⼚类不需要实例化，实例⼯⼚类需要实例化。\n静态⼯⼚⽅法1、创建 Car 类\n@Data@AllArgsConstructorpublic class Car &#123;\tprivate Integer num;\tprivate String brand;&#125;\n\n2、创建静态⼯⼚类、静态⼯⼚⽅法\npublic class StaticCarFactory&#123;\tprivate static Map&lt;Integer, Car&gt; carMap;\tstatic &#123;         carMap = new HashMap&lt;&gt;();        carMap.put(1,new Car(1,&quot;奥迪&quot;));        carMap.put(2,new Car(2,&quot;奥拓&quot;));\t&#125;\tpublic static Car getCar(Integer num)&#123;\t\treturn carMap.get(num);    &#125;&#125;\n\n3、spring.xml\n&lt;bean id=&quot;car1&quot; class=&quot;com.example.factory.StaticCarFactory&quot; factory-method=&quot;getCar&quot;&gt;\t&lt;constructor-arg value=&quot;1&quot;&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;\n\nfactory-method 指向静态⽅法，constructor-arg 的 value 属性是调⽤静态⽅法传⼊的参数。\n实例⼯⼚⽅法1、创建实例⼯⼚类、⼯⼚⽅法\npublic class InstanceCarFactory&#123;\tprivate Map&lt;Integer, Car&gt; carMap;\tpublic InstanceCarFactory() &#123;         carMap = new HashMap&lt;&gt;();        carMap.put(1,new Car(1,&quot;奥迪&quot;));        carMap.put(2,new Car(2,&quot;奥拓&quot;));\t&#125;\tpublic Car getCar(Integer num)&#123;\t\treturn carMap.get(num);    &#125;&#125;\n\n2、spring.xml\n&lt;bean id=&quot;instanceCarFactory&quot; class=&quot;com.example.factory.InstanceCarFactory&quot;/&gt;&lt;bean id=&quot;car2&quot; factory-bean=&quot;instanceCarFactory&quot; factory-method=&quot;getCar&quot;&gt;\t&lt;constructor-arg value=&quot;2&quot;&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;\n\n静态⼯⼚⽅法创建 Car 对象，不需要实例化⼯⼚对象，因为静态⼯⼚的静态⽅法，不需要创建对象即可调⽤，spring.xml 中只需要配置⼀个 bean，即最终的结果 Car 即可。\n实例⼯⼚⽅法创建 Car 对象，需要实例化⼯⼚对象，因为 getCar ⽅法是⾮静态的，就必须通过实例化对象才能调⽤，所以就必须要创建⼯⼚对象，spring.xml 中需要配置两个 bean，⼀个是⼯⼚ bean，⼀个是 Car bean。\n自动装载已知有两个实体类 Student 和 Cat。\nStudent：\n@Data@ToStringpublic class Student &#123;    private int id;    private String name;    private int age;    private Cat cat;&#125;\n\nCat：\n@Datapublic class Cat &#123;    private String name;&#125;\n\nspring.xml：\n&lt;bean id=&quot;cat&quot; class=&quot;com.kecho.entity.Cat&quot;&gt;    &lt;property name=&quot;name&quot; value=&quot;咪咪&quot;/&gt;&lt;/bean&gt;&lt;bean id=&quot;student&quot; class=&quot;com.kecho.entity.Student&quot; autowire=&quot;byName&quot;&gt;    &lt;property name=&quot;id&quot; value=&quot;1&quot;/&gt;    &lt;property name=&quot;name&quot; value=&quot;kecho&quot;/&gt;    &lt;property name=&quot;age&quot; value=&quot;18&quot;/&gt;&lt;/bean&gt;\n\n最终得到 Student(id=1, name=kecho, age=18, cat=Cat(name=咪咪))，通过 autowire 可以自动地将 cat 装载到 student 中，即使未显示使用 ref 声明。\nautowire 有两个值：byName 和 byType。\nbyName 会去找和 set 方法后面的值相同的 bean id 的 bean 自动装载，没有相同的则会报错。\nbyType 会去找和成员变量的数据类型相同的 bean 自动装载，如果容器中有两个相同类型的 bean 则会报错。\n基于注解开发使用注解开发需要：\n\n导入 context 约束\n配置注解支持\n\n以下创建 bean 时没有使用到 Setter 方法。\n手动创建需要在 xml 中手动声明 bean：\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;    &lt;context:annotation-config/&gt;    &lt;bean id=&quot;cat&quot; class=&quot;com.kecho.entity.Cat&quot;/&gt;    &lt;bean id=&quot;student&quot; class=&quot;com.kecho.entity.Student&quot;/&gt;&lt;/beans&gt;\n\n此时可以使用 @Value 来设置属性值，使用 @Autowired 实现自动装载：\npublic class Student &#123;    @Value(&quot;1&quot;)    private int id;    @Value(&quot;kecho&quot;)    private String name;    @Value(&quot;18&quot;)    private int age;        @Autowired    private Cat cat;&#125;\n\n如果容器中没有这个 bean，@Autowired 会自动装配失败报错，可以使用 @Autowired(require = false) 来允许为空。\n@Autowired 默认通过 byType 的方式来查找 bean，如果存在多个相同类型的 bean 也会无法自动装配，可以加上 @Qualifier(value = &quot;beanid&quot;) 指定装配相应 id 的 bean，不带参数的 @Qualifier 默认指定 id 与属性名对应的 bean。\n\n除了使用 @Autowired，Java 也有自己的注解 @Resource 实现相同的功能，也可以通过 @Resource(name = &quot;bean id&quot;) 指定 bean id 来自动装配对应的 bean。\n不同于 @Autowired 通过 byType 的方式来查找 bean，@Resource 默认通过 byName 的方式实现，如果找不到名字则通过 byType 的方式。\n\n自动扫描为了避免每个 bean 都需要自己手动去创建，可以配置扫描包：\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;    &lt;context:annotation-config/&gt;    &lt;context:component-scan base-package=&quot;com.kecho.entity&quot;/&gt;&lt;/beans&gt;\n\n此时使用 @Component 来自动加载：\n@Componentpublic class Student &#123;    @Value(&quot;1&quot;)    private int id;    @Value(&quot;kecho&quot;)    private String name;    @Value(&quot;18&quot;)    private int age;    @Autowired(required = false)    private Cat cat;&#125;\n\n除了 @Component 外，还有 @Repository、@Service、@Controller，这些注解的功能是一样的。\n@Configuration除了在 xml 配置文件中进行创建 bean、配置 context 约束、配置扫描包路径、配置注解的支持等等，还可以在 Java 类中进行配置：\nMyConfig 类：\n@Configuration // 相当于 beans 标签public class MyConfig &#123;    // 相当于一个 bean 标签    @Bean    public Student myStudent() &#123;  // Student 是 bean 的类型，myStudent 是 bean id        return new Student(1, &quot;kecho&quot;, 18);    &#125;&#125;\n\n获取 bean：\n// 不再通过 xml 文件获取上下文ApplicationContext context = new AnnotationConfigApplicationContext(MyConfig.class);User user = context.getBean(&quot;myUser&quot;, User.class);\n\n\n\n如果要自动扫描包来加载 bean，可以为 MyConfig 类设置 @ComponentScan(&quot;com.kecho.entity&quot;)，同时搭配 @Component 来自动加载 bean。如下：\nMyConfig 类：\n@Configuration@ComponentScan(&quot;com.kecho.entity&quot;)public class MyConfig &#123;&#125;\n\nStudent 类：\n@Componentpublic class Student &#123;    @Value(&quot;1&quot;)    private int id;    @Value(&quot;kecho&quot;)    private String name;    @Value(&quot;18&quot;)    private int age;    @Autowired(required = false)    private Cat cat;&#125;\n\n\n\n\n\nIoC控制反转（Inversion of Control，简称 IoC）是一种设计思想，它将对象的创建和依赖关系的管理交给容器，而不是在代码中直接控制对象的创建和依赖关系。IoC 的核心思想是通过容器来管理对象的生命周期和依赖关系，从而实现对象之间的松耦合。\n思想/* dao */public interface Fruit &#123;    public void get();&#125;/* daoImpl */public class Apple implements Fruit &#123;    public void get()&#123;        System.out.println(&quot;get a Apple&quot;);    &#125;&#125;public class Banana implements Fruit &#123;    public void get()&#123;        System.out.println(&quot;get a Banana&quot;);    &#125;&#125;/* service */public interface UserService &#123;    public void getFruit();&#125;/* serviceImpl */public UserServiceImpl implements UserService &#123;    private Fruit fruit = new Apple();        public void getFruit() &#123;        fruit.get();    &#125;&#125;/* 主程序测试 */public class MyTest &#123;    public static void main(String[] args) &#123;        UserService user = new UserServiceImpl();        user.getFruit(); // 输出 &quot;get a Apple&quot;     &#125;&#125;\n\n目前的控制权在业务层，每次用户需求改变时业务层也要跟着改变，即需要修改 UserServiceImpl 中的代码，如果工程量较大修改起来会很麻烦，而且修改代码容易对其它业务造成影响，可以考虑把控制权交给用户。\n修改业务层的代码实现控制权的转换，程序由主动创建对象变为被动接收对象：\n/* serviceImpl */public class UserServiceImpl implements UserService &#123;    private Fruit fruit;        // 利用 set 方法动态获取值的注入    public void setFruit(Fruit fruit) &#123;        this.fruit = fruit;    &#125;    public void getFruit() &#123;        this.fruit.get();    &#125;&#125;/* 主程序测试 */public class MyTest &#123;    public static void main(String[] args) &#123;        UserService user = new UserServiceImpl();        user.setFruit(new Apple());        //user.setFruit(new Banana());        user.getFruit();     &#125;&#125;\n\n在 spring.xml 中就是这么配置：\n&lt;bean id=&quot;apple&quot; class=&quot;com.example.dao.Apple&quot;/&gt;&lt;bean id=&quot;banana&quot; class=&quot;com.example.dao.Banana&quot;/&gt;&lt;bean id=&quot;userServiceImpl&quot; class=&quot;com.example.service.UserServiceImpl&quot;&gt;    &lt;property name=&quot;fruit&quot; ref=&quot;apple&quot; /&gt;&lt;/bean&gt;\n\n\n\n实现原理核⼼技术点：XML 解析 + 反射机制\n具体的思路：\n1、根据需求编写 XML ⽂件，配置需要创建的 bean。\n2、编写程序读取 XML ⽂件，获取 bean 相关信息，类、属性、id。\n3、根据第 2 步获取到的信息，结合反射机制动态创建对象，同时完成属性的赋值。\n4、将创建好的 bean 存⼊ Map 集合，设置 key - value 映射，key 就是 bean 中 id 值，value 就是 bean 对象。\n5、提供⽅法从 Map 中通过 id 获取到对应的 value。\n下面将自定义一个 MyClassPathXmlApplicationContext 类来实现。\n首先需要在 pom.xml 引入依赖解析 xml 文件：\n&lt;dependency&gt;    &lt;groupId&gt;dom4j&lt;/groupId&gt;    &lt;artifactId&gt;dom4j&lt;/artifactId&gt;    &lt;version&gt;1.6.1&lt;/version&gt;&lt;/dependency&gt;\n\n自定义 MyClassPathXmlApplicationContext 类（这里假设 bean 的属性仅为 int 或 String 类型）：\npublic class MyClassPathXmlApplicationContext implements ApplicationContext &#123;    private Map&lt;String, Object&gt; iocMap;    public MyClassPathXmlApplicationContext(String path) &#123;        iocMap = new HashMap&lt;&gt;();        parseXml(path);    &#125;    public void parseXml(String path)&#123;        SAXReader reader = new SAXReader();        try &#123;            Document document = reader.read(&quot;src/main/resources/&quot; + path);            Element rootElement = document.getRootElement();            Iterator&lt;Element&gt; elementIterator = rootElement.elementIterator();            while (elementIterator.hasNext()) &#123;                Element bean = elementIterator.next();                String beanID = bean.attributeValue(&quot;id&quot;);                String beanClassName = bean.attributeValue(&quot;class&quot;);                // 反射创建对象                Class myClass = Class.forName(beanClassName);                Constructor constructor = myClass.getConstructor();                Object object = constructor.newInstance();                // 给属性赋值                Iterator&lt;Element&gt; propertyIterator = bean.elementIterator();                while (propertyIterator.hasNext()) &#123;                    Element property = propertyIterator.next();                    String propertyName = property.attributeValue(&quot;name&quot;);                    String propertyValue = property.attributeValue(&quot;value&quot;);                    // 获取 setter 方法                    String methodName = &quot;set&quot; + propertyName.substring(0, 1).toUpperCase() + propertyName.substring(1);                    // 获取属性和方法                    Field field = myClass.getDeclaredField(propertyName);                    Method method = myClass.getMethod(methodName, field.getType());                    Object value = propertyValue;                    // 类型转换（这里假设 bean 的属性仅为 int 或 String 类型）                    switch (field.getType().getName())&#123;                        case &quot;java.lang.String&quot;:                            break;                        case &quot;int&quot;:                        case &quot;java.lang.Integer&quot;:                            value = Integer.parseInt(propertyValue);                            break;                    &#125;                    // 调用方法                    method.invoke(object, value);                &#125;                // 存入 Map                iocMap.put(beanID, object);            &#125;        &#125; catch (Exception e)&#123;            e.printStackTrace();        &#125;    &#125;        @Override    public Object getBean(String beanID) throws BeansException &#123;        return iocMap.get(beanID);    &#125;        // 省略其它需要重写的方法......&#125;\n\nspring.xml 配置：\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd &quot;&gt;    &lt;bean id=&quot;student&quot; class=&quot;com.kecho.entity.Student&quot;&gt;        &lt;property name=&quot;id&quot; value=&quot;1&quot;/&gt;        &lt;property name=&quot;name&quot; value=&quot;kecho&quot;/&gt;        &lt;property name=&quot;age&quot; value=&quot;18&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n测试类：\npublic static void main(String[] args  )&#123;    ApplicationContext context = new MyClassPathXmlApplicationContext(&quot;spring.xml&quot;);    Student student = (Student) context.getBean(&quot;student&quot;);    System.out.println(student);&#125;\n\n\n\n\nAOP","categories":["学习笔记","后端知识"],"tags":["Spring"]},{"title":"RuoYiPlus 扩展 JustAuth 支持 Welink 登录","url":"/posts/6bcd8e4.html","content":"RuoYiPlus 使用 JustAuth 进行三方登录，但是 JustAuth 不支持 Welink 登录，本文将介绍如何扩展 JustAuth 以支持 Welink 登录，并适配 RuoYiPlus 项目。\n\n\n\nJustAuth 文档\nRuoYiPlus 后端文档\nRuoYiPlus 前端文档\n第三方网站 Welink 登录流程免登录时，可以由前端生成 code 传递给后端，由后端去请求 Welink 接口返回用户信息给前端。也可以通过 OAuth 方式，由后端构造三方授权地址传递给前端跳转到指定地址，授权通过后再由 Welink 携带 code 返回到重定向地址，前端再将 code 传递给后端，由后端去请求 Welink 接口返回用户信息给前端。\n前台免登录我们先来了解一下 Welink 的免登录流程：\n\n前端生成 code 传递给后端\n后端使用 client_id 和 client_secret 请求三方得到 access_token\n后端使用 code 和 access_token 请求三方得到 userId\n后端使用 userId 和 access_token 请求三方得到用户详细信息\n\nPC 端生成 code 授权码有两种形式（移动端可参考 移动端获取授权登录码 | WeLink）：\n\n通过 Welink 打开轻应用\n通过扫码登录\n\n先说通过 Welink 打开轻应用：\n\n需要在 Welink 后台配置轻应用的 PC 端首页地址：\n 假定 PC 端打开链接为：https://www.example.com/index，需要在链接后面添加参数：code=$(code)，那么配置地址则为：https://www.example.com/index?code=$(code)\n\n从 URLSearchParams 获取 code 提交给后端向三方请求用户信息：\n &lt;script setup lang=&quot;ts&quot;&gt;const getWelinkLoginCode = async () =&gt; &#123;  const urlParams = new URLSearchParams(window.location.search);  const code = urlParams.get(&quot;code&quot;);  if (code) &#123;    // 发送请求将 code 传递给后端    const response = await loginWithCode(code);\t  &#125;&#125;onMounted(() =&gt; &#123;  getWelinkLoginCode();&#125;);&lt;/script&gt;\n\n再说扫码登录：\n\n前端引入 js 文件：\n &lt;script src=&quot;https://login.welink.huaweicloud.com/sso-proxy-front/public/qrcode/0.0.1/wlQrcodeLogin.js&quot;&gt;&lt;/script&gt;\n\n前端构造二维码：\n &lt;div id=&quot;welink-login-container&quot;&gt;&lt;/div&gt;&lt;script&gt;// 生成二维码const getWelinkLoginERCode = () =&gt; &#123;  const clientId = &quot;2025xxxxxxxxxxx1413&quot;;  const state = Date.now().toString();  const redirectUri  = &#x27;https://www.example.com/social-callback?source=welink&#x27;;  window.wlQrcodeLogin(&#123;    id: &quot;welink-login-container&quot;, // 这里需要你在自己的页面定义一个 HTML 标签并设置 id，例如 &lt;div id=&quot;welink-login-container&quot;&gt;&lt;/div&gt;，也可以使用 span    client_id: clientId,     response_type: &quot;code&quot;,     scope: &quot;snsapi_login&quot;,     state: state,     redirect_uri: redirectUri,    style: &quot;border:none;background-color:#FFFFFF;&quot;,    width : &quot;400&quot;,    height: &quot;300&quot;,    lang: &#x27;cn&#x27;,    self_redirect: false  &#125;);&#125;&lt;/script&gt;\n\n 注意：redirectUri 的域名或 IP 需要和 Welink 后台设置的 “应用管理后台” 地址保持一致，并且不能使用 localhost，否则可能导致二维码生成失败。\n\n从 MessageEvent 获取 code 提交给后端向三方请求用户信息：\n &lt;script&gt; const getWelinkLoginCode = (event) =&gt; &#123;  const origin = event.origin;  if(origin === &quot;https://login.welink.huaweicloud.com&quot;) &#123;    console.log(event)    const code = event.data as string;    console.log(code);    if(code) &#123;      // 发送请求将 code 传递给后端      const response = await loginWithCode(code);    &#125;  &#125;&#125; if (typeof window.addEventListener != &#x27;undefined&#x27;) &#123;     window.addEventListener(&#x27;message&#x27;, getWelinkLoginCode, false); &#125; else if (typeof window.attachEvent != &#x27;undefined&#x27;) &#123;     window.attachEvent(&#x27;onmessage&#x27;, getWelinkLoginCode); &#125;&lt;/script&gt;\n\n管理后台免登录上面说的都是由前台产生 code 传递给后台，然后后台拿 code 去请求三方获取信息。\n下面将介绍 Welink 中 OAuth 登录方式流程：\n\n前端点击按钮后向后端发送请求\n后端构造三方跳转地址并返回前端\n前端跳转指定三方跳转地址\n三方会判断用户是否登录三方，没有则跳转三方登录页，登录后三方会生成 code 并带参跳转到 redirect_uri 地址\n可以在前端判断用户是否是登录状态，请求后端对应的接口处理\n\nJustAuth 扩展流程根据  自定义第三方平台的OAuth | JustAuth 可以得知扩展步骤主要分为三步：\n\n在 application.yml 配置 justauth 中第三方平台的 client_id 和 client_secret 等信息\n创建一个类实现 AuthSource 接口\n创建一个类继承 AuthDefaultRequest 类，并重写 getAccessToken 和 getUserInfo 方法\n\nJustAuth 官方文档中例子的源码可见：AuthMyGitlabRequest.java | Github\n理解 RuoYiPlus 中三方登录流程\n结论：RuoYiPlus 中需要先绑定三方账号，才能使用三方登录。\n\n前端在 login.vue 登录页面或登录后 thirdParty.vue 绑定应用页面都会调用 /binding/&#123;source&#125; 接口。\n后端将创建 AuthRequest 调用 authorize 方法构造三方跳转地址 （会用到 yml 中配置的信息）并传递给前端（AuthController 中 authBinding 方法）。\n前端跳转到指定三方地址后由三方返回到指定的重定向地址 /social-callback（此路由对应前端 SocialCallback.vue 页面）。\n前端 SocialCallback.vue 中会判断是否是登录状态，如果已登录则请求 /social/callback 接口，未登录则请求 login 接口（AuthController 中 socialCallback 和 login 方法 ）。\nAuthController 中 login 方法中最关键的是 LoginVo loginVo = IAuthStrategy.login(body, client, grantType)，点进去看一下 IAuthStrategy.login 方法：\nstatic LoginVo login(String body, SysClientVo client, String grantType) &#123;    // 授权类型和客户端id    String beanName = grantType + BASE_NAME;    if (!SpringUtils.containsBean(beanName)) &#123;        throw new ServiceException(&quot;授权类型不正确!&quot;);    &#125;    IAuthStrategy instance = SpringUtils.getBean(beanName);    return instance.login(body, client);&#125;\n\n这里 grantType 是 “social”，BASE_NAME 就是 “AuthStrategy”，所以实际调用的是 socialAuthStrategy.login 方法。再看一下 SocialAuthStrategy 中 login 方法：\npublic LoginVo login(String body, SysClientVo client) &#123;    SocialLoginBody loginBody = JsonUtils.parseObject(body, SocialLoginBody.class);    ValidatorUtils.validate(loginBody);    AuthResponse&lt;AuthUser&gt; response = SocialUtils.loginAuth(        loginBody.getSource(), loginBody.getSocialCode(),        loginBody.getSocialState(), socialProperties);    if (!response.ok()) &#123;        throw new ServiceException(response.getMsg());    &#125;    AuthUser authUserData = response.getData();    /// 以下省略...&#125;\n\n可以看到就是通过 SocialUtils.loginAuth 方法来调用三方接口，拿到用户信息。再看一下 SocialUtils.loginAuth 方法：\npublic static AuthResponse&lt;AuthUser&gt; loginAuth(String source, String code, String state, SocialProperties socialProperties) throws AuthException &#123;    AuthRequest authRequest = getAuthRequest(source, socialProperties);    AuthCallback callback = new AuthCallback();    callback.setCode(code);    callback.setState(state);    return authRequest.login(callback);&#125;\n\n可以看到是先调用 getAuthRequest 获取到对应平台的 AuthRequest 类，然后调用其中的 login 方法。我们再看一下 getAuthRequest 方法：\npublic static AuthRequest getAuthRequest(String source, SocialProperties socialProperties) throws AuthException &#123;    SocialLoginConfigProperties obj = socialProperties.getType().get(source);    if (ObjectUtil.isNull(obj)) &#123;        throw new AuthException(&quot;不支持的第三方登录类型&quot;);    &#125;    AuthConfig.AuthConfigBuilder builder = AuthConfig.builder()        .clientId(obj.getClientId())        .clientSecret(obj.getClientSecret())        .redirectUri(obj.getRedirectUri())        .scopes(obj.getScopes());    return switch (source.toLowerCase()) &#123;        case &quot;dingtalk&quot; -&gt; new AuthDingTalkV2Request(builder.build(), STATE_CACHE);        case &quot;baidu&quot; -&gt; new AuthBaiduRequest(builder.build(), STATE_CACHE);            // ...             // 此处省略若干            // ...        case &quot;welink&quot; -&gt; new AuthWelinkRequest(builder.build(), STATE_CACHE);        default -&gt; throw new AuthException(&quot;未获取到有效的Auth配置&quot;);    &#125;;&#125;\n\n没错，socialProperties.getType() 返回的是 map 类型，就是用于读取 yml 配置文件中配置内容构造对应的 AuthRequest 类。\n所以总结一下：AuthController 中 login 方法就是执行对应平台的 AuthRequest 类中的 login 方法。\n本文中的 AuthWelinkRequest 之所以要重写基类 AuthDefaultRequest 中的 login 方法，是因为 Welink  获取用户信息的流程不太一样，需要先获取 userId 才能获取用户信息，再重复定义一遍 responseError 也是因为基类中的该方法是 private，子类无法调用。\n回到 SocialAuthStrategy 中 login 方法后面代码部分，获取到三方平台的用户信息后会去查询 sys_social 表，检查是否有此账号绑定记录，没有则则抛出异常提示需要先进行绑定。如果有记录则查询对应的系统用户 Id，然后通过 Id 获取系统用户信息，使用 SaToken 生成 token 进行登录。\nAuthController 中 socialCallback 方法则先对用户登录状态判断，只有登录状态才会调用 SocialUtils.loginAuth 方法，上面分析了这实际就是调用对应平台的 AuthRequest 类中的 login 方法获取三方用户信息。然后通过 loginService.socialRegister 方法去新增或修改绑定记录。\nRuoYiPlus 适配由于在扫码登录时，Welink 的认证需要向第三方传递前端传过来 code 参数，并且需要先获取 userId 才能获取用户信息，所以本文和官方的扩展流程有些许不同。\n后端改造application-dev.yml 增加 Welink 平台配置：\njustauth:  # 前端访问地址，不能使用 localhost  address: https://www.example.com:80  type:    welink:      client-id: 2025xxxxxxxxxxx1413      client-secret: xxxxxxxxxxxxx      redirect-uri: $&#123;justauth.address&#125;/social-callback?source=welink # 前端路由\n\nAuthWelinkSource.java 定义接口地址：\npublic enum AuthWelinkSource implements AuthSource &#123;    WELINK;    public String snsAuthorize() &#123;        return &quot;https://login.welink.huaweicloud.com/sso/oauth2/sns_authorize&quot;;    &#125;        @Override    public String authorize() &#123;        return &quot;https://login.welink.huaweicloud.com/sso/oauth2/authorize&quot;;    &#125;    @Override    public String accessToken() &#123;        return &quot;https://open.welink.huaweicloud.com/api/auth/v2/tickets&quot;;    &#125;    @Override    public String userInfo() &#123;        return &quot;https://open.welink.huaweicloud.com/api/contact/v2/user/detail&quot;;    &#125;    @Override    public Class&lt;? extends AuthDefaultRequest&gt; getTargetClass() &#123;        return AuthWelinkRequest.class;    &#125;    public String userId() &#123;        return &quot;https://open.welink.huaweicloud.com/api/auth/v2/userid&quot;;    &#125;&#125;\n\nAuthWelinkRequest.java 发送请求：\n相比较官方示例代码，注意改变了以下几点：：\n\n重写的 getUserInfo(AuthToken authToken) 方法啥也没写，因为用不到\n增加了 getUserInfoById(AuthToken authToken, AuthCallback authCallback) 方法，增加一个参数获取 code，即 authCallback.code\n增加了 getUserId 方法\n重载了 authorize 方法，分别用于扫码登录和绑定账号两个不同场景\n没有使用自带的 doGetXxxxxx 或 doPostXxxxxx 方法，而是使用封装的 OkHttp 库，封装代码将放在文章末尾。因为使用 doPostAuthorizationCode 请求 access_token 时返回内容一直提示：”clientId为空”，其实请求时是有传递 client_id 的，换了之后就成功了。我猜测是因为自带的 doPostXxxxxx 并没有把请求参数放在 body 里面而是以 ?client_id=xxx&amp;client_secret=xxx 这种方式拼接在 url 后面导致的\n重写了 login 方法 和 增加了 responseError 方法（这两个方法就是仿照基类 AuthDefaultRequest 中对应方法写的）。\n\n@Slf4jpublic class AuthWelinkRequest extends AuthDefaultRequest &#123;    public AuthWelinkRequest(AuthConfig config) &#123;        super(config, AuthWelinkSource.WELINK);    &#125;    public AuthWelinkRequest(AuthConfig config, AuthStateCache authStateCache) &#123;        super(config, AuthWelinkSource.WELINK, authStateCache);    &#125;    @Override    public AuthUser getUserInfo(AuthToken authToken) &#123;        return null;    &#125;    @Override    public AuthToken getAccessToken(AuthCallback authCallback) &#123;        // AuthCallback 这里用不到        Map&lt;String, String&gt; params = new HashMap&lt;&gt;();        params.put(&quot;client_id&quot;, this.config.getClientId());        params.put(&quot;client_secret&quot;, this.config.getClientSecret());        Map&lt;String, String&gt; headers = new HashMap&lt;&gt;();        headers.put(&quot;Content-Type&quot;, &quot;application/json;charset=UTF-8&quot;);        headers.put(&quot;x-wlk-gray&quot;, &quot;0&quot;);        JSONObject object = null;        try &#123;            String body = OkHttpUtil.post(UrlBuilder.fromBaseUrl(this.source.accessToken()).build(), JSON.toJSONString(params), MediaType.parse(&quot;application/json&quot;), headers);            object = JSONObject.parseObject(body);            log.info(&quot;welink get access token success, access token body:[&#123;&#125;]&quot;, body);        &#125; catch (Exception e) &#123;            log.error(&quot;get welink access token fail&quot;, e);        &#125;        AuthToken.AuthTokenBuilder builder = AuthToken.builder();        if(object != null &amp;&amp; this.checkResponse(object))&#123;            builder.accessToken(object.getString(&quot;access_token&quot;))                .expireIn(object.getInteger(&quot;expires_in&quot;));        &#125;        return builder.build();    &#125;    public AuthUser getUserInfoById(AuthToken authToken, AuthCallback authCallback) &#123;        String userId = this.getUserId(authToken, authCallback.getCode());        AuthUser.AuthUserBuilder builder = AuthUser.builder();        if(userId == null)&#123;            return builder.build();        &#125;        Map&lt;String, String&gt; params = new HashMap&lt;&gt;();        params.put(&quot;userId&quot;, userId);        Map&lt;String, String&gt; headers = new HashMap&lt;&gt;();        headers.put(&quot;x-wlk-Authorization&quot;, authToken.getAccessToken());        headers.put(&quot;Content-Type&quot;, &quot;application/json&quot;);        headers.put(&quot;Accept-Charset&quot;, &quot;UTF-8&quot;);        JSONObject object = null;        try &#123;            String body = OkHttpUtil.post(UrlBuilder.fromBaseUrl(AuthWelinkSource.WELINK.userInfo()).build(), JSON.toJSONString(params), MediaType.parse(&quot;application/json&quot;), headers);            object = JSONObject.parseObject(body);            log.info(&quot;welink get user info success, user info body:[&#123;&#125;]&quot;, body);        &#125; catch (Exception e) &#123;            log.error(&quot;get welink user info fail&quot;, e);        &#125;        if(object != null &amp;&amp; this.checkResponse(object))&#123;            AuthUserGender gender = switch (object.getString(&quot;sex&quot;)) &#123;                case &quot;F&quot; -&gt; AuthUserGender.FEMALE;                case &quot;M&quot; -&gt; AuthUserGender.MALE;                default -&gt; AuthUserGender.UNKNOWN;            &#125;;            builder.uuid(object.getString(&quot;userId&quot;))                .username(object.getString(&quot;employeeId&quot;))                .nickname(object.getString(&quot;userNameCn&quot;))                .avatar(object.getString(&quot;avatar&quot;))                .email(object.getString(&quot;userEmail&quot;))                .company(object.getString(&quot;mainDeptCode&quot;))                .gender(gender)                .token(authToken)                .source(source.toString())                .rawUserInfo(object);        &#125;        return builder.build();    &#125;    public String getUserId(AuthToken authToken, String code)&#123;        Map&lt;String, String&gt; params = new HashMap&lt;&gt;();        params.put(&quot;code&quot;, code);        Map&lt;String, String&gt; headers = new HashMap&lt;&gt;();        headers.put(&quot;x-wlk-Authorization&quot;, authToken.getAccessToken());        JSONObject object = null;        try &#123;            String body = OkHttpUtil.get(UrlBuilder.fromBaseUrl(AuthWelinkSource.WELINK.userId()).build(), headers, params);            object = JSONObject.parseObject(body);            log.info(&quot;welink get user id success, user id body:[&#123;&#125;]&quot;, body);        &#125; catch (Exception e) &#123;            log.error(&quot;get welink user id fail&quot;, e);        &#125;        if(object != null &amp;&amp; this.checkResponse(object))&#123;            return object.getString(&quot;userId&quot;);        &#125;        return null;    &#125;    public String authorize(String code, String state) &#123;        return UrlBuilder.fromBaseUrl(AuthWelinkSource.WELINK.snsAuthorize())            .queryParam(&quot;response_type&quot;, &quot;code&quot;)            .queryParam(&quot;client_id&quot;, this.config.getClientId())            .queryParam(&quot;redirect_uri&quot;, URLEncoder.encode(this.config.getRedirectUri(), StandardCharsets.UTF_8))            .queryParam(&quot;state&quot;, this.getRealState(state))            .queryParam(&quot;scope&quot;, &quot;snsapi_login&quot;)            .queryParam(&quot;code&quot;, code)            .build();    &#125;    @Override    public String authorize(String state) &#123;        return UrlBuilder.fromBaseUrl(AuthWelinkSource.WELINK.authorize())            .queryParam(&quot;response_type&quot;, &quot;code&quot;)            .queryParam(&quot;client_id&quot;, this.config.getClientId())            .queryParam(&quot;redirect_uri&quot;, URLEncoder.encode(this.config.getRedirectUri(), StandardCharsets.UTF_8))            .queryParam(&quot;state&quot;, this.getRealState(state))            .queryParam(&quot;scope&quot;, &quot;backendlogin&quot;)            .build();    &#125;    @Override    public AuthResponse&lt;AuthUser&gt; login(AuthCallback authCallback) &#123;        try &#123;            if (!this.config.isIgnoreCheckState()) &#123;                AuthChecker.checkState(authCallback.getState(), this.source, this.authStateCache);            &#125;            AuthToken authToken = this.getAccessToken(authCallback);            AuthUser user = this.getUserInfoById(authToken, authCallback);            return AuthResponse.&lt;AuthUser&gt;builder().code(AuthResponseStatus.SUCCESS.getCode()).data(user).build();        &#125; catch (Exception var4) &#123;            Log.error(&quot;Failed to login with oauth authorization.&quot;, var4);            return this.responseError(var4);        &#125;    &#125;    private boolean checkResponse(JSONObject object) &#123;        if(object == null) &#123;            log.error(&quot;response body is null, request fail！&quot;);            return false;        &#125;else if(!Objects.equals(object.getString(&quot;code&quot;), &quot;0&quot;))&#123;            log.error(&quot;response body message: &#123;&#125;&quot;, object.getString(&quot;message&quot;));            return false;        &#125;        return true;    &#125;    AuthResponse&lt;AuthUser&gt; responseError(Exception e) &#123;        int errorCode = AuthResponseStatus.FAILURE.getCode();        String errorMsg = e.getMessage();        if (e instanceof AuthException authException) &#123;            errorCode = authException.getErrorCode();            if (StringUtils.isNotEmpty(authException.getErrorMsg())) &#123;                errorMsg = authException.getErrorMsg();            &#125;        &#125;        return AuthResponse.&lt;AuthUser&gt;builder().code(errorCode).msg(errorMsg).build();    &#125;&#125;\n\nAuthController 类中 authBinding 方法新增 code 参数，并对 Welink 平台扫码登录时特殊处理：\n@GetMapping(&quot;/binding/&#123;source&#125;&quot;)public R&lt;String&gt; authBinding(@PathVariable(&quot;source&quot;) String source, @RequestParam(required = false) String code,                             @RequestParam String tenantId, @RequestParam String domain) &#123;    SocialLoginConfigProperties obj = socialProperties.getType().get(source);    if (ObjectUtil.isNull(obj)) &#123;        return R.fail(source + &quot;平台账号暂不支持&quot;);    &#125;    AuthRequest authRequest = SocialUtils.getAuthRequest(source, socialProperties);    Map&lt;String, String&gt; map = new HashMap&lt;&gt;();    map.put(&quot;tenantId&quot;, tenantId);    map.put(&quot;domain&quot;, domain);    map.put(&quot;state&quot;, AuthStateUtils.createState());    String authorizeUrl;    if(authRequest instanceof AuthWelinkRequest welinkRequest &amp;&amp; !StringUtils.isBlank(code))&#123;        // 仅 welink 扫码登录需要特殊处理，welink 绑定时同其它平台一样        authorizeUrl = welinkRequest.authorize(code, Base64.encode(JsonUtils.toJsonString(map), StandardCharsets.UTF_8));    &#125;else &#123;        authorizeUrl = authRequest.authorize(Base64.encode(JsonUtils.toJsonString(map), StandardCharsets.UTF_8));    &#125;    log.info(&quot;authorize url: &quot; + authorizeUrl);    return R.ok(&quot;操作成功&quot;, authorizeUrl);&#125;\n\nSocialUtils 类中 getAuthRequest 方法中增加 case：\npublic static AuthRequest getAuthRequest(String source, SocialProperties socialProperties) throws AuthException &#123;    // ...     // 此处省略若干    // ...    return switch (source.toLowerCase()) &#123;\t// ... \t// 此处省略若干\t// ...        case &quot;welink&quot; -&gt; new AuthWelinkRequest(builder.build(), STATE_CACHE);        default -&gt; throw new AuthException(&quot;未获取到有效的Auth配置&quot;);    &#125;;&#125;\n\n\n\n前端改造前端涉及到登录页和绑定应用页，需要改造 login.vue 和 thirdParty.vue 页面。\nauth.ts 中 authBinding 方法增加 code 参数：\n// 绑定账号export function authBinding(source: string, tenantId: string, code: string = &quot;&quot;) &#123;  return request(&#123;    url: &#x27;/auth/binding/&#x27; + source,    method: &#x27;get&#x27;,    params: &#123;      code: code,      tenantId: tenantId,      domain: window.location.host    &#125;  &#125;);&#125;\n\nindex.js 引入 js 文件\n&lt;script src=&quot;https://login.welink.huaweicloud.com/sso-proxy-front/public/qrcode/0.0.1/wlQrcodeLogin.js&quot;&gt;&lt;/script&gt;\n\nassets&#x2F;icons&#x2F;svg 放入 welink.svg 图标\n\nlang&#x2F;zh_CN.ts 和 en_US.ts 增加 login.social.welink 语言内容：\n// zh_CN.tslogin: &#123;      // 省略...    social: &#123;\t\twelink: &#x27;Welink 登录&#x27;,    &#125;&#125;    // en_US.tslogin: &#123;    // 省略...    social: &#123;\t\twelink: &#x27;Welink Login&#x27;,    &#125;&#125;\n\nlogin.vue 中使用 Element-Plus 中的 Dialog 组件来展示二维码，使用 @opened 实现打开弹窗时调用函数生成二维码。\n注意：redirectUri 的域名或 IP 需要和 Welink 后台设置的 “应用管理后台” 地址保持一致，并且不能使用 localhost，否则可能导致二维码生成失败。\n代码如下：\n&lt;template&gt;\t&lt;!-- Welink 扫码登录弹窗 --&gt;    &lt;el-dialog v-model=&quot;isWelinkLogin&quot;         :title=&quot;proxy.$t(&#x27;login.social.welink&#x27;)&quot;         @opened=&quot;getWelinkLoginERCode&quot;        width=&quot;500&quot; center align-center&gt;        &lt;div class=&quot;welink-login-dialog&quot;&gt;            &lt;div id=&quot;welink-login-container&quot;&gt;&lt;/div&gt;        &lt;/div&gt;    &lt;/el-dialog&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;// 是否 welink 登录const isWelinkLogin = ref(false);// 生成二维码const getWelinkLoginERCode = () =&gt; &#123;  const clientId = &quot;2025xxxxxxxxxxx1413&quot;;  const state = Date.now().toString();  const redirectUri  = &#x27;https://www.example.com/social-callback?source=welink&#x27;;  window.wlQrcodeLogin(&#123;    id: &quot;welink-login-container&quot;, // 这里需要你在自己的页面定义一个 HTML 标签并设置 id，例如 &lt;div id=&quot;welink-login-container&quot;&gt;&lt;/div&gt;，也可以使用 span    client_id: clientId,     response_type: &quot;code&quot;,     scope: &quot;snsapi_login&quot;,     state: state,     redirect_uri: redirectUri,    style: &quot;border:none;background-color:#FFFFFF;&quot;,    width : &quot;400&quot;,    height: &quot;300&quot;,    lang: &#x27;cn&#x27;,    self_redirect: false  &#125;);&#125;const getWelinkLoginCode = (event: MessageEvent) =&gt; &#123;  const origin = event.origin;  if(origin === &quot;https://login.welink.huaweicloud.com&quot;) &#123;    console.log(event)    const code = event.data as string;    console.log(code);    if(code) &#123;      // 发送请求将 code 传递给后端      doSocialLogin(&#x27;welink&#x27;, code)    &#125;  &#125;&#125;onMounted(() =&gt; &#123;  window.addEventListener(&quot;message&quot;, getWelinkLoginCode, false);&#125;);onBeforeUnmount(() =&gt; &#123;  window.removeEventListener(&quot;message&quot;, getWelinkLoginCode, false);&#125;)    &lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;.welink-login-dialog &#123;  display: flex;  justify-content: center;  align-items: center;  height: 100%;&#125;&lt;/style&gt;\n\nthirtyParty.vue 中在可绑定应用中增加 Welink：\n&lt;div id=&quot;authlist&quot; class=&quot;user-bind&quot;&gt;    &lt;a class=&quot;third-app&quot; href=&quot;#&quot; title=&quot;使用 Welink 账号授权登录&quot; @click=&quot;authUrl(&#x27;welink&#x27;)&quot;&gt;        &lt;div class=&quot;git-other-login-icon&quot;&gt;            &lt;svg-icon icon-class=&quot;welink&quot; /&gt;        &lt;/div&gt;        &lt;span class=&quot;app-name&quot;&gt;Welink&lt;/span&gt;    &lt;/a&gt;    &lt;!-- 省略其它列表 --&gt;&lt;/div&gt;\n\n\n\n附录OkHttp 封装Maven 引入：\n&lt;dependency&gt;    &lt;groupId&gt;com.squareup.okhttp3&lt;/groupId&gt;    &lt;artifactId&gt;okhttp&lt;/artifactId&gt;    &lt;version&gt;4.12.0&lt;/version&gt;&lt;/dependency&gt;\n\nOkHttpUtil 类：\npublic class OkHttpUtil &#123;    private static final OkHttpClient okHttpClient = new OkHttpClient();    public static String get(String url, Map&lt;String, String&gt; headers, Map&lt;String, String&gt; urlParams) throws IOException &#123;        String result = &quot;&quot;;        Request.Builder builder = new Request.Builder();        if (!StringUtils.hasText(url)) &#123;            return result;        &#125;        if (headers != null) &#123;            builder.headers(setHeaders(headers));        &#125;        if (urlParams != null) &#123;            builder.url(setUrlParams(url, urlParams));        &#125; else &#123;            builder.url(url);        &#125;        Request request = builder.build();        try(Response response = okHttpClient.newCall(request).execute())&#123;            if(response.body() != null)&#123;                result = response.body().string();            &#125;        &#125;        return result;    &#125;    public static String post(String url, String json, MediaType mediaType) throws IOException &#123;        RequestBody body = RequestBody.create(json, mediaType);        Request request = new Request.Builder()            .url(url)            .post(body)            .build();        try(Response response = okHttpClient.newCall(request).execute())&#123;            if(response.body() != null)&#123;                return response.body().string();            &#125;        &#125;        return &quot;&quot;;    &#125;\t// 新增：支持自定义 header 的 post 方法    public static String post(String url, String json, MediaType mediaType, Map&lt;String, String&gt; headers) throws IOException &#123;        RequestBody body = RequestBody.create(json, mediaType);        Request.Builder builder = new Request.Builder()            .url(url)            .post(body);        if (headers != null) &#123;            builder.headers(setHeaders(headers));        &#125;        Request request = builder.build();        try(Response response = okHttpClient.newCall(request).execute())&#123;            if(response.body() != null)&#123;                return response.body().string();            &#125;        &#125;        return &quot;&quot;;    &#125;    private static Headers setHeaders(Map&lt;String, String&gt; headersParams) &#123;        Headers headers = null;        okhttp3.Headers.Builder headersbuilder = new okhttp3.Headers.Builder();        if (headersParams != null) &#123;            Iterator&lt;String&gt; iterator = headersParams.keySet().iterator();            String key = &quot;&quot;;            while (iterator.hasNext()) &#123;                key = iterator.next();                headersbuilder.add(key, headersParams.get(key));            &#125;        &#125;        headers = headersbuilder.build();        return headers;    &#125;    private static String setUrlParams(String url, Map&lt;String, String&gt; mapParams) &#123;        StringBuilder strParams = new StringBuilder();        if (mapParams != null) &#123;            Iterator&lt;String&gt; iterator = mapParams.keySet().iterator();            for (Map.Entry&lt;String, String&gt; entry : mapParams.entrySet()) &#123;                if (!strParams.isEmpty()) &#123;                    strParams.append(&quot;&amp;&quot;);                &#125;                strParams.append(entry.getKey()).append(&quot;=&quot;).append(entry.getValue());            &#125;            if (url.endsWith(&quot;?&quot;)) &#123;                url += strParams;            &#125; else &#123;                url += &quot;?&quot; + strParams;            &#125;        &#125;        return url;    &#125;&#125;\n\n如何读取 yml 配置首先定义一个 SocialProperties 类，使用 @ConfigurationProperties 注解将 yml 下 justauth.* 的内容映射到这个类里面\n@Data@Component@ConfigurationProperties(prefix = &quot;justauth&quot;)public class SocialProperties &#123;    /**     * 授权类型     */    private Map&lt;String, SocialLoginConfigProperties&gt; type;&#125;\n\n然后定义一个配置类，使用 @EnableConfigurationProperties 注解来启用\n@AutoConfiguration@EnableConfigurationProperties(SocialProperties.class)public class SocialAutoConfiguration &#123;    @Bean    public AuthStateCache authStateCache() &#123;        return new AuthRedisStateCache();    &#125;&#125;","categories":["学习笔记"],"tags":["JustAuth","Welink"]},{"title":"Spring Boot 整合 Swagger 实现接口文档","url":"/posts/448c169.html","content":"本文介绍 OpenApi、Swagger、SpringFox 和 SpringDoc 之间的区别，以及 SpringBoot 如何整合并使用 Swagger 实现接口文档。\n\n名词解释\nOpenApi 是什么？\n\n解答： OpenApi 是一个用于描述、定义和共享 RESTful API 文档的规范。最新规范是 OpenAPI 3.0。\n\nSwagger 是什么？\n\n解答： Swagger 是一个用于设计和测试 RESTful API 的工具，是无关语言的。它提供了 API 描述、请求和响应示例、API 测试和文档生成等丰富的功能。最新版本是 Swagger 3，支持 OpenAPI 3.0 规范。\n\nSpringFox 是什么？\n\n解答： SpringFox 是 Spring 社区维护的一个项目（非官方），帮助使用者将 Swagger 2 集成到 Spring 中。\n地址：https://github.com/springfox/springfox\n\nSpringDoc 是什么？\n\n解答： SpringDoc 也是 Spring 社区维护的一个项目（非官方），帮助使用者将 Swagger 3 集成到 Spring 中。SpringDoc 支持 Swagger 页面、Oauth2 登录，相较于 SpringFox 而言，它的支撑时间更长，无疑是更好的选择。\n地址：https://springdoc.org/\n\n它们之间的关系\n\n解答： OpenAPI 定义了一种标准的格式来表示 API 文档，而 Swagger 是一个实现 OpenAPI 规范的工具，而 SpringFox 和 SpringDoc 都是将 Swagger 继承到 Spring 框架中方便使用。\n开始如何将 Swagger 集成到 SpringBoot 中？\n环境\nJDK 17\nSpringBoot 3\n\n在 SpringBoot 3 之前用的都是 SpringFox 来集成 Swagger 管理我们的 API 接口文档，但是 SpringFox 已经停止更新了，本次我们使用的是 SpringBoot 3 、JDK 17 的环境，推荐使用 SpringDoc 来整合 Swagger。\n添加依赖&lt;dependency&gt;    &lt;groupId&gt;org.springdoc&lt;/groupId&gt;    &lt;artifactId&gt;springdoc-openapi-starter-webmvc-ui&lt;/artifactId&gt;    &lt;version&gt;2.8.8&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springdoc&lt;/groupId&gt;    &lt;artifactId&gt;springdoc-openapi-starter-webmvc-api&lt;/artifactId&gt;    &lt;version&gt;2.8.8&lt;/version&gt;&lt;/dependency&gt;\n\n\n编写 Controller 类@RestControllerpublic class HelloController &#123;     @RequestMapping(&quot;/hello&quot;)    public String hello()&#123;        return &quot;hello&quot;;    &#125;&#125;\n\n访问接口页面浏览器直接输入：http://localhost:8080/swagger-ui/index.html 回车即可看到下面界面：\n\n配置在 application.yml 中可以自定义 api-docs 和 swagger-ui 的访问路径，扫描的指定包等等。\nspringdoc:  api-docs:    path: /v3/api-docs    enabled: false # 关闭接口文档，可针对 application-dev.yml / application-test 进行不同配置  swagger-ui:    path: /swagger-ui.html  packages-to-scan: com.example.swaggerdemo.common.controller # 只显示 common 包下的接口\n\n可以通过配置类来自定义 swagger-ui 页面信息：\n@OpenAPIDefinition(        // 不同环境的服务器地址        servers = &#123;                @Server(description = &quot;开发环境服务器&quot;, url = &quot;http://localhost:8080&quot;),                @Server(description = &quot;测试环境服务器&quot;, url = &quot;https://test.xiezhr.com&quot;)        &#125;,        // 配置外部文档地址        externalDocs = @ExternalDocumentation(                description = &quot;项目编译部署说明&quot;,                url = &quot;http://localhost:8080/deplay/readme.md&quot;        )) @Configurationpublic class SpringDocConfig &#123;     @Bean    public OpenAPI openAPI() &#123;        return new OpenAPI()                // 配置接口文档基本信息                .info(this.getApiInfo())                ;    &#125;     private Info getApiInfo() &#123;        return new Info()                 // 配置文档标题                .title(&quot;SpringBoot3集成Swagger3&quot;)                // 配置文档描述                .description(&quot;SpringBoot3集成Swagger3示例文档&quot;)                // 配置作者信息                .contact(new Contact().name(&quot;程序员小凡&quot;).url(&quot;https://www.xiezhrspace.cn&quot;).email(&quot;1666397814@163.com&quot;))                // 配置License许可证信息                .license(new License().name(&quot;Apache 2.0&quot;).url(&quot;https://www.xiezhrspace.cn&quot;))                //                .summary(&quot;SpringBoot3集成Swagger3示例文档aaa&quot;)                .termsOfService(&quot;https://www.xiezhrspace.cn&quot;)                 // 配置版本号                .version(&quot;2.0&quot;);    &#125;    // 对接口进行分组    @Bean(&quot;commonGroupApi&quot;)    public GroupedOpenApi webGroupApi() &#123;        return GroupedOpenApi.builder().group(&quot;common通用模块组&quot;)            .pathsToMatch(&quot;/common/**&quot;)            .build();    &#125;     @Bean(&quot;adminGroupApi&quot;)    public GroupedOpenApi adminGroupApi() &#123;        return GroupedOpenApi.builder().group(&quot;admin模块组&quot;)            .pathsToMatch(&quot;/admin/**&quot;)            .build();    &#125;&#125;\n\n\n\n注解使用Controller 类① @Tag 注解，用于类上。\n\nname: 名称\ndescription: 接口描述信息\n\n② @Operation 注解，用在方法上。\n\nsummary：方法概要，方法的一个简单介绍，建议 120 个字符内\ndescription：方法描述，一般是很长的内容\nhidden：是否隐藏\n\n③@Parameter 注解，用在方法参数上。\n\nname：指定的参数名\nin：参数位置，可选 query、header、path 或 cookie，默认为空，表示忽略\ndescription：参数描述\nrequired：是否必填，默认为 false\n\n④ @ApiResponse 注解，用于说明一个响应信息，用在 @ApiResponses 中。\n\nresponseCode：HTTP 响应码\ndescription：描述\n\n@RestController@RequestMapping(&quot;/common&quot;)@Tag(name = &quot;公共接口&quot;, description = &quot;公共接口&quot;)public class CommonController &#123;     @Autowired    private IUserService userService;    @GetMapping(&quot;/hello&quot;)   @Operation(summary = &quot;hello接口&quot;, description = &quot;hello接口描述&quot;, hidden = true)    public String hello()&#123;        return &quot;hello&quot;;    &#125;     @GetMapping(&quot;/hi&quot;)    @Operation(summary = &quot;hi接口&quot;, description = &quot;hi接口描述&quot;)    public String Hi()&#123;        return &quot;Hi 程序员小凡&quot;;    &#125;     @GetMapping(&quot;/user/&#123;id&#125;&quot;)    @Operation(summary = &quot;获取用户信息&quot;, description = &quot;根据用户ID获取用户信息&quot;)    @ApiResponses(value =&#123;            @ApiResponse(responseCode = &quot;200&quot;, description = &quot;请求成功&quot;),            @ApiResponse(responseCode = &quot;404&quot;, description = &quot;用户不存在&quot;)    &#125;)    public User getUser( @Parameter(name = &quot;id&quot;, in = ParameterIn.PATH, description = &quot;用户ID&quot;, required = true) @PathVariable(&quot;id&quot;) Integer id)&#123;        User user = userService.getUserById(id);        return user;    &#125;&#125;\n\n\n⑤@RequestHeader 注解。\n很多时候我们接口都需要认证之后才能访问，这时候我们就需要接口调用的时候携带着 token 信息，我们通过 @RequestHeader 注解，获取请求头中 token 信息。\n@GetMapping(&quot;/index&quot;)public String  admin(@RequestHeader (&quot;token&quot;) String token)&#123;\tSystem.out.println(&quot;token&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot; + token);    //token 验证    //.....各种业务逻辑    return &quot;admin&quot;;&#125;\n\n\n实体类@Schema 注解，用于描述数据对象信息或数据对象属性，用在类或类属性上。\n\nname: 属性名称\ndescription: 属性描述\nrequired: 是否必须\nminLength: 字符最小长度\nmaxLength: 字符最大长度\n\n@Data@Schema(description = &quot;用户实体类&quot;, name = &quot;User&quot;)public class User &#123;    @Schema(description = &quot;用户名&quot;, name = &quot;name&quot;, minLength = 6, maxLength = 20, required = true)    private String name;    @Schema(description = &quot;年龄&quot;, name = &quot;age&quot;, required = true, minimum = &quot;1&quot;, maximum = &quot;100&quot;)    private Integer age;    @Schema(description = &quot;邮箱&quot;, name = &quot;email&quot;, required = true)    private String email;    @Schema(description = &quot;地址&quot;, name = &quot;address&quot;)    private String address;&#125;\n\n\n","categories":["学习笔记","后端知识"],"tags":["Spring Boot","Swagger"]},{"title":"使用 Snail Job 定时任务同步 Welink 部门和用户信息","url":"/posts/a7ea8c76.html","content":"本文将以同步 Welink 部门和用户为例，介绍如何使用 Snail Job 创建定时任务并适配 RuoYiPlus 项目。\n\n\n在上文中实现了 Welink 的绑定与扫码登录功能，但是项目一开始是没有用户的，于是就有了本文，通过定时任务来获取 Welink 部门和用户信息构造系统部门和用户，并进行绑定。\n如何使用 Snail Job 创建定时任务并启动可参考：snail-job集群定时任务 | 掘金\nSnail Job  文档\n编写任务类CreateDeptAndUserFromWelinkJob.java 中使用 @JobExecutor 注解给任务命名，在后台创建任务时就不需要全限定类名，需要编写 jobExecute 方法来完成实际操作：\n@Slf4j@RequiredArgsConstructor@Component@JobExecutor(name = &quot;createDeptAndUserFromWelinkJob&quot;)public class CreateDeptAndUserFromWelinkJob &#123;    private final SocialProperties socialProperties;    private final ISysDeptService deptService;    private final ISysUserService userService;    private final ISysSocialService socialService;    private final ISysTenantService tenantService;    private List&lt;SysDeptBo&gt; deptBoList; // 部门列表    private final List&lt;SysUserBo&gt; userBoList = new ArrayList&lt;&gt;(); // 用户列表    private final String SOURCE = &quot;welink&quot;;    private static String accessToken;    public void getAccessToken()&#123;        SocialLoginConfigProperties obj = socialProperties.getType().get(SOURCE);        if (ObjectUtil.isNull(obj)) &#123;            SnailJobLog.REMOTE.error(&quot;not find &#123;&#125; application profile&quot;, SOURCE);            return;        &#125;        AuthRequest authRequest = SocialUtils.getAuthRequest(SOURCE, socialProperties);        AuthToken authToken = authRequest.getAccessToken(new AuthCallback());        accessToken = authToken.getAccessToken();    &#125;    private boolean getDeptList(String deptRootCode) &#123;        JSONArray allDeptJsonArray = new JSONArray();        final int pageSize = 50; // 最大 100        int pageNo = 1;        boolean hasMore = false;        getAccessToken();        if( StringUtils.isEmpty(accessToken)) &#123;            SnailJobLog.REMOTE.error(&quot;&#123;&#125; get access token fail&quot;, SOURCE);            return false;        &#125;        do &#123;            Map&lt;String, String&gt; headers = new HashMap&lt;&gt;();            headers.put(&quot;Content-Type&quot;, &quot;application/json;charset=UTF-8&quot;);            headers.put(&quot;x-wlk-gray&quot;, &quot;0&quot;);            headers.put(&quot;x-wlk-Authorization&quot;, accessToken);            Map&lt;String, String&gt; params = new HashMap&lt;&gt;();            params.put(&quot;deptCode&quot;, deptRootCode);            params.put(&quot;recursiveflag&quot;, &quot;1&quot;); // 递归查询子部门            params.put(&quot;offset&quot;, String.valueOf(pageNo));            params.put(&quot;limit&quot;, String.valueOf(pageSize));            try &#123;                String body = OkHttpUtil.get(UrlBuilder.fromBaseUrl(AuthWelinkSource.WELINK.deptList()).build(), headers, params);                JSONObject object = JSONObject.parseObject(body);                log.info(&quot;get dept list body: &#123;&#125;&quot;, object);                if(this.checkResponse(object))&#123;                    hasMore = object.getInteger(&quot;totalCount&quot;) &gt; pageNo * pageSize;                    pageNo++;                    JSONArray deptArray = object.getJSONArray(&quot;departmentInfo&quot;);                    allDeptJsonArray.addAll(deptArray);                &#125;else&#123;                    SnailJobLog.REMOTE.error(&quot;&#123;&#125; get dept list fail, pageNo: &#123;&#125;&quot;, SOURCE, pageNo);                    // 部分出错，如分页查询时失败                    return false;                &#125;            &#125; catch (Exception e) &#123;                SnailJobLog.REMOTE.error(&quot;&#123;&#125; get dept list fail, &#123;&#125;&quot;, SOURCE, e.getMessage());                return false;            &#125;        &#125; while (hasMore);        if(!allDeptJsonArray.isEmpty())&#123;            List&lt;JSONObject&gt; deptListJson = JSONArray.parseArray(allDeptJsonArray.toJSONString(), JSONObject.class);            // 将 JSONObject 转换为 SysDeptBo            deptBoList = deptListJson.stream().map(json -&gt; &#123;                SysDeptBo bo = new SysDeptBo();                bo.setDeptId(json.getLong(&quot;deptCode&quot;));                bo.setDeptName(json.getString(&quot;deptNameCn&quot;));                bo.setParentId(json.getLong(&quot;fatherCode&quot;));                bo.setDeptCategory(SOURCE);                bo.setOrderNum(json.getInteger(&quot;orderNo&quot;));                return bo;            &#125;).collect(Collectors.toList());            // 手动创建根部门            SysDeptBo root = new SysDeptBo();            root.setDeptId(Convert.toLong(deptRootCode));            root.setOrderNum(0);            root.setDeptName(&quot;xxxxxx有限公司&quot;);            root.setParentId(0L);            root.setDeptCategory(SOURCE);            deptBoList.add(root);        &#125;        return true;    &#125;    private boolean getUserListByDeptId(String deptId)&#123;        if(StringUtils.isEmpty(accessToken)) &#123;            SnailJobLog.REMOTE.error(&quot;&#123;&#125; get access token fail&quot;, SOURCE);            return false;        &#125;        JSONArray userJsonArray = new JSONArray();        final int pageSize = 50; // 最大 50        int pageNo = 1;        boolean hasMore = false;        do &#123;            Map&lt;String, String&gt; headers = new HashMap&lt;&gt;();            headers.put(&quot;Content-Type&quot;, &quot;application/json;charset=UTF-8&quot;);            headers.put(&quot;x-wlk-gray&quot;, &quot;0&quot;);            headers.put(&quot;x-wlk-Authorization&quot;, accessToken);            Map&lt;String, String&gt; params = new HashMap&lt;&gt;();            params.put(&quot;deptCode&quot;, deptId);            params.put(&quot;pageNo&quot;, String.valueOf(pageNo));            params.put(&quot;pageSize&quot;, String.valueOf(pageSize));            try &#123;                String body = OkHttpUtil.get(UrlBuilder.fromBaseUrl(AuthWelinkSource.WELINK.userList()).build(), headers, params);                JSONObject object = JSONObject.parseObject(body);                log.info(&quot;get user list body: &#123;&#125;&quot;, object);                if(this.checkResponse(object))&#123;                    hasMore = object.getInteger(&quot;hasMore&quot;) == 0; // 0 表示还有下一页                    pageNo++;                    JSONArray userArray = object.getJSONArray(&quot;data&quot;);                    userJsonArray.addAll(userArray);                &#125;else&#123;                    SnailJobLog.REMOTE.error(&quot;&#123;&#125; get user list fail。deptId: &#123;&#125;, pageNo: &#123;&#125;&quot;, SOURCE, deptId, pageNo);                    // 部分出错（如某部门没有用户）或某个分页查询时失败                    return false;                &#125;            &#125; catch (Exception e) &#123;                SnailJobLog.REMOTE.error(&quot;&#123;&#125; get user list fail, &#123;&#125;&quot;, SOURCE, e.getMessage());                return false;            &#125;        &#125; while(hasMore);        if(!userJsonArray.isEmpty())&#123;            List&lt;JSONObject&gt; userListJson = JSONArray.parseArray(userJsonArray.toJSONString(), JSONObject.class);            List&lt;SysUserBo&gt; userBoListOneDept = userListJson.stream().map(json -&gt; &#123;                SysUserBo bo = new SysUserBo();                Map&lt;String, Object&gt; remark = new HashMap&lt;&gt;();                remark.put(&quot;welinkId&quot;, json.getString(&quot;userId&quot;));                remark.put(&quot;avatar&quot;, json.getString(&quot;avatar&quot;)); // welink avatar 为链接， 系统 avatar 为 bigint                bo.setRemark(new JSONObject(remark).toJSONString()); // welink 用户id 为字符串而系统表为 long，保存用于更新 sys_social 表                bo.setDeptId(Convert.toLong(json.get(&quot;mainDeptCode&quot;)));                bo.setUserName(json.getString(&quot;employeeId&quot;));                bo.setNickName(json.getString(&quot;userNameCn&quot;));                bo.setStatus(&quot;3&quot;.equals(json.getString(&quot;userStatus&quot;)) ? &quot;0&quot; : &quot;1&quot;); // 0 正常 1 停用                bo.setPhonenumber(json.getString(&quot;mobileNumber&quot;).replaceFirst(&quot;^\\\\+\\\\d+-&quot;, &quot;&quot;)); // 去除 &#x27;+86-&#x27; 或 &#x27;+1-&#x27; 等                String rawSex = json.getString(&quot;sex&quot;);                bo.setSex(&quot;M&quot;.equalsIgnoreCase(rawSex) ? &quot;0&quot; : (&quot;F&quot;.equalsIgnoreCase(rawSex) ? &quot;1&quot; : &quot;2&quot;)); // &#x27;M&#x27; -&gt; &#x27;0&#x27; ; &#x27;F&#x27; -&gt; &#x27;1&#x27;; else -&gt; &#x27;2&#x27;                bo.setEmail(json.getString(&quot;userEmail&quot;));                bo.setPassword(BCrypt.hashpw(&quot;Cd123456$&quot;));                return bo;            &#125;).toList();            // 过滤用户名不为空或空白字符            userBoListOneDept = userBoListOneDept.stream().filter(bo -&gt; !StringUtils.isBlank(bo.getUserName())).toList();            userBoList.addAll(userBoListOneDept);        &#125;        return true;    &#125;    private boolean createSysDept(String deptRootCode) &#123;        if (StringUtils.isBlank(deptRootCode)) &#123;            SnailJobLog.REMOTE.error(&quot;&#123;&#125; create dept list fail, deptRootCode is null or blank string&quot;, SOURCE);            return false;        &#125;        if (deptBoList.isEmpty()) &#123;            SnailJobLog.REMOTE.error(&quot;&#123;&#125; create dept list fail, dept list is empty&quot;, SOURCE);            return false;        &#125;        boolean flag;        try &#123;            flag = deptService.batchInsertOrUpdateDept(deptBoList);        &#125; catch (Exception e) &#123;            SnailJobLog.REMOTE.error(&quot;&#123;&#125; create dept list fail, &#123;&#125;&quot;, SOURCE, e.getMessage());            return false;        &#125;        return flag;    &#125;    private boolean createUser()&#123;        if (userBoList.isEmpty()) &#123;            SnailJobLog.REMOTE.error(&quot;&#123;&#125; create user list fail, user list is empty&quot;, SOURCE);            return false;        &#125;        DataPermissionHelper.enableIgnore(); // 忽略数据权限        boolean flag;        try &#123;            flag = userService.batchInsertOrUpdateUserByUserName(userBoList); // username email phone 一定唯一，插入不用校验        &#125; catch (Exception e) &#123;            SnailJobLog.REMOTE.error(&quot;&#123;&#125; create user list fail, &#123;&#125;&quot;, SOURCE, e.getMessage());            return false;        &#125;        return flag;    &#125;    private boolean bindWelink()&#123;        if(!createUser())&#123;            return false;        &#125;        SnailJobLog.REMOTE.info(&quot;create &#123;&#125; user success! userCount: &#123;&#125;&quot;, SOURCE, userBoList.size());        // welink 绑定信息更新        boolean bindFlag = true;        for(SysUserBo bo: userBoList)&#123;            try&#123;                JSONObject object = JSON.parseObject(bo.getRemark());                if(Objects.nonNull(object) &amp;&amp; object.containsKey(&quot;welinkId&quot;)) &#123;                    String welinkId = object.getString(&quot;welinkId&quot;);                    String authId = SOURCE + welinkId;                    SysSocialBo socialBo = new SysSocialBo();                    socialBo.setUserId(bo.getUserId());                    socialBo.setAuthId(authId);                    socialBo.setOpenId(welinkId);                    socialBo.setSource(SOURCE);                    socialBo.setUserName(bo.getUserName());                    socialBo.setNickName(bo.getNickName());                    socialBo.setEmail(bo.getEmail());                    socialBo.setAccessToken(accessToken);                    if (object.containsKey(&quot;avatar&quot;)) &#123;                        socialBo.setAvatar(object.getString(&quot;avatar&quot;));                    &#125;                    // 查询是否已经绑定用户                    SysSocialBo params = new SysSocialBo();                    params.setUserId(bo.getUserId());                    params.setSource(SOURCE);                    List&lt;SysSocialVo&gt; socialList = socialService.queryList(params);                    boolean success;                    if (socialList.isEmpty()) &#123;                        success = socialService.insertByBo(socialBo);                    &#125; else &#123;                        socialBo.setId(socialList.getFirst().getId());                        // 通过 id 更新                        // bindFlag =  socialService.updateByBo(socialBo);  // 不能这么写，如果新值和旧值一样，返回的是 false                        socialService.updateByBo(socialBo);                        List&lt;SysSocialVo&gt; checkList = socialService.selectByAuthId(socialBo.getAuthId());                        success = CollUtil.isNotEmpty(checkList);                    &#125;                    if(!success) &#123;                        bindFlag = false;                        break;                    &#125;                &#125;            &#125; catch (JSONException e)&#123;                // json 解析出错，自动进入下一个循环            &#125;            catch (Exception e)&#123;                bindFlag = false; // 数据库报错                break;            &#125;        &#125;        return bindFlag;    &#125;    public ExecuteResult jobExecute(JobArgs jobArgs) &#123;        JSONObject object;        try &#123;            object = JSON.parseObject(jobArgs.getJobParams().toString());        &#125;catch (JSONException e)&#123;            return ExecuteResult.failure(&quot;JSON parsing error in JobParams&quot;);        &#125;        String tenantId = object.getString(&quot;tenantId&quot;);        String rootDeptId = object.getString(&quot;rootDeptId&quot;);        SnailJobLog.REMOTE.info(&quot;租户：&#123;&#125;, 根部门ID：&#123;&#125;&quot;, tenantId, rootDeptId);        if(StringUtils.isBlank(tenantId))&#123;            return ExecuteResult.failure(&quot;tenantId is blank&quot;);        &#125;        if(StringUtils.isBlank(rootDeptId))&#123;            return ExecuteResult.failure(&quot;rootDeptId is blank&quot;);        &#125;        SysTenantVo tenant = tenantService.queryByTenantId(tenantId);        if(ObjectUtil.isNull(tenant))&#123;            return ExecuteResult.failure(&quot;tenantId is not exist&quot;);        &#125;        // 设置所属租户        TenantHelper.setDynamic(tenantId);        //创建部门        boolean getDeptFlag = getDeptList(rootDeptId);        if(getDeptFlag)&#123;            SnailJobLog.REMOTE.info(&quot;get &#123;&#125; dept list success!&quot;, SOURCE);            boolean insertDeptFlag = createSysDept(rootDeptId);            if(insertDeptFlag)&#123;                SnailJobLog.REMOTE.info(&quot;create &#123;&#125; dept success! deptCount: &#123;&#125;&quot;, SOURCE, deptBoList.size());            &#125;else&#123;                return ExecuteResult.failure(&quot;create &#123;&#125; dept fail&quot;, SOURCE);            &#125;        &#125;else&#123;            return ExecuteResult.failure(&quot;get &#123;&#125; dept list fail&quot;, SOURCE );        &#125;        // 创建用户并绑定        boolean getUserFlag = true;        for(SysDeptBo deptBo: deptBoList)&#123;            String deptCode = deptBo.getDeptId().toString();            boolean getUserOneDeptFlag = getUserListByDeptId(deptCode); // 循环获取每个部门的所有用户            if(!getUserOneDeptFlag)&#123;                getUserFlag = false;                break; // 某一个部门出错则终止            &#125;        &#125;        if(getUserFlag)&#123;            SnailJobLog.REMOTE.info(&quot;get &#123;&#125; user list success!&quot;, SOURCE);            boolean bindFlag = bindWelink();            if(bindFlag)&#123;                SnailJobLog.REMOTE.info(&quot;bind &#123;&#125; user success!&quot;, SOURCE);            &#125;else&#123;                return ExecuteResult.failure(&quot;bind &#123;&#125; user fail&quot;, SOURCE);            &#125;        &#125;else&#123;            return ExecuteResult.failure(&quot;get &#123;&#125; user list fail&quot;, SOURCE);        &#125;        return ExecuteResult.success(&quot;任务成功&quot; );    &#125;    private boolean checkResponse(JSONObject object) &#123;        if(Objects.isNull(object)) &#123;            log.error(&quot;response body is null, request fail！&quot;);            return false;        &#125;else if(!Objects.equals(object.getString(&quot;code&quot;), &quot;0&quot;))&#123;            log.error(&quot;response body message: &#123;&#125;&quot;, object.getString(&quot;message&quot;));            return false;        &#125;        return true;    &#125;&#125;\n\n其中发送 Http 请求的封装代码参考上文附录\nService 类中方法扩充任务类中调用的 deptService.batchInsertOrUpdateDept 和 userService.batchInsertOrUpdateUserByUserName 方法是为了批量创建或更新部门和用户，但是 RuoYiPlus 中没有，需要自己实现。\nSysDeptServiceImpl.java 新增：\n/** * 批量新增或更新部门信息 * * @param list:  部门信息列表 * @return boolean 是否成功 */@Overridepublic boolean batchInsertOrUpdateDept(List&lt;SysDeptBo&gt; list) &#123;    if (list.isEmpty()) &#123;        return false;    &#125;    // 将 bo 转换为 sysDept, 暂不构建 ancestors    List&lt;SysDept&gt; sysDeptList = MapstructUtils.convert(list, SysDept.class);    if (Objects.isNull(sysDeptList))&#123;        return false;    &#125;    // 构建 Map 快速查找    Map&lt;Long, SysDept&gt; deptMap = sysDeptList.stream().collect(Collectors.toMap(SysDept::getDeptId, d -&gt; d));    sysDeptList.forEach(d -&gt; &#123;        d.setAncestors(buildAncestors(d, deptMap));    &#125;);    return baseMapper.insertOrUpdateBatch(sysDeptList);&#125;// 构造祖先部门列表private String buildAncestors(SysDept dept, Map&lt;Long, SysDept&gt; deptMap) &#123;    List&lt;Long&gt; ancestors = new ArrayList&lt;&gt;();    Long parentId = dept.getParentId();    while(ObjectUtil.isNotNull(parentId) &amp;&amp; parentId != 0) &#123;        ancestors.add(parentId);        SysDept parent = deptMap.get(parentId);        if(ObjectUtil.isNotNull(parent)) &#123;            parentId = parent.getParentId();        &#125; else &#123;            break; // 没有找到上级        &#125;    &#125;    Collections.reverse(ancestors); // 倒序，从顶级到父级    return ancestors.stream().map(String::valueOf).collect(Collectors.joining(StringUtils.SEPARATOR));&#125;\n\nSysUserServiceImpl.java 新增：\n/** * 批量插入或更新用户 * * @param list:  用户信息列表 * @return boolean 是否成功 */@Override@Transactional(rollbackFor = Exception.class)public boolean batchInsertOrUpdateUserByUserName(List&lt;SysUserBo&gt; list) &#123;    if (list.isEmpty()) &#123;        return false;    &#125;    // 将 bo 转换为 sysUser    List&lt;SysUser&gt; sysUserList = MapstructUtils.convert(list, SysUser.class);    if (sysUserList == null)&#123;        return false;    &#125;    // 批量插入或更新 （根据 userName 判断是插入还是更新，没有一定是插入）    // 仅单个租户中 userName 唯一    // 此处不校验 userName, email, phone 唯一性，由函数调用方自行处理    for(SysUser sysUser : sysUserList)&#123;        int rows = baseMapper.update(sysUser, new LambdaQueryWrapper&lt;SysUser&gt;().eq(SysUser::getUserName, sysUser.getUserName()));        if( rows == 0)&#123; // 未更新说明不存在            // 如果是插入，会自动回填 sysUser.userId            baseMapper.insert(sysUser);        &#125;else &#123;            // 如果是更新，需要手动查询            SysUser dbUser = baseMapper.selectOne(new LambdaQueryWrapper&lt;SysUser&gt;().eq(SysUser::getUserName, sysUser.getUserName()));            if(dbUser != null)&#123;                sysUser.setUserId(dbUser.getUserId());            &#125;        &#125;    &#125;    // 回填生成的 userid 更新其它表    IntStream.range(0, sysUserList.size()).forEach(i -&gt; &#123;        SysUser sysUser = sysUserList.get(i);        list.get(i).setUserId(sysUser.getUserId());    &#125;);    return true;&#125;\n\n不要忘了在对应抽象类中定义  batchInsertOrUpdateDept 和 batchInsertOrUpdateUserByUserName 方法\n后台创建任务下图中表示每月 1 日的凌晨 1 点执行一次任务，既支持 Cron 表达式也支持固定时间间隔执行。\n\n","categories":["学习笔记"],"tags":["Welink","Snail Job"]},{"title":"出栈顺序个数之卡特兰数","url":"/posts/6fd3c141.html","content":"在数据结构中有个问题：n 个元素进栈，共有多少种出栈顺序？\n\n\n答案：\n分析可以利用动态规划里面的子问题来进行推导。\n把 n 个元素的出栈顺序个数的记为 f(n)：\n\n当 n = 1 时，假设元素是 a，那么出栈顺序只有 ( a )，则 f(1) = 1\n当 n = 2 时，假设元素是 a b，那么出栈顺序有 ( a b ) ( b a )，则 f(2) = 2\n当 n = 3 时，假设元素是 a b c，那么出栈顺序有 ( a b c ) ( a c b ) ( b a c ) ( b c a ) ( c b a )，则 f(3) = 5\n\n当 n = 4 时, 假设元素是 a b c d，那么：元素 a 结果只可能出现在 1 号位置，2 号位置，3 号位置和 4 号位置。\n分析：\n\n如果元素 a 在 1 号位置，那么只可能 a 先进栈且马上出栈，此时还剩 3 个元素等待操作，就是子问题 f(3)\n\n如果元素 a 在 2 号位置，那么一定有 1 个元素比 a 先出栈（只能是 b ），即有 f(1) 种可能顺序。一定有 2 个元素比 a 后出栈，即有 f(2) 种可能顺序，根据乘法原理一共的顺序个数为 f(1) * f(2)\n\n如果元素 a 在 3 号位置，那么一定有 2 个元素比 a 先出栈，即有 f(2) 种可能顺序。一定有 1 个元素比 a 后出栈（只能是 d ），即有 f(1) 种可能顺序，根据乘法原理一共的顺序个数为 f(2) * f(1)\n\n如果元素 a 在 4 号位置，那么在 a 最后出栈前已经有 3 个元素进行了入栈出栈操作，就是子问题 f(3)\n\n\n结合所有情况，即 \n我们定义 。于是可以重新写为：\n推广到 n，于是我们可以得到：\n这就是卡特兰数的递推公式：且\n\n习题：元素 ABCDE 依次入栈，则以下（）是不可能的出栈次序。\nA、ABCDE\nB、EDCBA\nC、BADCE\nD、DBCAE\n答案：D\n解析：看 A 的位置 n，结果中排在 A 左边的元素一定是 A 的后 n - 1 个元素当中的。比如 D 选项：A 在结果中的位置是 4，那么结果中排在 A 左边的元素一定只能是 A 的后 3 个元素（即 B C D）当中的，此时符合。但是还要判断以 A 为界，左右两个子问题是否符合此规律。对于左边子问题 D B C ，同理要看 B 的位置，B 在子问题结果中的位置是 2，结果中排在 B 左边的元素一定只能是 B 的后 1 个元素，即出现在 B 的左边一定只能是 C，所以不符合。\n总结：判断原问题是否符合规则，若符合则继续判断子问题是否符合。\n\n通项推导几何法可通过折线法求得通项： 。\n要求：有两种操作即入栈和出栈，要求每种操作的总次数一样，且进行第 k 次出栈前必须先进行至少 k 次入栈。\n假设：一个人从原点出发，入栈是此人沿右上角 45° 走一个单位（一个单位长为 ）。出栈是此人沿右下角 45° 走一个单位。\n因为有入栈和出栈操作的次数相同的限制，所以最后必将到到达点  。\n因为有第 k 次出栈前必须先进行至少 k 次入栈的限制，导致走出来的折线不会跨越 x 轴走到  这条线上。\n\n如果没有限制第 k 次出栈前必须先进行至少 k 次入栈，只要求两种操作各 n 次，那么其不同折线共有  种可能，其中减去不合法的可能就是要求的内容。\n\n对于任意跨越 x 轴的折线情况，找出第一个与  相交的点 k，将 k 点以右的折线根据  对称。可以发现终点最终都会从  对称到 。\n我们可以得出所有跨越了 x 轴的折线总数与从  到  的折线总数相等。\n而从  到  的折线表示的是入栈和出栈的总数是 2n 且出栈的数量比入栈多了 2 次，则出栈 n + 1 次，入栈 n - 1 次。所以其不同折线有  或者  种可能。\n所以合法的折线有  种可能。\n得证  。\n代数法我还不会组合数学，看不明白生成函数！呜呜呜~\n典例\n汽车胡同加油问题一个汽车队在狭窄的路面上行驶，不得超车，但可以进入一个死胡同去加油，然后再插队行驶，共有 n 辆汽车，问共有多少种不同的方式使得车队开出城去？\n\n摞碗问题饭后姐姐洗碗，妹妹把姐姐洗过的碗一个一个放进碗橱摞成一摞。一共有n个不同的碗，洗前也是摞成一摞的，也许因为小妹贪玩而使碗拿进碗橱不及时，姐姐则把洗过的碗摞在旁边，问：小妹摞起的碗有多少种可能的方式？\n\n01 序列问题给出一个 n，要求一个长度为 2n 的 01 序列，使得序列的任意前缀中 1 的个数不少于 0 的个数，有多少个不同的 01 序列?\n\n借书还书问题在图书馆一共 2n 个人在排队，n 个还《面试宝典》一书，n 个在借《面试宝典》一书，图书馆此时没有面试宝典了，求他们有多少种排队的情形？\n\n高矮排队问题2n 个高矮不同的人排成两排，每排必须是从矮到高排列，而且第二排比对应的第一排的人高，问排列方式有多少种?\n\n单调路径问题一位大城市的律师在他住所以北 n 个街区和以东 n 个街区处工作，每天他走 2n 个街区去上班。如果他从不穿越（但可以碰到）从家到办公室的对角线，那么有多少条可能的道路？\n\n找零问题2n 个人要买票价为五元的电影票，每人只买一张，但是售票员没有钱找零。其中 n 个人持有五元，另外 n 个人持有十元，问在不发生找零困难的情况下，有多少种排队方法？\n\n括号匹配问题n 对括号有多少种合法匹配方式？\n\n凸多边形划分在一个 n 边形中，通过不相交于 n 边形内部的对角线，把 n 边形拆分为若干个三角形，问有多少种拆分方案？\n\n圆上线段在圆上选择 2n 个点，将这些点成对连接起来使得所得到的 n 条线段不相交的方法数？\n\n填充阶梯图形用 n 个长方形填充一个高度为 n 的阶梯状图形的方法个数？\n\n二叉树问题a) 由 n 个节点构成的二叉树的个数？b) 有 n + 1 个叶子的二叉树的个数？c) 先序序列为 a b c d 的不同二叉树个数？\n\n\n参考文章n个元素进栈，共有多少种出栈顺序？ - 止战 - 博客园\n卡特兰数的证明及其应用 - _Dinosaur_Po - 博客园\n卡特兰数（Catalan）公式、证明、代码、典例.-CSDN博客\n","categories":["学习笔记","数据结构与算法"],"tags":["栈","卡特兰数"]},{"title":"正则表达式","url":"/posts/2f57a694.html","content":"正则表达式是用字符串描述的一个匹配规则，使用正则表达式可以快速判断给定的字符串是否符合匹配规则。\n\n\n常见匹配规则\n\n\n正则表达式\n含义\n备注\n\n\n\n\\\n转义字符\n常用于转义 \\、(、[、&#123; 等\n\n\n^\n匹配字符串开头（第一个字符之前）\n\n\n\n$\n匹配字符串结尾（最后一个字符之后）\n^A\\d&#123;3&#125;$ 可匹配 A001、A380\n\n\n.\n除 \\n、\\r 之外的任意单个字符\n注意 [.] 只会匹配 . 字符，等价于 \\.\n\n\nA\n指定字符 A\n\n\n\n\\u548c\n指定 Unicode 字符\n\\u548c 可匹配 和\n\n\n\\b\n匹配一个单词边界，即字与空格间的位置\n作用类似于 ^、$，注意 \\bCha 和 Cha\\b 的区别\n\n\n\\B\n\\b 的反义，即非单词边界匹配\n\n\n\n\\d\n数字 0~9\n相当于 [0-9]\n\n\n\\D\n\\d 的反义，即非数字\n相当于 [^0-9]\n\n\n\\w\n大小写字母，数字和下划线\n相当于 [A-Za-z0-9_]\n\n\n\\W\n\\w 的反义\n\n\n\n\\s\n匹配空白字符，如空格、制表符等\n相当于 [ \\t\\v\\r\\n\\f]\n\n\n\\S\n\\s 的反义，即非空白符\n\n\n\n*\n任意个数\nA* 可匹配  、A、AA、AAA、…\n\n\n+\n至少一个\nA+ 可匹配 A、AA、…\n\n\n?\n0 或 1 个（也用于 非贪婪匹配 ）\nA? 可匹配  、A\n\n\n&#123;3&#125;\n指定个数，此处指定为 3 个\nA&#123;3&#125; 可匹配 AAA\n\n\n&#123;2,3&#125;\n指定个数范围\nA&#123;2,3&#125; 可匹配 AA、AAA\n\n\n&#123;2,&#125;\n至少个数，此处为至少 2 个\nA&#123;2,&#125; 可匹配 AA、AAA、AAAA、…\n\n\n&#123;0,2&#125;\n至多个数，此处为至多 2 个\nA&#123;0,2&#125; 可匹配  、A、AA\n\n\nX|Y\n匹配 X 或 Y\n(z|f)ood 可匹配 zood 和 food\n\n\n[ABC]\n匹配 [...] 内的任意单个字符\n[ABC] 可匹配 A、B、C\n\n\n[^ABC]\n匹配除指定字符之外的任意单个字符\n[^ABC] 可匹配 D、1、_\n\n\n[A-C1-3X]\n匹配指定范围内的单个字符\n[A-C1-3XY] 可匹配 A、B、C、1、2、3、X\n\n\n[^A-C]\n匹配指定范围之外的任意单个字符\n[^A-C] 可匹配 D、1、_、…\n\n\nex1(?=ex2)\n查找 ex1，但后面是 ex2\n\n\n\nex1(?!ex2)\n查找 ex1，但后面不是 ex2\n\n\n\n(?&lt;=ex2)ex1\n查找 ex1，但前面是 ex2\n\n\n\n(?&lt;!ex2)ex1\n查找 ex1，但前面不是 ex2\n\n\n\n\n\n可使用 (...) 将子规则括起来\n定位符（如 ^、$、/b、/B）不能与限定符（?、*、+、&#123;2,4&#125; 等）一起使用\n\n\n正则表达式默认使用贪婪匹配：任何一个规则，它总是尽可能多地向后匹配。* 和 + 限定符都是贪婪的，它们会尽可能多的匹配文字，在它们的后面加上一个 ? 可以实现非贪婪或最小匹配。\n修饰符带有修饰符的正则表达式格式：/pattern/flags\n\n\n\n修饰符 flags\n含义\n备注\n\n\n\ni\n不区分大小写\n默认区分大小写\n\n\ng\n全局匹配\n查找所有匹配项，默认找到一项就停止\n\n\nm\n多行匹配\n使边界字符 ^ 和 $ 匹配每一行的开头和结尾\n\n\ns\n特殊字符圆点 . 中包含换行符 \\n\n默认是不包含的\n\n\n非打印字符\n\n\n字符\n含义\n\n\n\n\\cx\n匹配由 x 指明的控制字符。例如 \\cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 &#39;c&#39; 字符。\n\n\n\\t\n匹配一个制表符。等价于 \\x09 和 \\cI\n\n\n\\v\n匹配一个垂直制表符。等价于 \\x0b 和 \\cK\n\n\n\\r\n匹配一个回车符。等价于 \\x0d 和 \\cM\n\n\n\\n\n匹配一个换行符。等价于 \\x0a 和 \\cJ\n\n\n\\f\n匹配一个换页符。等价于 \\x0c 和 \\cL\n\n\n\\s\n匹配任何空白字符。等价于 [ \\t\\v\\r\\n\\f]。注意 Unicode 正则表达式会匹配全角空格符。\n\n\n\\S\n匹配任何非空白字符。等价于 [^ \\t\\v\\r\\n\\f]\n\n\n参考\n廖雪峰的官方网站-正则表达式\n菜鸟教程-正则表达式\n正则表达式手册\n\n","categories":["学习笔记","通用工具"],"tags":["正则表达式"]},{"title":"常用编程语言基础语法对比","url":"/posts/d0f4f654.html","content":"本文将对 Java、Go、Python 等编程语言的基础语法进行对比。\n\n\n导入包\n                \n                    JavaGoPython\n                \n                package com.example.main;import com.example.myapp.MyClass;import com.example.main.TestClass;package mainimport (    &quot;fmt&quot;    &quot;foo/bar&quot; // 导入本地包    myBar &quot;foo/bar&quot; // 别名    &quot;github.com/username/myproject/foo&quot; // 导入三方包)import module_name_1import module_name_2 as aliasfrom module_name_3 import class_name, func_namefrom module_name_4 import *  # 导入所有内容module = __import__(&#x27;module_name_5&#x27;)  # 动态导入\n          \n\n\n控制结构\n                \n                    JavaGoPython\n                \n                if 结构\nif ( condition1 ) &#123;    // ...&#125; else if ( condition2 ) &#123;    // ...&#125; else &#123;    // ...&#125;\n\nswitch 结构，多行语句不需要花括号但需要手动写 break;\nswitch ( val ) &#123;    case val1:        // ...        // ...        break;    case val2:        // ...        break;    default:        // ...&#125;\n\n循环结构\nfor ( int i = 0; i &lt; 10; i++ ) &#123;    count++;&#125;while ( condition ) &#123;    // ...&#125;do &#123;    // ...&#125; while ( condition );\n不需要小括号\n\nif 结构\nif condition1 &#123;    // ...&#125; else if condition2 &#123;    // ...    &#125; else &#123;    // ...&#125;\n\nswitch 结构，多行语句不需要花括号且不需要手动写 break;\nswitch val &#123;    case val1:        // ...        // ...    case val2:        // ...    default:        // ...&#125;\n\n循环结构，没有 while 关键字但有 for - range 结构\nfor i := 0; i &lt; 10; i++ &#123;    // ...&#125;for condition &#123;    // ...&#125;for pos, char := range myStr &#123;    // ...&#125;\n需要冒号，不需要花括号，小括号可省略，\n\nif 结构\nif condition1:    # ...elif condition2:    # ...elif condition3:    # ...else:    # ...\n\n没有 switch 结构，可以使用 and 或 or 来组合多个条件\nif condition1 or condition2:    # ...else:    # ...\n\n循环结构\nfor i in range(10):    # ...for letter in &#x27;Python&#x27;:   print(&quot;当前字母: %s&quot; % letter)while condition:    # ...\n          \n","categories":["学习笔记","编程语言"]},{"title":"Debian 服务器配置备忘","url":"/posts/f7465fc9.html","content":"记录个人 Debian 服务器的配置过程。\n\n软件安装aptdebian | 镜像站使用帮助 | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror\n编辑配置文件：\nsudo - rootvi /etc/apt/sources.list\n\n替换为：\ndeb https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm main contrib non-free non-free-firmware# deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm main contrib non-free non-free-firmwaredeb https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-updates main contrib non-free non-free-firmware# deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-updates main contrib non-free non-free-firmwaredeb https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-backports main contrib non-free non-free-firmware# deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-backports main contrib non-free non-free-firmwaredeb https://mirrors.tuna.tsinghua.edu.cn/debian-security bookworm-security main contrib non-free non-free-firmware# deb-src https://mirrors.tuna.tsinghua.edu.cn/debian-security bookworm-security main contrib non-free non-free-firmware\n\n其中 main contrib non-free non-free-firmware 表示不同类型的软件包。\n\nmain 表示符合 Debian Free Software Guidelines 的包；\ncontrib 是依赖一些非自由软件就才能正常运作的开源软件；\nnon-free 和 non-free-firmware 表示非自由软件。\n\n\n上述这种格式称为传统格式（又称 One-Line-Style 格式）。\n新的 DEB822 格式自 APT 1.1（2015 年发布）起支持，文件后缀为 .sources，存储在 /etc/apt/sources.list.d/ 目录下，格式类似如下：\nTypes: deb deb-srcURIs: https://mirrors.tuna.tsinghua.edu.cn/debianSuites: bookworm bookworm-updates bookworm-backportsComponents: main contrib non-free non-free-firmwareSigned-By: /usr/share/keyrings/debian-archive-keyring.gpgTypes: deb deb-srcURIs: http://security.debian.org/debian-securitySuites: bookworm-securityComponents: mainSigned-By: /usr/share/keyrings/debian-archive-keyring.gpg\n\n安装常用工具：\napt updateapt install vim git wget curl\n\n常用命令：\napt update    # 更新软件索引apt upgrade  # 更新系统中的所有软件包，但不安装额外的软件包或卸载软件包apt full-upgrade # 更新系统中的所有软件包，并且在必要的时候安装额外的软件包或卸载软件包apt install foo   # 安装软件包 foo 和它的全部依赖apt remove foo  # 卸载软件包 fooapt purge foo    # 卸载软件包 foo 和它的配置文件apt list --upgradable  # 列出所有可以更新到新版本的软件包apt search foo  # 找出描述中包含 foo 的软件包apt show foo    # 打印软件包的详细信息apt-cache depends foo    # 打印软件包的依赖apt-cache showpkg foo   # 打印软件包各可用版本的详细信息，以及反向依赖它的软件包\n\ndpkg除了使用 apt 软件管理工具安装软件外，还可以直接使用 dpkg 命令本地安装 deb 软件包\ndeb 包安装与卸载：\ndpkg -i hello.deb       # 安装dpkg -r hello.deb       # 保留配置文件卸载dpkg -P hello.deb       # 清除配置文件卸载dpkg -l                 # 显示已安装程序列表dpkg -l | grep &quot;hello&quot;  # 查询已安装包dpkg -l | grep ^rc      # 查看处于 rc 状态的软件包\ndpkg -l 显示已安装程序列表，其中每行输出的第一列 ii 表示软件包的安装和配置状态，其格式如下：期望状态|当前状态|错误 。\n期望状态有以下几种：\n\nu：即 unknown，软件包未安装且用户未请求安装\ni：即 install，用户请求安装该软件包\nr：即 remove，用户请求卸载该软件包\np：即 purge，用户请求卸载该软件包并清理配置文件\nh：即 hold，用户请求保持续当前软件包版本\n\n当前状态有以下几种：\n\nn：即 not-installed，软件包未安装\ni：即 installed，软件包已安装并完成配置\nc：即 config-files，软件包已经被卸载，但是其配置文件未清理\nu：即 unpacked，软件包已经被解压缩，但还未配置\nf：即 half-configured，配置软件包时出现错误\nw：即 triggers-awaited，触发器等待\nt：即 triggers-pending，触发器未决\n\n错误状态有以下几种：\n\nh：软件包被强制保持\nr：即 reinstall-required，需要卸载并重新安装\nx：软件包被破坏\n\n因此 ii 表示该软件需要安装且已经安装，没有出现错误；iu 表示已经安装该软件，但未正确配置；rc 表示该软件已经被删除，但配置文件未清理。\n一个 deb 包的目录结构如下：\n\nmy.deb\nDEBIAN\ncontrol （存放软件包的作者、版本、描述等信息）\npreinst （安装前执行的脚本）\npostinst （安装后执行的脚本）\nprerm （卸载前执行的脚本）\npostrm （卸载后执行的脚本）\n\n\nusr （存放源码）\nxxxxxx\n\n\n\n\n\n可以使用以下命令对 deb 包进行解压和打包：\ndpkg -x my.deb build  # 解压源码dpkg -e my.deb build  # 解压其中的 DEBIAN 内容dpkg -b build my.deb  # 重新打包为 deb\n\n\nsudo安装：\nsu - rootapt install sudo\n\n配置：\nusermod -aG sudo username #将用户 username 添加到 sudo 组中\n\n或者使用 visudo 命令或者编辑 /etc/sudoers 文件，文中添加 username ALL=(ALL) ALL ，保存文件后注销重新登录。\ndockerdocker-ce | 镜像站使用帮助 | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror\n卸载：\nfor pkg in docker.io docker-doc docker-compose podman-docker containerd runc; do apt-get remove $pkg; done\n\n信任公钥并添加仓库：\ninstall -m 0755 -d /etc/apt/keyringscurl -fsSL https://download.docker.com/linux/debian/gpg | gpg --dearmor -o /etc/apt/keyrings/docker.gpgsudo chmod a+r /etc/apt/keyrings/docker.gpgecho \\  &quot;deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/debian \\  &quot;$(. /etc/os-release &amp;&amp; echo &quot;$VERSION_CODENAME&quot;)&quot; stable&quot; | \\  tee /etc/apt/sources.list.d/docker.list &gt; /dev/null\n\n安装：\nsudo apt updatesudo apt install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin\n\n编辑配置文件：\nsudo vim /etc/docker/daemon.json\n\n增加代理加速地址：\n&#123;  &quot;registry-mirrors&quot;: [    &quot;https://docker.1panel.live&quot;,    &quot;https://docker.ketches.cn&quot;,    &quot;https://hub.iyuu.cn&quot;  ]&#125;\n\n服务启动：\nsudo systemctl restart docker\n\n\n\n常用命令：\nsudo vim docker-compose.yml # 编辑容器配置文件sudo docker compose up -dsudo docker compose downsudo docker exec -it [contianer_name] /bin/bashsudo docker images # 列出所有镜像sudo docker image remove xxx:xxx # 删除指定镜像sudo docker container ps # 列出在运行容器\n\n\n\n网络配置编辑配置文件：\nsudo vim /etc/network/interfaces\n\n增加内容：\nauto enp0s3iface enp0s3 inet staticaddress 192.168.1.240/24network 192.168.1.0broadcast 192.168.1.255gateway 192.168.1.1dns-nameservers 223.5.5.5\n\n服务启动：\nsudo systemctl restart networking.service\n\n常用命令：\nip address # 查看网络接口ip route # 查看路由\n\n\nsmb安装：\nsudo apt updatesudo apt install samba\n\n配置：\nmkdir share # 创建共享文件夹sudo vim /etc/samba/smb.conf # 编辑配置文件\n\n末尾增加：\n[SHARE]comment = My Share Folderpath = /home/username/sharewritable = yesbrowseable = noguest ok = no\n\n服务启动：\nsudo systemctl restart smbd.service\n\n\n\ncrontabDebian 12 已经默认安装了 cron\n安装：\nsudo apt updatesudo apt install cron\n\n常用命令：\ncrontab –e     //修改 crontab 文件，如果文件不存在会自动创建crontab –l      //显示 crontab 文件crontab -r      //删除 crontab 文件crontab -ir     //删除 crontab 文件前提醒用户# 默认使用当前用户，可以使用 -u 指定用户crontab [-u username] -e\n\n\n\nfrpc 自启动创建配置文件：\nsudo vim /etc/systemd/system/frpc.service\n\n添加内容：\n[Unit]Description=Frpc ServiceAfter=network.target[Service]Type=idleExecStart=/home/kecho/frp/frpc -c /home/kecho/frp/frpc.tomlRestart=on-failureRestartSec=30sUser=nobody[Install]WantedBy=multi-user.target\n\n服务启动：\nsudo systemctl daemon-reloadsudo systemctl enable frpc.service\n\n","categories":["折腾记录"],"tags":["Linux","Debian"]},{"title":"Handsome 主题美化教程","url":"/posts/ffa86c2a.html","content":"Handsome 是一款收费的 Typecho 主题，本文给出的 Handsome 主题美化教程收集自网络，部分内容可能随着主题更新而失效。\n\n\n\n首页列表最前方广告位新年倒计时&lt;style&gt;   .gn_box &#123;    border: none;         border-radius: 15px;   &#125;   .gn_box &#123;    padding: 10px 14px;    margin: 10px;    margin-bottom: 20px;    text-align: center;    background-color: #fff;   &#125;   #t_d &#123;    color: #982585;    font-size: 18px;   &#125;   #t_h &#123;     color: #8f79c1;    font-size: 18px;  &#125;   #t_m &#123;     color: #65b4b5;    font-size: 18px;  &#125;   #t_s &#123;    color: #83caa3;    font-size: 18px;   &#125; &lt;/style&gt; &lt;div class=&quot;gn_box&quot;&gt;     &lt;h1&gt;    &lt;font color=#E80017&gt;2&lt;/font&gt;&lt;font color=#D1002E&gt;0&lt;/font&gt;&lt;font color=#BA0045&gt;2&lt;/font&gt;&lt;font color=#A3005C&gt;1&lt;/font&gt;&lt;font  color=#8C0073&gt;年&lt;/font&gt;&lt;font color=#75008A&gt;-&lt;/font&gt;&lt;font color=#5E00A1&gt;新&lt;/font&gt;&lt;font color=#4700B8&gt;年&lt;/font&gt;&lt;font color=#3000CF&gt;倒&lt;/font&gt;&lt;font color=#1900E6&gt;计&lt;/font&gt;&lt;font color=#0200FD&gt;时&lt;/font&gt;  &lt;/h1&gt;  &lt;center&gt;    &lt;div id=&quot;CountMsg&quot; class=&quot;HotDate&quot;&gt;      &lt;span id=&quot;t_d&quot;&gt; 天&lt;/span&gt;&lt;span id=&quot;t_h&quot;&gt; 时&lt;/span&gt;&lt;span id=&quot;t_m&quot;&gt; 分&lt;/span&gt;&lt;span id=&quot;t_s&quot;&gt; 秒&lt;/span&gt;    &lt;/div&gt;  &lt;/center&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;   function getRTime() &#123;         var EndTime = new Date(&#x27;2021/02/12 00:00:00&#x27;);        var NowTime = new Date();        var t = EndTime.getTime() - NowTime.getTime();         var d = Math.floor(t / 1000 / 60 / 60 / 24);         var h = Math.floor(t / 1000 / 60 / 60 % 24);         var m = Math.floor(t / 1000 / 60 % 60);         var s = Math.floor(t / 1000 % 60);       var day = document.getElementById(&quot;t_d&quot;);      if (day != null) &#123;          day.innerHTML = d + &quot; 天&quot;;         &#125;      var hour = document.getElementById(&quot;t_h&quot;);      if (hour != null) &#123;          hour.innerHTML = h + &quot; 时&quot;;        &#125;      var min = document.getElementById(&quot;t_m&quot;);      if (min != null) &#123;          min.innerHTML = m + &quot; 分&quot;;         &#125;      var sec = document.getElementById(&quot;t_s&quot;);      if (sec != null) &#123;          sec.innerHTML = s + &quot; 秒&quot;;      &#125;  &#125;     setInterval(getRTime, 1000);   &lt;/script&gt;\n\n自定义 CSS以下内容添加到后台主题外观设置-开发者设置-自定义 CSS\n头像呼吸环和鼠标悬停旋转放大.img-full &#123;    width: 100px;    border-radius: 50%;    animation: light 4s ease-in-out infinite;    transition: 0.5s;&#125;.img-full:hover &#123;    transform: scale(1.15) rotate(720deg);&#125;@keyframes light &#123;    0% &#123;        box-shadow: 0 0 4px #f00;    &#125;    25% &#123;        box-shadow: 0 0 16px #0f0;    &#125;    50% &#123;        box-shadow: 0 0 4px #00f;    &#125;    75% &#123;        box-shadow: 0 0 16px #0f0;    &#125;    100% &#123;        box-shadow: 0 0 4px #f00;    &#125;&#125;\n\n打赏图标跳动.btn-pay &#123;    animation: star 0.5s ease-in-out infinite alternate;&#125;@keyframes star &#123;    from &#123;        transform: scale(1);    &#125;    to &#123;        transform: scale(1.1);    &#125;&#125;\n\n自定义鼠标指针可以使用下面代码，或者直接下载插件 HoerMouse 使用\nbody &#123;    cursor:url(&#x27;鼠标指针图片链接&#x27;), auto;&#125;select, input, textarea, a, button &#123;    cursor:url(&#x27;鼠标指针图片链接&#x27;), auto;&#125;input[disabled], select[disabled], textarea[disabled], input[readonly], select[readonly] &#123;    cursor:url(&#x27;鼠标指针图片链接&#x27;), auto;&#125;\n\n自定义右侧滚动条/*定义滚动条高宽及背景 高宽分别对应横竖滚动条的尺寸*/::-webkit-scrollbar&#123;    width: 3px;    height: 16px;    background-color: rgba(255,255,255,0);&#125;/*定义滚动条轨道 内阴影+圆角*/::-webkit-scrollbar-track&#123;    -webkit-box-shadow: inset 0 0 6px rgba(0,0,0,0.3);    border-radius: 10px;    background-color: rgba(255,255,255,0);&#125;/*定义滑块 内阴影+圆角*/::-webkit-scrollbar-thumb&#123;    border-radius: 10px;    -webkit-box-shadow: inset 0 0 6px rgba(0,0,0,.3);    background-color: #555;&#125;\n\n首页文章列表悬浮.blog-post .panel:not(article) &#123;    transition: all 0.3s;&#125;.blog-post .panel:not(article):hover &#123;    transform: translateY(-10px);    box-shadow: 0 8px 15px rgba(73, 90, 47, 0.5);&#125;\n\n首页文章列表宽度盒子模型下我感觉页面有点小，但非盒子模型下首页文章列表感觉太宽了，特别在首页设置了大头图情况下，图片看起来就更不美观了，所以可以用以下代码改窄一点。\n.blog-post&#123;  max-width: 900px;  margin: 0 auto;&#125;\n\n首页文章版式阴影化.panel&#123;    box-shadow: 1px 1px 3px 3px rgba(255,255,255, 0.35);    -moz-box-shadow: 1px 1px 3px 3px rgba(255,255,255, 0.35);&#125;.panel:hover&#123;    box-shadow: 1px 1px 3px 3px rgba(135 206 250, 0.35);    -moz-box-shadow: 1px 1px 3px 3px rgba(135 206 250, 0.35);&#125;.panel-small&#123;    box-shadow: 1px 1px 3px 3px rgba(255,255,255, 0.35);    -moz-box-shadow: 1px 1px p3x 3px rgba(255,255,255, 0.35);&#125;.panel-small:hover&#123;    box-shadow: 1px 1px p3x 3px rgba(135 206 250, 0.35);    -moz-box-shadow: 1px 1px 3px 3px rgba(135 206 250, 0.35);&#125;.app.container &#123;box-shadow: 0 0 30px rgba(255, 255, 255, 0.3);&#125;span.baidu-record::before &#123;    font: normal normal normal 12px/1 FontAwesome;    content: &quot;\\f024&quot;;    margin-right: 3px;&#125;\n\n首页文章标题颜色渐变.index-post-title a:hover&#123;     color:rgba(107, 209, 255, 1);     transition:color 0.2s linear&#125;\n\n文章标题居中.panel h2&#123;    text-align: center; &#125;.post-item-foot-icon&#123;    text-align: center;&#125;\n\n文章图片悬停放大.entry-thumbnail &#123;    overflow: hidden;&#125;/*如果想放大并超出范围请删除上面代码*/#post-content img &#123;    border-radius: 10px;    transition: 0.5s;&#125;#post-content img:hover &#123;    transform: scale(1.05);&#125;\n\n文章末尾转载说明可使用插件 Copyright\n自定义 JavaScript以下内容添加到后台主题外观设置-开发者设置-自定义 JavaScript\n鼠标点击爱心! function (e, t, a) &#123;  function n() &#123;    c(&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &#x27;&#x27;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;), o(), r()  &#125;  function r() &#123;    for (var e = 0; e &lt; d.length; e++) d[e].alpha &lt;= 0 ? (t.body.removeChild(d[e].el), d.splice(e, 1)) : (d[e].y--, d[e].scale += .004, d[e].alpha -= .013, d[e].el.style.cssText = &quot;left:&quot; + d[e].x + &quot;px;top:&quot; + d[e].y + &quot;px;opacity:&quot; + d[e].alpha + &quot;;transform:scale(&quot; + d[e].scale + &quot;,&quot; + d[e].scale + &quot;) rotate(45deg);background:&quot; + d[e].color + &quot;;z-index:99999&quot;);    requestAnimationFrame(r)  &#125;  function o() &#123;    var t = &quot;function&quot; == typeof e.onclick &amp;&amp; e.onclick;    e.onclick = function (e) &#123;      t &amp;&amp; t(), i(e)    &#125;  &#125;  function i(e) &#123;    var a = t.createElement(&quot;div&quot;);    a.className = &quot;heart&quot;, d.push(&#123;      el: a,      x: e.clientX - 5,      y: e.clientY - 5,      scale: 1,      alpha: 1,      color: s()    &#125;), t.body.appendChild(a)  &#125;  function c(e) &#123;    var a = t.createElement(&quot;style&quot;);    a.type = &quot;text/css&quot;;    try &#123;      a.appendChild(t.createTextNode(e))    &#125; catch (t) &#123;      a.styleSheet.cssText = e    &#125;    t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a)  &#125;  function s() &#123;    return &quot;rgb(&quot; + ~~(255 * Math.random()) + &quot;,&quot; + ~~(255 * Math.random()) + &quot;,&quot; + ~~(255 * Math.random()) + &quot;)&quot;  &#125;  var d = [];  e.requestAnimationFrame = function () &#123;    return e.requestAnimationFrame || e.webkitRequestAnimationFrame || e.mozRequestAnimationFrame || e.oRequestAnimationFrame || e.msRequestAnimationFrame || function (e) &#123;      setTimeout(e, 1e3 / 60)    &#125;  &#125;(), n()&#125;(window, document);\n\n彩色数字可用于将左侧各分类下文章数目变成彩色数字，右侧博客信息变成彩色，标签变成彩色。如果启用 pjax，添加自定义 JavaScript 的同时还要将代码放入 pjax 函数中，否则无效。\nlet tags = document.querySelectorAll(&quot;#tag_cloud-2 a&quot;);let infos = document.querySelectorAll(&quot;.badge&quot;);let colorArr = [&quot;#428BCA&quot;, &quot;#AEDCAE&quot;, &quot;#ECA9A7&quot;, &quot;#DA99FF&quot;, &quot;#FFB380&quot;, &quot;#D9B999&quot;];tags.forEach(tag =&gt; &#123;    tagsColor = colorArr[Math.floor(Math.random() * colorArr.length)];    tag.style.backgroundColor = tagsColor;&#125;);infos.forEach(info =&gt; &#123;    infosColor = colorArr[Math.floor(Math.random() * colorArr.length)];    info.style.backgroundColor = infosColor;&#125;);\n\n网页标签获得&#x2F;失去焦点时更改标题内容//网页标签获得/失去焦点时更改标题内容var OriginTitile = document.title;var titleTime;document.addEventListener(&quot;visibilitychange&quot;,function() &#123;    if (document.hidden) &#123;        OriginTitile = document.title;        document.title = &quot;怎么走了(；д｀)ゞ&quot;;        clearTimeout(titleTime)    &#125; else &#123;        document.title = &quot;回来了ヾ(◍°∇°◍)ﾉﾞ)&quot;;        titleTime = setTimeout(function() &#123;            document.title = OriginTitile        &#125;,        2000)    &#125;&#125;);\n\n多处组合改动复制弹窗提醒第一步：将 layer.js 保存至自己的服务器上。\n第二步：将以下代码添加到后台主题外观设置-开发者设置-自定义输出 head 头部的 HTML 代码，注意修改引用路径。\n&lt;script src=&quot;https://xxxx/layer.js&quot;&gt;&lt;/script&gt;\n第三步：将以下代码添加到后台主题外观设置-开发者设置-自定义 JavaScript\ndocument.body.oncopy = function() &#123;layer.msg(&#x27;复制成功，若要转载请务必保留本文链接！&#x27;);&#125;;\n\n彩色 3D 云标签\n彩色标签以下内容添加到后台主题外观设置-开发者设置-自定义 CSS\n#tag_cloud-2&gt;div&gt;a &#123;    color: #fff;    text-align: center;    text-overflow: ellipsis;    white-space: nowrap;    padding: 3px 5px;    border: 0;    border-radius: 3px;    display: inline-block;    line-height: 18px;&#125;#tag_cloud-2&gt;div&gt;a:hover &#123;    background: #d02f53;&#125;\n以下内容添加到后台主题外观设置-开发者设置-自定义 JavaScript\nfunction colorfultags()&#123;let tags = document.querySelectorAll(&quot;#tag_cloud-2 a&quot;);let colorArr = [&quot;#f60&quot;, &quot;#45B6F7&quot;, &quot;#15a287&quot;, &quot;#5cb85c&quot;, &quot;#d9534f&quot;, &quot;#567e95&quot;, &quot;#00a67c&quot;, &quot;#b37333&quot;];let count = 1;tags.forEach(tag =&gt; &#123;    tagsColor = colorArr[count%8];    tag.style.backgroundColor = tagsColor;    count++;&#125;);&#125;window.onload=colorfultags();\n\n3D 标签以下内容添加到后台主题外观设置-开发者设置-自定义 CSS\n#tag_cloud-2&gt;div &#123;    position: relative;    width: 200px;    height: 240px;    border: 2px black;    margin: 0 0px 0px 0&#125;#tag_cloud-2&gt;div&gt;a &#123;    position: absolute;&#125;#tag_cloud-2&gt;div&gt;a:hover &#123;    display: block&#125;\n以下内容添加到后台主题外观设置-开发者设置-自定义 JavaScript\n//3d标签，和css搭配使用function around3D() &#123;  var oDiv = document.getElementById(&#x27;tag_cloud-2&#x27;).getElementsByTagName(&#x27;div&#x27;)[0];  if (null == oDiv) &#123;    return  &#125; else &#123;    var radius = 80;    var d = 200;    var dtr = Math.PI / 180;    var mcList = [];    var lasta = 1;    var lastb = 1;    var distr = true;    var tspeed = 11;    var size = 200;    var mouseX = 0;    var mouseY = 10;    var howElliptical = 1;    var aA = null;    var i = 0;    var oTag = null;    aA = oDiv.getElementsByTagName(&#x27;a&#x27;);    for (i = 0; i &lt; aA.length; i++) &#123;      oTag = &#123;&#125;;      aA[i].onmouseover = (function(obj) &#123;        return function() &#123;          obj.on = true;          this.style.zIndex = 9999;          this.style.color = &#x27;#fff&#x27;;          this.style.background = &#x27;#0099ff&#x27;;          this.style.padding = &#x27;5px 5px&#x27;;          this.style.filter = &quot;alpha(opacity=100)&quot;;          this.style.opacity = 1;        &#125;      &#125;)(oTag)      aA[i].onmouseout = (function(obj) &#123;        return function() &#123;          obj.on = false;          this.style.zIndex = obj.zIndex;          this.style.color = &#x27;#fff&#x27;;          this.style.background = &#x27;#30899B&#x27;;          this.style.padding = &#x27;5px&#x27;;          this.style.filter = &quot;alpha(opacity=&quot; + 100 * obj.alpha + &quot;)&quot;;          this.style.opacity = obj.alpha;          this.style.zIndex = obj.zIndex;        &#125;      &#125;)(oTag)      oTag.offsetWidth = aA[i].offsetWidth;      oTag.offsetHeight = aA[i].offsetHeight;      mcList.push(oTag);    &#125;    sineCosine(0, 0, 0);    positionAll();    (function() &#123;      update();      setTimeout(arguments.callee, 40);    &#125;)();    function update() &#123;      var a, b, c = 0;      a = (Math.min(Math.max(-mouseY, -size), size) / radius) * tspeed;      b = (-Math.min(Math.max(-mouseX, -size), size) / radius) * tspeed;      lasta = a;      lastb = b;      if (Math.abs(a) &lt;= 0.01 &amp;&amp; Math.abs(b) &lt;= 0.01) &#123;        return;      &#125;      sineCosine(a, b, c);      for (var i = 0; i &lt; mcList.length; i++) &#123;        if (mcList[i].on) &#123;          continue;        &#125;        var rx1 = mcList[i].cx;        var ry1 = mcList[i].cy * ca + mcList[i].cz * (-sa);        var rz1 = mcList[i].cy * sa + mcList[i].cz * ca;        var rx2 = rx1 * cb + rz1 * sb;        var ry2 = ry1;        var rz2 = rx1 * (-sb) + rz1 * cb;        var rx3 = rx2 * cc + ry2 * (-sc);        var ry3 = rx2 * sc + ry2 * cc;        var rz3 = rz2;        mcList[i].cx = rx3;        mcList[i].cy = ry3;        mcList[i].cz = rz3;        per = d / (d + rz3);        mcList[i].x = (howElliptical * rx3 * per) - (howElliptical * 2);        mcList[i].y = ry3 * per;        mcList[i].scale = per;        var alpha = per;        alpha = (alpha - 0.6) * (10 / 6);        mcList[i].alpha = alpha * alpha * alpha - 0.2;        mcList[i].zIndex = Math.ceil(100 - Math.floor(mcList[i].cz));      &#125;      doPosition();    &#125;    function depthSort() &#123;      var i = 0;      var aTmp = [];      for (i = 0; i &lt; aA.length; i++) &#123;        aTmp.push(aA[i]);      &#125;      aTmp.sort(        function(vItem1, vItem2) &#123;          if (vItem1.cz &gt; vItem2.cz) &#123;            return -1;          &#125; else if (vItem1.cz &lt; vItem2.cz) &#123;            return 1;          &#125; else &#123;            return 0;          &#125;        &#125;      );      for (i = 0; i &lt; aTmp.length; i++) &#123;        aTmp[i].style.zIndex = i;      &#125;    &#125;    function positionAll() &#123;      var phi = 0;      var theta = 0;      var max = mcList.length;      for (var i = 0; i &lt; max; i++) &#123;        if (distr) &#123;          phi = Math.acos(-1 + (2 * (i + 1) - 1) / max);          theta = Math.sqrt(max * Math.PI) * phi;        &#125; else &#123;          phi = Math.random() * (Math.PI);          theta = Math.random() * (2* Math.PI);        &#125;        mcList[i].cx = radius * Math.cos(theta) * Math.sin(phi);        mcList[i].cy = radius * Math.sin(theta) * Math.sin(phi);        mcList[i].cz = radius * Math.cos(phi);        aA[i].style.left = mcList[i].cx + oDiv.offsetWidth / 2 - mcList[i].offsetWidth / 2 + &#x27;px&#x27;;        aA[i].style.top = mcList[i].cy + oDiv.offsetHeight / 2 - mcList[i].offsetHeight / 2 + &#x27;px&#x27;;      &#125;    &#125;    function doPosition() &#123;      var l = oDiv.offsetWidth / 2;      var t = oDiv.offsetHeight / 2;      for (var i = 0; i &lt; mcList.length; i++) &#123;        if (mcList[i].on) &#123;          continue;        &#125;        var aAs = aA[i].style;        if (mcList[i].alpha &gt; 0.1) &#123;          if (aAs.display != &#x27;&#x27;)            aAs.display = &#x27;&#x27;;        &#125; else &#123;          if (aAs.display != &#x27;none&#x27;)            aAs.display = &#x27;none&#x27;;          continue;        &#125;        aAs.left = mcList[i].cx + l - mcList[i].offsetWidth / 2 + &#x27;px&#x27;;        aAs.top = mcList[i].cy + t - mcList[i].offsetHeight / 2 + &#x27;px&#x27;;          aAs.filter = &quot;alpha(opacity=&quot; + 100 * mcList[i].alpha + &quot;)&quot;;        aAs.zIndex = mcList[i].zIndex;        aAs.opacity = mcList[i].alpha;      &#125;    &#125;    function sineCosine(a, b, c) &#123;      sa = Math.sin(a * dtr);      ca = Math.cos(a * dtr);      sb = Math.sin(b * dtr);      cb = Math.cos(b * dtr);      sc = Math.sin(c * dtr);      cc = Math.cos(c * dtr);    &#125;  &#125;&#125;window.onload = around3D();\n\n如果启用了 pjax ，要实现 3D 彩色标签，则保持上面两个自定义 CSS 不变，将上面两个自定义 JavaScript 删掉，替换成下面这个自定义 JavaScript，然后后台 pjax 回调函数加上 colorfultags();around3D();\n\nfunction colorfultags()&#123;    let tags = document.querySelectorAll(&quot;#tag_cloud-2 a&quot;);    let colorArr = [&quot;#f60&quot;, &quot;#45B6F7&quot;, &quot;#15a287&quot;, &quot;#5cb85c&quot;, &quot;#d9534f&quot;, &quot;#567e95&quot;, &quot;#00a67c&quot;, &quot;#b37333&quot;];    let count = 1;    tags.forEach(tag =&gt; &#123;        tagsColor = colorArr[count%8];        tag.style.backgroundColor = tagsColor;        count++;    &#125;);&#125;function around3D() &#123;    var oDiv = document.getElementById(&#x27;tag_cloud-2&#x27;).getElementsByTagName(&#x27;div&#x27;)[0];    if (null == oDiv) &#123;        return;    &#125; else &#123;        var radius = 80;        var d = 200;        var dtr = Math.PI / 180;        var mcList = [];        var lasta = 1;        var lastb = 1;        var distr = true;        var tspeed = 11;        var size = 200;        var mouseX = 0;        var mouseY = 10;        var howElliptical = 1;        var aA = null;        var i = 0;        var oTag = null;        aA = oDiv.getElementsByTagName(&#x27;a&#x27;);        for (i = 0; i &lt; aA.length; i++) &#123;            oTag = &#123;&#125;;            aA[i].onmouseover = (function(obj) &#123;                return function() &#123;                    obj.on = true;                    this.style.zIndex = 9999;                    this.style.color = &#x27;#fff&#x27;;                    this.style.background = &#x27;#0099ff&#x27;;                    this.style.padding = &#x27;5px 5px&#x27;;                    this.style.filter = &quot;alpha(opacity=100)&quot;;                    this.style.opacity = 1;                  &#125;              &#125;)(oTag)            aA[i].onmouseout = (function(obj) &#123;                return function() &#123;                    obj.on = false;                    this.style.zIndex = obj.zIndex;                    this.style.color = &#x27;#fff&#x27;;                    this.style.background = &#x27;#30899B&#x27;;                    this.style.padding = &#x27;5px&#x27;;                    this.style.filter = &quot;alpha(opacity=&quot; + 100 * obj.alpha + &quot;)&quot;;                    this.style.opacity = obj.alpha;                    this.style.zIndex = obj.zIndex;                &#125;            &#125;)(oTag)            oTag.offsetWidth = aA[i].offsetWidth;            oTag.offsetHeight = aA[i].offsetHeight;            mcList.push(oTag);        &#125;        sineCosine(0, 0, 0);        positionAll();        (function() &#123;            update();            setTimeout(arguments.callee, 40);        &#125;)();        function update() &#123;            var a, b, c = 0;            a = (Math.min(Math.max(-mouseY, -size), size) / radius) * tspeed;            b = (-Math.min(Math.max(-mouseX, -size), size) / radius) * tspeed;            lasta = a;            lastb = b;            if (Math.abs(a) &lt;= 0.01 &amp;&amp; Math.abs(b) &lt;= 0.01) &#123;                return;            &#125;            sineCosine(a, b, c);            for (var i = 0; i &lt; mcList.length; i++) &#123;                if (mcList[i].on) &#123;                    continue;                &#125;                var rx1 = mcList[i].cx;                var ry1 = mcList[i].cy * ca + mcList[i].cz * (-sa);                var rz1 = mcList[i].cy * sa + mcList[i].cz * ca;                var rx2 = rx1 * cb + rz1 * sb;                var ry2 = ry1;                var rz2 = rx1 * (-sb) + rz1 * cb;                var rx3 = rx2 * cc + ry2 * (-sc);                var ry3 = rx2 * sc + ry2 * cc;                var rz3 = rz2;                mcList[i].cx = rx3;                mcList[i].cy = ry3;                mcList[i].cz = rz3;                per = d / (d + rz3);                mcList[i].x = (howElliptical * rx3 * per) - (howElliptical * 2);                mcList[i].y = ry3 * per;                mcList[i].scale = per;                var alpha = per;                alpha = (alpha - 0.6) * (10 / 6);                mcList[i].alpha = alpha * alpha * alpha - 0.2;                mcList[i].zIndex = Math.ceil(100 - Math.floor(mcList[i].cz));            &#125;            doPosition();        &#125;        function depthSort() &#123;            var i = 0;            var aTmp = [];            for (i = 0; i &lt; aA.length; i++) &#123;                aTmp.push(aA[i]);            &#125;            aTmp.sort(                function(vItem1, vItem2) &#123;                    if (vItem1.cz &gt; vItem2.cz) &#123;                        return -1;                    &#125; else if (vItem1.cz &lt; vItem2.cz) &#123;                        return 1;                    &#125; else &#123;                        return 0;                    &#125;                &#125;            );            for (i = 0; i &lt; aTmp.length; i++) &#123;                aTmp[i].style.zIndex = i;            &#125;        &#125;        function positionAll() &#123;            var phi = 0;            var theta = 0;            var max = mcList.length;            for (var i = 0; i &lt; max; i++) &#123;                if (distr) &#123;                    phi = Math.acos(-1 + (2 * (i + 1) - 1) / max);                    theta = Math.sqrt(max * Math.PI) * phi;                &#125; else &#123;                    phi = Math.random() * (Math.PI);                    theta = Math.random() * (2 * Math.PI);                &#125;                mcList[i].cx = radius * Math.cos(theta) * Math.sin(phi);                mcList[i].cy = radius * Math.sin(theta) * Math.sin(phi);                mcList[i].cz = radius * Math.cos(phi);                aA[i].style.left = mcList[i].cx + oDiv.offsetWidth / 2 - mcList[i].offsetWidth / 2 + &#x27;px&#x27;;                aA[i].style.top = mcList[i].cy + oDiv.offsetHeight / 2 - mcList[i].offsetHeight / 2 + &#x27;px&#x27;;            &#125;        &#125;        function doPosition() &#123;            var l = oDiv.offsetWidth / 2;            var t = oDiv.offsetHeight / 2;            for (var i = 0; i &lt; mcList.length; i++) &#123;                if (mcList[i].on) &#123;                    continue;                &#125;                var aAs = aA[i].style;                if (mcList[i].alpha &gt; 0.1) &#123;                    if (aAs.display != &#x27;&#x27;)                        aAs.display = &#x27;&#x27;;                &#125; else &#123;                    if (aAs.display != &#x27;none&#x27;)                        aAs.display = &#x27;none&#x27;;                    continue;                &#125;                aAs.left = mcList[i].cx + l - mcList[i].offsetWidth / 2 + &#x27;px&#x27;;                aAs.top = mcList[i].cy + t - mcList[i].offsetHeight / 2 + &#x27;px&#x27;;                aAs.filter = &quot;alpha(opacity=&quot; + 100 * mcList[i].alpha + &quot;)&quot;;                aAs.zIndex = mcList[i].zIndex;                aAs.opacity = mcList[i].alpha;            &#125;        &#125;        function sineCosine(a, b, c) &#123;            sa = Math.sin(a * dtr);            ca = Math.cos(a * dtr);            sb = Math.sin(b * dtr);            cb = Math.cos(b * dtr);            sc = Math.sin(c * dtr);            cc = Math.cos(c * dtr);        &#125;    &#125;&#125;\n\n文件改动左侧导航全站友链显示头像在 aside.php 文件中大约 213 行左右 “使用links插件，输出全站友链” 位置下方修改代码，在 php 代码中的 a 标签内加上：\n&lt;img style=\\&quot;width:18px;height:18px;border-radius:50%;margin-right:3px;\\&quot; src=\\&quot;&#123;image&#125;\\&quot; /&gt;\n\n左、右下角彩色版权声明找到主题文件夹下 handsomecomponentfooter.php 文件，找到下方这段代码（在文件中可按 Ctrl+F 进行查找）：\nPowered by &lt;a target=&quot;_blank&quot; href=&quot;http://www.typecho.org&quot;&gt;Typecho&lt;/a&gt; | Theme by &lt;a target=&quot;_blank&quot;href=&quot;https://www.ihewro.com/archives/489/&quot;&gt;handsome&lt;/a&gt;\n修改为:\n&lt;div class=&quot;wrapper bg-light&quot;&gt;      &lt;!--右下角--&gt;    &lt;span class=&quot;pull-right hidden-xs text-ellipsis&quot;&gt;        &lt;?php $this-&gt;options-&gt;BottomInfo(); ?&gt;        &lt;div class=&quot;github-badge&quot;&gt;            &lt;a href=&quot;http://www.typecho.org&quot; title=&quot;Typecho&quot; target=&quot;_blank&quot;&gt;                &lt;span class=&quot;badge-subject&quot;&gt;Powered by&lt;/span&gt;&lt;span class=&quot;badge-value bg-blue&quot;&gt;Typecho&lt;/span&gt;            &lt;/a&gt;        &lt;/div&gt;        &lt;span&gt; | &lt;/span&gt;        &lt;div class=&quot;github-badge&quot;&gt;            &lt;a href=&quot;https://www.ihewro.com/archives/489/&quot; title=&quot;Handsome&quot; target=&quot;_blank&quot;&gt;                &lt;span class=&quot;badge-subject&quot;&gt;Theme by&lt;/span&gt;&lt;span class=&quot;badge-value bg-green&quot;&gt;Handsome&lt;/span&gt;            &lt;/a&gt;        &lt;/div&gt;    &lt;/span&gt;      &lt;!--左下角--&gt;    &lt;span class=&quot;text-ellipsis&quot;&gt;        &lt;?php $this-&gt;options-&gt;BottomleftInfo(); ?&gt;        &lt;div class=&quot;github-badge&quot;&gt;            &lt;a href=&quot;https://blog.kecho.top&quot; title=&quot;©2022 Kecho&quot; target=&quot;_blank&quot;&gt;                &lt;span class=&quot;badge-subject&quot;&gt;Copyright&lt;/span&gt;&lt;span class=&quot;badge-value bg-blue&quot;&gt;©2022 Kecho&lt;/span&gt;            &lt;/a&gt;        &lt;/div&gt;        &lt;span&gt; | &lt;/span&gt;        &lt;div class=&quot;github-badge&quot;&gt;            &lt;a href=&quot;http://www.beian.miit.gov.cn&quot; title=&quot;赣ICP备 20004569号-1&quot; target=&quot;_blank&quot;&gt;                &lt;span class=&quot;badge-subject&quot;&gt;备案号&lt;/span&gt;&lt;span class=&quot;badge-value bg-green&quot;&gt;赣ICP备 20004569号-1&lt;/span&gt;            &lt;/a&gt;        &lt;/div&gt;    &lt;/span&gt;&lt;/div&gt;\n然后在后台主题外观设置-开发者设置-自定义 CSS中添加：\n/*最底部版权声明样式*/.github-badge &#123;    display: inline-block;    border-radius: 4px;    text-shadow: none;    font-size: 12px;    color: #fff;    line-height: 14px;    background-color: #abbac3;&#125;.github-badge .badge-subject &#123;    display: inline-block;    background-color: #4d4d4d;    padding: 4px 4px 4px 6px;    border-top-left-radius: 4px;    border-bottom-left-radius: 4px&#125;.github-badge .badge-value &#123;    display: inline-block;    padding: 4px 6px 4px 4px;    border-top-right-radius: 4px;    border-bottom-right-radius: 4px&#125;.github-badge .bg-blue &#123;    background-color: #007ec6&#125;.github-badge .bg-orange &#123;    background-color: #ffa500&#125;.github-badge .bg-red &#123;    background-color: #f00&#125;.github-badge .bg-green &#123;    background-color: #3bca6e&#125;.github-badge .bg-purple &#123;    background-color: #ab34e9&#125;\n\n网站顶部彩虹条第一步：将以下代码添加到后台主题外观设置-开发者设置-自定义 CSS\n.gundongtiao&#123;    animation: gundongtiao 1s infinite linear;    height:2px;    top:0;    left:0;    position: fixed;    width:100%;    z-index:9999;&#125;@keyframes gundongtiao&#123;    0%&#123;        background: #000 linear-gradient(to left, #4cd964, #5ac8fa, #007aff, #34aadc, #5856d6, #ff2d55);    &#125;    20%&#123;        background: #000 linear-gradient(to left, #ff2d55,#4cd964, #5ac8fa, #007aff, #34aadc,#5856d6);    &#125;    40%&#123;        background: #000 linear-gradient(to left, #5856d6,#ff2d55,#4cd964, #5ac8fa, #007aff, #34aadc);    &#125;    60%&#123;        background: #000 linear-gradient(to left, #34aadc,#5856d6,#ff2d55,#4cd964, #5ac8fa, #007aff);    &#125;    80%&#123;        background: #000 linear-gradient(to left, #007aff,#34aadc,#5856d6,#ff2d55,#4cd964, #5ac8fa);    &#125;    100%&#123;        background: #000 linear-gradient(to left, #5ac8fa,#007aff,#34aadc,#5856d6,#ff2d55,#4cd964);    &#125;&#125;\n第二步：在网站文件 footer.php (文件路径为 handsome/component/footer.php )末尾添加：\n&lt;div class=&quot;gundongtiao&quot;&gt;&lt;/div&gt;\n\n添加访客 3D 地球找到 handsome/component/sidebar.php 下方代码位置：\n&lt;li class=&quot;list-group-item text-second&quot;&gt;&lt;span class=&quot;blog-info-icons&quot;&gt; &lt;i data-feather=&quot;activity&quot;&gt;&lt;/i&gt;&lt;/span&gt;     &lt;span class=&quot;badge         pull-right&quot;&gt;&lt;?php echo Utils::getLatestTime($this); ?&gt;&lt;/span&gt;&lt;?php _me(&quot;最后活动&quot;) ?&gt;&lt;/li&gt;    &lt;/ul&gt; &lt;/section&gt; &lt;!--插入位置--&gt; &lt;?php endif; ?&gt; &lt;?php if ($this-&gt;options-&gt;adContentSidebar != &quot;&quot;): ?&gt; &lt;!--广告位置--&gt;     &lt;section id=&quot;a_d_sidebar&quot; class=&quot;widget widget_categories wrapper-md clear&quot;&gt;         &lt;h5 class=&quot;widget-title m-t-none text-md&quot;&gt;&lt;?php _me(&quot;广告&quot;) ?&gt;&lt;/h5&gt;         &lt;?php $this-&gt;options-&gt;adContentSidebar(); ?&gt;    &lt;/section&gt; &lt;?php endif; ?&gt;\n插入以下代码：（可以修改其中的 height 来调整大小）\n&lt;!--自定义访客地球--&gt;&lt;section id=&quot;tag_cloud-2&quot; class=&quot;widget widget_tag_cloud wrapper-md clear&quot;&gt;    &lt;h3 class=&quot;widget-title m-t-none text-md&quot;&gt;访客统计&lt;/h3&gt;    &lt;div id=&quot;visitors&quot; class=&quot;tags l-h-2x&quot; style=&quot;width:auto;height:185px;&quot;&gt;&lt;/div&gt;&lt;/section&gt;\n然后去 RevolverMaps 找自己喜欢的地球样式，并且把它给的 JavaScript 代码复制下来，然后将复制的代码进行转义，即将 / 改为 \\/ ，将 &quot; 改为 \\&quot;，将转义后的代码和下方代码合并在一起，放到后台主题外观设置-开发者设置-自定义 JavaScript。\n$(document).ready(function()&#123;$(&quot;#visitors&quot;).append(&quot;这里是您在 RevolverMaps 地球网站上复制的转义后的代码&quot;);&#125;);$(document).on(&#x27;pjax:complete&#x27;, function() &#123;$(&#x27;#morphing&#x27;).tooltip(&#x27;show&#x27;); $(&quot;#visitors&quot;).append(&quot;这里是您在 RevolverMaps 地球网站上复制的转义后的代码&quot;);&#125;);\n如果你不会转义，也可以直接使用我转义好的：\n&lt;script type=\\&quot;text/javascript\\&quot; src=\\&quot;//rf.revolvermaps.com/0/0/8.js?i=51frwlq4tnv&amp;m=0&amp;c=ff0000&amp;cr1=ffffff&amp;f=arial&amp;l=33&amp;bv=65\\&quot; async=\\&quot;async\\&quot;&gt;&lt;\\/script&gt;\n\n评论框打字特效详见 网页输入框打字特效\n左侧导航栏输出优化详见 Handsome 魔改教程：左侧边栏输出优化\n","categories":["折腾记录"],"tags":["Handsome","Typecho"]},{"title":"Windows 本地部署 DeepSeek 大模型","url":"/posts/8bd9618c.html","content":"本文介绍如何通过 Ollama 部署 DeepSeek-R1 蒸馏版。\n\n\n\n安装 DeepSeek去官网下载 Ollama 安装程序，使用 OllamaSetup.exe /DIR=D:\\Software\\Ollama 可指定安装路径。\nOllama 安装后执行 ollama run deepseek-r1:14b 即可运行 DeepSeek-R1-Distill-Qwen-14B，可以替换数字以安装不同数据集大小的模型，更多信息见 Ollama DeepSeek-R1。\n安装 open-webui运行成功后默认是通过命令行进行交互，可以利用安装 open-webui 提供网页交互入口，此处使用 pip 安装（依赖 python 3.11 ）：\n# 需已安装 python 3.11pip install open-webuiopen-webui serve\n\n你也可以使用 docker 安装，更多信息详见 Open WebUI 文档。\n参考文章\nOllama Deepseek-R1\nOpen WebUI 文档\n\n","categories":["折腾记录"],"tags":["Windows","DeepSeek","大模型","AI"]},{"title":"Windows 注册表备忘","url":"/posts/e36ef7eb.html","content":"记录 Windows 系统常用注册表。\n\n系统代理记录清除删除 HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings 中 ProxyServer 和 ProxyOverride 的值\n共享网络默认网关修改修改 HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\SharedAccess\\Parameters 中 ScopeAddress 和 ScopeAddressBackup 的值\nRDP 默认端口修改修改 HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp 中 PortNumber 的值\nWebdav 挂载支持 http修改 HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\WebClient\\Parameters 中 BasicAuthLevel 的值为 2，然后重新启动计算机\n开机自启项可使用 autoruns 管理开机自启项。\nHKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\RunHKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnceHKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunHKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnceHKEY_LOCAL_MACHINE\\SOFTWARE\\WOW6432Node\\Microsoft\\Windows\\CurrentVersion\\Run\n","categories":["折腾记录"],"tags":["Windows","注册表"]},{"title":"KeepassDx 的魔法键盘适配小米手机键盘全面屏优化","url":"/posts/ca3e9532.html","content":"本文将通过修改包名的方式使 KeepassDx 的魔法键盘适配小米手机键盘全面屏优化。\n\n\n\n前情提要密码管理工具 KeepassDX 填充密码时可以使用魔法键盘填充，防止密码被第三方输入法读取，但是切换输入法需要去设置应用手动切换，十分麻烦。\n小米手机在 “设置 -&gt; 更多设置 -&gt; 语言与输入法” 中打开 “全面屏键盘优化” 能够实现快捷切换输入法，但是目前只支持三个小米版输入法，分别是百度输入法小米版、搜狗输入法小米版、讯飞输入法小米版。\n有人对其实现的原理进行了分析，发现是系统是根据包名来判断的，那我们可以把包名修改成其中之一，也就能够实现快捷切换了。\n操作步骤1.电脑新建文件夹 demo，下载 反编译工具 apktool 到其中并重命名为 apktool.apk，下载 KeePassDX 安装包 到其中并重命名为 KeePassDX.apk，下载 脚本文件 到其中并重命名为 apktool.bat，然后双击脚本文件。\n2.进入 demo 目录下执行命令：apktool d KeePassDX.apk 进行解包。\n3.打开 KeePassDX 目录中的 AndroidManifest.xml 文件，将第一行中 package=&quot;com.kunzisoft.keepass.libre&quot; 改为 package=&quot;com.iflytek.inputmethod.miui&quot;。\n\n包名在 com.iflytek.inputmethod.miui，com.sohu.inputmethod.sogou.xiaomi，com.baidu.input_mi 三个中选一个，不要和正常在用的键盘包名重复\n\n4.执行命令：apktool b &quot;KeePassDX&quot; -o KeePassDX-new.apk 将文件重新打包。\n5.手机下载并安装 MT 管理器\n6.将 KeePassDX-new.apk 发送到手机，打开 MT 管理器，长按文件选择 “签名”。\n7.安装签名后的文件。\n安装完成后，去系统设置里面启用魔法键盘，之后就能快速切换键盘实现填充密码了。\n参考文章KeepassDx的魔法键盘适配小米全面屏优化 - 三点一圆 - 博客园\n","categories":["折腾记录"],"tags":["Keepass","Android"]}]